[
  {
    "path": "run_tests.py",
    "code": [
      "import unittest\n",
      "import os\n",
      "import sys\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    os.environ[\"DEBUG_MODE\"] = \"True\"\n",
      "\n",
      "    # Change the current working directory to 'tests'\n",
      "    os.chdir('tests')\n",
      "\n",
      "    # Create a test suite combining all test cases\n",
      "    loader = unittest.TestLoader()\n",
      "    suite = loader.discover(start_dir='.', pattern='test*.py')\n",
      "\n",
      "    # Create a test runner that will run the test suite\n",
      "    runner = unittest.TextTestRunner()\n",
      "    result = runner.run(suite)\n",
      "\n",
      "    # Exit with a non-zero exit code if tests failed\n",
      "    if not result.wasSuccessful():\n",
      "        sys.exit(1)\n"
    ],
    "startline": 1,
    "endline": 21
  },
  {
    "path": "setup.py",
    "code": [
      "from setuptools import setup, find_packages\n",
      "\n",
      "# Read the contents of your requirements file\n",
      "with open('requirements.txt') as f:\n",
      "    requirements = f.read().splitlines()\n",
      "\n",
      "setup(\n",
      "    name='agency-swarm',\n",
      "    version='0.3.0',\n",
      "    author='VRSEN',\n",
      "    author_email='me@vrsen.ai',\n",
      "    description='An opensource agent orchestration framework built on top of the latest OpenAI Assistants API.',\n",
      "    long_description=open('README.md', encoding='utf-8').read(),\n",
      "    long_description_content_type='text/markdown',\n",
      "    url='https://github.com/VRSEN/agency-swarm',\n",
      "    packages=find_packages(exclude=['tests', 'tests.*']),\n",
      "    install_requires=requirements,\n",
      "    classifiers=[\n",
      "        'Intended Audience :: Developers',\n",
      "        'Topic :: Software Development :: Build Tools',\n",
      "        'License :: OSI Approved :: MIT License',\n",
      "    ],\n",
      "    entry_points = {\n",
      "        'console_scripts': ['agency-swarm=agency_swarm.cli:main'],\n",
      "    },\n",
      "    python_requires='>=3.7',\n",
      ")\n"
    ],
    "startline": 1,
    "endline": 27
  },
  {
    "path": "agency_swarm/cli.py",
    "code": [
      "import argparse\n",
      "import os\n",
      "from dotenv import load_dotenv\n",
      "from agency_swarm.util.helpers import list_available_agents\n",
      "\n",
      "\n",
      "def main():\n",
      "    parser = argparse.ArgumentParser(description='Agency Swarm CLI.')\n",
      "\n",
      "    subparsers = parser.add_subparsers(dest='command', help='Utility commands to simplify the agent creation process.')\n",
      "    subparsers.required = True\n",
      "\n",
      "    # create-agent-template\n",
      "    create_parser = subparsers.add_parser('create-agent-template', help='Create agent template folder locally.')\n",
      "    create_parser.add_argument('--path', type=str, default=\"./\", help='Path to create agent folder.')\n",
      "    create_parser.add_argument('--use_txt', action='store_true', default=False,\n",
      "                               help='Use txt instead of md for instructions and manifesto.')\n",
      "    create_parser.add_argument('--name', type=str, help='Name of agent.')\n",
      "    create_parser.add_argument('--description', type=str, help='Description of agent.')\n",
      "\n",
      "    # genesis-agency\n",
      "    genesis_parser = subparsers.add_parser('genesis', help='Start genesis agency.')\n",
      "    genesis_parser.add_argument('--openai_key', default=None, type=str, help='OpenAI API key.')\n",
      "    genesis_parser.add_argument('--with_browsing', default=False, action='store_true',\n",
      "                                help='Enable browsing agent.')\n",
      "\n",
      "    # import-agent\n",
      "    import_parser = subparsers.add_parser('import-agent', help='Import pre-made agent by name to a local directory.')\n",
      "    available_agents = list_available_agents()\n",
      "    import_parser.add_argument('--name', type=str, required=True, choices=available_agents, help='Name of the agent to import.')\n",
      "    import_parser.add_argument('--destination', type=str, default=\"./\", help='Destination path to copy the agent files.')\n",
      "\n",
      "    args = parser.parse_args()\n",
      "\n",
      "    if args.command == \"create-agent-template\":\n",
      "        from agency_swarm.util import create_agent_template\n",
      "        create_agent_template(args.name, args.description, args.path, args.use_txt)\n",
      "    elif args.command == \"genesis\":\n",
      "        load_dotenv()\n",
      "        if not os.getenv('OPENAI_API_KEY') and not args.openai_key:\n",
      "            print(\"OpenAI API key not set. \"\n",
      "                  \"Please set it with --openai_key argument or by setting OPENAI_API_KEY environment variable.\")\n",
      "            return\n",
      "\n",
      "        if args.openai_key:\n",
      "            from agency_swarm import set_openai_key\n",
      "            set_openai_key(args.openai_key)\n",
      "\n",
      "        from agency_swarm.agency.genesis import GenesisAgency\n",
      "        agency = GenesisAgency(with_browsing=args.with_browsing)\n",
      "        agency.run_demo()\n",
      "    elif args.command == \"import-agent\":\n",
      "        from agency_swarm.util import import_agent\n",
      "        import_agent(args.name, args.destination)\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    main()\n"
    ],
    "startline": 1,
    "endline": 58
  },
  {
    "path": "agency_swarm/__init__.py",
    "code": [
      "from .agency import Agency\n",
      "from .agents import Agent\n",
      "from .tools import BaseTool\n",
      "from .util import set_openai_key\n",
      "from .util import set_openai_client\n",
      "from .util import get_openai_client\n",
      "from .util.streaming import AgencyEventHandler\n",
      "from .util import llm_validator\n"
    ],
    "startline": 1,
    "endline": 8
  },
  {
    "path": "agency_swarm/agency/agency.py",
    "code": [
      "import inspect\n",
      "import json\n",
      "import os\n",
      "import queue\n",
      "import threading\n",
      "import uuid\n",
      "from enum import Enum\n",
      "from typing import Any, Callable, Dict, List, Literal, Optional, Type, TypeVar, TypedDict, Union\n",
      "\n",
      "from openai.lib._parsing._completions import type_to_response_format_param\n",
      "from openai.types.beta.threads import Message\n",
      "from openai.types.beta.threads.runs import RunStep\n",
      "from openai.types.beta.threads.runs.tool_call import (\n",
      "    CodeInterpreterToolCall,\n",
      "    FileSearchToolCall,\n",
      "    FunctionToolCall,\n",
      "    ToolCall,\n",
      ")\n",
      "from pydantic import BaseModel, Field, field_validator, model_validator\n",
      "from rich.console import Console\n",
      "from typing_extensions import override\n",
      "\n",
      "from agency_swarm.agents import Agent\n",
      "from agency_swarm.messages import MessageOutput\n",
      "from agency_swarm.messages.message_output import MessageOutputLive\n",
      "from agency_swarm.threads import Thread\n",
      "from agency_swarm.tools import BaseTool, CodeInterpreter, FileSearch\n",
      "from agency_swarm.user import User\n",
      "from agency_swarm.util.errors import RefusalError\n",
      "from agency_swarm.util.files import get_tools, get_file_purpose\n",
      "from agency_swarm.util.shared_state import SharedState\n",
      "from agency_swarm.util.streaming import AgencyEventHandler\n",
      "\n",
      "console = Console()\n",
      "\n",
      "T = TypeVar('T', bound=BaseModel)\n",
      "\n",
      "class SettingsCallbacks(TypedDict):\n",
      "    load: Callable[[], List[Dict]]\n",
      "    save: Callable[[List[Dict]], Any]\n",
      "\n",
      "\n",
      "class ThreadsCallbacks(TypedDict):\n",
      "    load: Callable[[], Dict]\n",
      "    save: Callable[[Dict], Any]\n",
      "\n",
      "\n",
      "class Agency:\n",
      "    ThreadType = Thread\n",
      "    send_message_tool_description = \"\"\"Use this tool to facilitate direct, synchronous communication between specialized agents within your agency. When you send a message using this tool, you receive a response exclusively from the designated recipient agent. To continue the dialogue, invoke this tool again with the desired recipient agent and your follow-up message. Remember, communication here is synchronous; the recipient agent won't perform any tasks post-response. You are responsible for relaying the recipient agent's responses back to the user, as the user does not have direct access to these replies. Keep engaging with the tool for continuous interaction until the task is fully resolved. Do not send more than 1 message at a time.\"\"\"\n",
      "    send_message_tool_description_async = \"\"\"Use this tool for asynchronous communication with other agents within your agency. Initiate tasks by messaging, and check status and responses later with the 'GetResponse' tool. Relay responses to the user, who instructs on status checks. Continue until task completion.\"\"\"\n",
      "\n",
      "    def __init__(self,\n",
      "                 agency_chart: List,\n",
      "                 shared_instructions: str = \"\",\n",
      "                 shared_files: Union[str, List[str]] = None,\n",
      "                 async_mode: Literal['threading', \"tools_threading\"] = None,\n",
      "                 settings_path: str = \"./settings.json\",\n",
      "                 settings_callbacks: SettingsCallbacks = None,\n",
      "                 threads_callbacks: ThreadsCallbacks = None,\n",
      "                 temperature: float = 0.3,\n",
      "                 top_p: float = 1.0,\n",
      "                 max_prompt_tokens: int = None,\n",
      "                 max_completion_tokens: int = None,\n",
      "                 truncation_strategy: dict = None,\n",
      "                 ):\n",
      "        \"\"\"\n",
      "        Initializes the Agency object, setting up agents, threads, and core functionalities.\n",
      "\n",
      "        Parameters:\n",
      "            agency_chart: The structure defining the hierarchy and interaction of agents within the agency.\n",
      "            shared_instructions (str, optional): A path to a file containing shared instructions for all agents. Defaults to an empty string.\n",
      "            shared_files (Union[str, List[str]], optional): A path to a folder or a list of folders containing shared files for all agents. Defaults to None.\n",
      "            async_mode (str, optional): Specifies the mode for asynchronous processing. In \"threading\" mode, all sub-agents run in separate threads. In \"tools_threading\" mode, all tools run in separate threads, but agents do not. Defaults to None.\n",
      "            settings_path (str, optional): The path to the settings file for the agency. Must be json. If file does not exist, it will be created. Defaults to None.\n",
      "            settings_callbacks (SettingsCallbacks, optional): A dictionary containing functions to load and save settings for the agency. The keys must be \"load\" and \"save\". Both values must be defined. Defaults to None.\n",
      "            threads_callbacks (ThreadsCallbacks, optional): A dictionary containing functions to load and save threads for the agency. The keys must be \"load\" and \"save\". Both values must be defined. Defaults to None.\n",
      "            temperature (float, optional): The temperature value to use for the agents. Agent-specific values will override this. Defaults to 0.3.\n",
      "            top_p (float, optional): The top_p value to use for the agents. Agent-specific values will override this. Defaults to None.\n",
      "            max_prompt_tokens (int, optional): The maximum number of tokens allowed in the prompt for each agent. Agent-specific values will override this. Defaults to None.\n",
      "            max_completion_tokens (int, optional): The maximum number of tokens allowed in the completion for each agent. Agent-specific values will override this. Defaults to None.\n",
      "            truncation_strategy (dict, optional): The truncation strategy to use for the completion for each agent. Agent-specific values will override this. Defaults to None.\n",
      "\n",
      "        This constructor initializes various components of the Agency, including CEO, agents, threads, and user interactions. It parses the agency chart to set up the organizational structure and initializes the messaging tools, agents, and threads necessary for the operation of the agency. Additionally, it prepares a main thread for user interactions.\n",
      "        \"\"\"\n",
      "        self.ceo = None\n",
      "        self.user = User()\n",
      "        self.agents = []\n",
      "        self.agents_and_threads = {}\n",
      "        self.main_recipients = []\n",
      "        self.main_thread = None\n",
      "        self.recipient_agents = None  # for autocomplete\n",
      "        self.shared_files = shared_files if shared_files else []\n",
      "        self.async_mode = async_mode\n",
      "        self.settings_path = settings_path\n",
      "        self.settings_callbacks = settings_callbacks\n",
      "        self.threads_callbacks = threads_callbacks\n",
      "        self.temperature = temperature\n",
      "        self.top_p = top_p\n",
      "        self.max_prompt_tokens = max_prompt_tokens\n",
      "        self.max_completion_tokens = max_completion_tokens\n",
      "        self.truncation_strategy = truncation_strategy\n",
      "\n",
      "        if self.async_mode == \"threading\":\n",
      "            from agency_swarm.threads.thread_async import ThreadAsync\n",
      "            self.ThreadType = ThreadAsync\n",
      "        elif self.async_mode == \"tools_threading\":\n",
      "            Thread.async_mode = self.async_mode\n",
      "        elif self.async_mode is None:\n",
      "            pass\n",
      "        else:\n",
      "            raise Exception(\"Please select async_mode = 'threading' or 'tools_threading'.\")\n",
      "\n",
      "        if os.path.isfile(os.path.join(self._get_class_folder_path(), shared_instructions)):\n",
      "            self._read_instructions(os.path.join(self._get_class_folder_path(), shared_instructions))\n",
      "        elif os.path.isfile(shared_instructions):\n",
      "            self._read_instructions(shared_instructions)\n",
      "        else:\n",
      "            self.shared_instructions = shared_instructions\n",
      "\n",
      "        self.shared_state = SharedState()\n",
      "\n",
      "        self._parse_agency_chart(agency_chart)\n",
      "        self._create_special_tools()\n",
      "        self._init_agents()\n",
      "        self._init_threads()\n",
      "\n",
      "    def get_completion(self, message: str,\n",
      "                       message_files: List[str] = None,\n",
      "                       yield_messages: bool = False,\n",
      "                       recipient_agent: Agent = None,\n",
      "                       additional_instructions: str = None,\n",
      "                       attachments: List[dict] = None,\n",
      "                       tool_choice: dict = None,\n",
      "                       verbose: bool = False,\n",
      "                       response_format: dict = None):\n",
      "        \"\"\"\n",
      "        Retrieves the completion for a given message from the main thread.\n",
      "\n",
      "        Parameters:\n",
      "            message (str): The message for which completion is to be retrieved.\n",
      "            message_files (list, optional): A list of file ids to be sent as attachments with the message. When using this parameter, files will be assigned both to file_search and code_interpreter tools if available. It is recommended to assign files to the most sutiable tool manually, using the attachments parameter.  Defaults to None.\n",
      "            yield_messages (bool, optional): Flag to determine if intermediate messages should be yielded. Defaults to True.\n",
      "            recipient_agent (Agent, optional): The agent to which the message should be sent. Defaults to the first agent in the agency chart.\n",
      "            additional_instructions (str, optional): Additional instructions to be sent with the message. Defaults to None.\n",
      "            attachments (List[dict], optional): A list of attachments to be sent with the message, following openai format. Defaults to None.\n",
      "            tool_choice (dict, optional): The tool choice for the recipient agent to use. Defaults to None.\n",
      "            parallel_tool_calls (bool, optional): Whether to enable parallel function calling during tool use. Defaults to True.\n",
      "            verbose (bool, optional): Whether to print the intermediary messages in console. Defaults to False.\n",
      "            response_format (dict, optional): The response format to use for the completion.\n",
      "\n",
      "        Returns:\n",
      "            Generator or final response: Depending on the 'yield_messages' flag, this method returns either a generator yielding intermediate messages or the final response from the main thread.\n",
      "        \"\"\"\n",
      "        if verbose and yield_messages:\n",
      "            raise Exception(\"Verbose mode is not compatible with yield_messages=True\")\n",
      "        \n",
      "        res = self.main_thread.get_completion(message=message,\n",
      "                                               message_files=message_files,\n",
      "                                               attachments=attachments,\n",
      "                                               recipient_agent=recipient_agent,\n",
      "                                               additional_instructions=additional_instructions,\n",
      "                                               tool_choice=tool_choice,\n",
      "                                               yield_messages=yield_messages or verbose,\n",
      "                                               response_format=response_format)\n",
      "        \n",
      "        if not yield_messages or verbose:\n",
      "            while True:\n",
      "                try:\n",
      "                    message = next(res)\n",
      "                    if verbose:\n",
      "                        message.cprint()\n",
      "                except StopIteration as e:\n",
      "                    return e.value\n",
      "\n",
      "        return res\n",
      "\n",
      "\n",
      "    def get_completion_stream(self,\n",
      "                              message: str,\n",
      "                              event_handler: type(AgencyEventHandler),\n",
      "                              message_files: List[str] = None,\n",
      "                              recipient_agent: Agent = None,\n",
      "                              additional_instructions: str = None,\n",
      "                              attachments: List[dict] = None,\n",
      "                              tool_choice: dict = None,\n",
      "                              response_format: dict = None):\n",
      "        \"\"\"\n",
      "        Generates a stream of completions for a given message from the main thread.\n",
      "\n",
      "        Parameters:\n",
      "            message (str): The message for which completion is to be retrieved.\n",
      "            event_handler (type(AgencyEventHandler)): The event handler class to handle the completion stream. https://github.com/openai/openai-python/blob/main/helpers.md\n",
      "            message_files (list, optional): A list of file ids to be sent as attachments with the message. When using this parameter, files will be assigned both to file_search and code_interpreter tools if available. It is recommended to assign files to the most sutiable tool manually, using the attachments parameter.  Defaults to None.\n",
      "            recipient_agent (Agent, optional): The agent to which the message should be sent. Defaults to the first agent in the agency chart.\n",
      "            additional_instructions (str, optional): Additional instructions to be sent with the message. Defaults to None.\n",
      "            attachments (List[dict], optional): A list of attachments to be sent with the message, following openai format. Defaults to None.\n",
      "            tool_choice (dict, optional): The tool choice for the recipient agent to use. Defaults to None.\n",
      "            parallel_tool_calls (bool, optional): Whether to enable parallel function calling during tool use. Defaults to True.\n",
      "\n",
      "        Returns:\n",
      "            Final response: Final response from the main thread.\n",
      "        \"\"\"\n",
      "        if not inspect.isclass(event_handler):\n",
      "            raise Exception(\"Event handler must not be an instance.\")\n",
      "\n",
      "        res = self.main_thread.get_completion_stream(message=message,\n",
      "                                                      message_files=message_files,\n",
      "                                                      event_handler=event_handler,\n",
      "                                                      attachments=attachments,\n",
      "                                                      recipient_agent=recipient_agent,\n",
      "                                                      additional_instructions=additional_instructions,\n",
      "                                                      tool_choice=tool_choice,\n",
      "                                                      response_format=response_format)\n",
      "\n",
      "        while True:\n",
      "            try:\n",
      "                next(res)\n",
      "            except StopIteration as e:\n",
      "                event_handler.on_all_streams_end()\n",
      "\n",
      "                return e.value\n",
      "                \n",
      "    def get_completion_parse(self, message: str,\n",
      "                             response_format: Type[T],\n",
      "                             message_files: List[str] = None,\n",
      "                             recipient_agent: Agent = None,\n",
      "                             additional_instructions: str = None,\n",
      "                             attachments: List[dict] = None,\n",
      "                             tool_choice: dict = None,\n",
      "                             verbose: bool = False) -> T:\n",
      "        \"\"\"\n",
      "        Retrieves the completion for a given message from the main thread and parses the response using the provided pydantic model.\n",
      "\n",
      "        Parameters:\n",
      "            message (str): The message for which completion is to be retrieved.\n",
      "            response_format (type(BaseModel)): The response format to use for the completion. \n",
      "            message_files (list, optional): A list of file ids to be sent as attachments with the message. When using this parameter, files will be assigned both to file_search and code_interpreter tools if available. It is recommended to assign files to the most sutiable tool manually, using the attachments parameter.  Defaults to None.\n",
      "            recipient_agent (Agent, optional): The agent to which the message should be sent. Defaults to the first agent in the agency chart.\n",
      "            additional_instructions (str, optional): Additional instructions to be sent with the message. Defaults to None.\n",
      "            attachments (List[dict], optional): A list of attachments to be sent with the message, following openai format. Defaults to None.\n",
      "            tool_choice (dict, optional): The tool choice for the recipient agent to use. Defaults to None.\n",
      "            verbose (bool, optional): Whether to print the intermediary messages in console. Defaults to False.\n",
      "        \n",
      "        Returns:\n",
      "            Final response: The final response from the main thread, parsed using the provided pydantic model.\n",
      "        \"\"\"\n",
      "        response_model = None\n",
      "        if isinstance(response_format, type):\n",
      "            response_model = response_format\n",
      "            response_format = type_to_response_format_param(response_format)\n",
      "\n",
      "        res = self.get_completion(message=message,\n",
      "                            message_files=message_files,\n",
      "                            recipient_agent=recipient_agent,\n",
      "                            additional_instructions=additional_instructions,\n",
      "                            attachments=attachments,\n",
      "                            tool_choice=tool_choice,\n",
      "                            response_format=response_format,\n",
      "                            verbose=verbose)\n",
      "        \n",
      "        try:\n",
      "            return response_model.model_validate_json(res)\n",
      "        except:\n",
      "            parsed_res = json.loads(res)\n",
      "            if 'refusal' in parsed_res:\n",
      "                raise RefusalError(parsed_res['refusal'])\n",
      "            else:\n",
      "                raise Exception(\"Failed to parse response: \" + res)\n",
      "\n",
      "    def demo_gradio(self, height=450, dark_mode=True, **kwargs):\n",
      "        \"\"\"\n",
      "        Launches a Gradio-based demo interface for the agency chatbot.\n",
      "\n",
      "        Parameters:\n",
      "            height (int, optional): The height of the chatbot widget in the Gradio interface. Default is 600.\n",
      "            dark_mode (bool, optional): Flag to determine if the interface should be displayed in dark mode. Default is True.\n",
      "            **kwargs: Additional keyword arguments to be passed to the Gradio interface.\n",
      "        This method sets up and runs a Gradio interface, allowing users to interact with the agency's chatbot. It includes a text input for the user's messages and a chatbot interface for displaying the conversation. The method handles user input and chatbot responses, updating the interface dynamically.\n",
      "        \"\"\"\n",
      "\n",
      "        try:\n",
      "            import gradio as gr\n",
      "        except ImportError:\n",
      "            raise Exception(\"Please install gradio: pip install gradio\")\n",
      "\n",
      "        js = \"\"\"function () {\n",
      "          gradioURL = window.location.href\n",
      "          if (!gradioURL.endsWith('?__theme={theme}')) {\n",
      "            window.location.replace(gradioURL + '?__theme={theme}');\n",
      "          }\n",
      "        }\"\"\"\n",
      "\n",
      "        if dark_mode:\n",
      "            js = js.replace(\"{theme}\", \"dark\")\n",
      "        else:\n",
      "            js = js.replace(\"{theme}\", \"light\")\n",
      "\n",
      "        attachments = []\n",
      "        images = []\n",
      "        message_file_names = None\n",
      "        uploading_files = False\n",
      "        recipient_agents = [agent.name for agent in self.main_recipients]\n",
      "        recipient_agent = self.main_recipients[0]\n",
      "\n",
      "        with gr.Blocks(js=js) as demo:\n",
      "            chatbot_queue = queue.Queue()\n",
      "            chatbot = gr.Chatbot(height=height)\n",
      "            with gr.Row():\n",
      "                with gr.Column(scale=9):\n",
      "                    dropdown = gr.Dropdown(label=\"Recipient Agent\", choices=recipient_agents,\n",
      "                                           value=recipient_agent.name)\n",
      "                    msg = gr.Textbox(label=\"Your Message\", lines=4)\n",
      "                with gr.Column(scale=1):\n",
      "                    file_upload = gr.Files(label=\"OpenAI Files\", type=\"filepath\")\n",
      "            button = gr.Button(value=\"Send\", variant=\"primary\")\n",
      "\n",
      "            def handle_dropdown_change(selected_option):\n",
      "                nonlocal recipient_agent\n",
      "                recipient_agent = self._get_agent_by_name(selected_option)\n",
      "\n",
      "            def handle_file_upload(file_list):\n",
      "                nonlocal attachments\n",
      "                nonlocal message_file_names\n",
      "                nonlocal uploading_files\n",
      "                nonlocal images\n",
      "                uploading_files = True\n",
      "                attachments = []\n",
      "                message_file_names = []\n",
      "                if file_list:\n",
      "                    try:\n",
      "                        for file_obj in file_list:\n",
      "                            purpose = get_file_purpose(file_obj.name)\n",
      "\n",
      "                            with open(file_obj.name, 'rb') as f:\n",
      "                                # Upload the file to OpenAI\n",
      "                                file = self.main_thread.client.files.create(\n",
      "                                    file=f,\n",
      "                                    purpose=purpose\n",
      "                                )\n",
      "\n",
      "                            if purpose == \"vision\":\n",
      "                                images.append({\n",
      "                                    \"type\": \"image_file\",\n",
      "                                    \"image_file\": {\"file_id\": file.id}\n",
      "                                })\n",
      "                            else:\n",
      "                                attachments.append({\n",
      "                                    \"file_id\": file.id,\n",
      "                                    \"tools\": get_tools(file.filename)\n",
      "                                })\n",
      "\n",
      "                            message_file_names.append(file.filename)\n",
      "                            print(f\"Uploaded file ID: {file.id}\")\n",
      "                        return attachments\n",
      "                    except Exception as e:\n",
      "                        print(f\"Error: {e}\")\n",
      "                        return str(e)\n",
      "                    finally:\n",
      "                        uploading_files = False\n",
      "\n",
      "                uploading_files = False\n",
      "                return \"No files uploaded\"\n",
      "\n",
      "            def user(user_message, history):\n",
      "                if not user_message.strip():\n",
      "                    return user_message, history\n",
      "                \n",
      "                nonlocal message_file_names\n",
      "                nonlocal uploading_files\n",
      "                nonlocal images\n",
      "                nonlocal attachments\n",
      "                nonlocal recipient_agent\n",
      "\n",
      "                # Check if attachments contain file search or code interpreter types\n",
      "                def check_and_add_tools_in_attachments(attachments, recipient_agent):\n",
      "                    for attachment in attachments:\n",
      "                        for tool in attachment.get(\"tools\", []):\n",
      "                            if tool[\"type\"] == \"file_search\":\n",
      "                                if not any(isinstance(t, FileSearch) for t in recipient_agent.tools):\n",
      "                                    # Add FileSearch tool if it does not exist\n",
      "                                    recipient_agent.tools.append(FileSearch)\n",
      "                                    recipient_agent.client.beta.assistants.update(recipient_agent.id, tools=recipient_agent.get_oai_tools())\n",
      "                                    print(\"Added FileSearch tool to recipient agent to analyze the file.\")\n",
      "                            elif tool[\"type\"] == \"code_interpreter\":\n",
      "                                if not any(isinstance(t, CodeInterpreter) for t in recipient_agent.tools):\n",
      "                                    # Add CodeInterpreter tool if it does not exist\n",
      "                                    recipient_agent.tools.append(CodeInterpreter)\n",
      "                                    recipient_agent.client.beta.assistants.update(recipient_agent.id, tools=recipient_agent.get_oai_tools())\n",
      "                                    print(\"Added CodeInterpreter tool to recipient agent to analyze the file.\")\n",
      "                    return None\n",
      "\n",
      "                check_and_add_tools_in_attachments(attachments, recipient_agent)\n",
      "\n",
      "                if history is None:\n",
      "                    history = []\n",
      "\n",
      "                original_user_message = user_message\n",
      "\n",
      "                # Append the user message with a placeholder for bot response\n",
      "                if recipient_agent:\n",
      "                    user_message = f\"\ud83d\udc64 User \ud83d\udde3\ufe0f @{recipient_agent.name}:\\n\" + user_message.strip()\n",
      "                else:\n",
      "                    user_message = f\"\ud83d\udc64 User:\" + user_message.strip()\n",
      "\n",
      "                nonlocal message_file_names\n",
      "                if message_file_names:\n",
      "                    user_message += \"\\n\\n\ud83d\udcce Files:\\n\" + \"\\n\".join(message_file_names)\n",
      "\n",
      "                return original_user_message, history + [[user_message, None]]\n",
      "\n",
      "            class GradioEventHandler(AgencyEventHandler):\n",
      "                message_output = None\n",
      "\n",
      "                @override\n",
      "                def on_message_created(self, message: Message) -> None:\n",
      "\n",
      "                    if message.role == \"user\":\n",
      "                        full_content = \"\"\n",
      "                        for content in message.content:\n",
      "                            if content.type == \"image_file\":\n",
      "                                full_content += f\"\ud83d\uddbc\ufe0f Image File: {content.image_file.file_id}\\n\"\n",
      "                                continue\n",
      "\n",
      "                            if content.type == \"image_url\":\n",
      "                                full_content += f\"\\n{content.image_url.url}\\n\"\n",
      "                                continue\n",
      "\n",
      "                            if content.type == \"text\":\n",
      "                                full_content += content.text.value + \"\\n\"\n",
      "\n",
      "\n",
      "                        self.message_output = MessageOutput(\"text\", self.agent_name, self.recipient_agent_name,\n",
      "                                                            full_content)\n",
      "\n",
      "                    else:\n",
      "                        self.message_output = MessageOutput(\"text\", self.recipient_agent_name, self.agent_name,\n",
      "                                                            \"\")\n",
      "\n",
      "                    chatbot_queue.put(\"[new_message]\")\n",
      "                    chatbot_queue.put(self.message_output.get_formatted_content())\n",
      "\n",
      "                @override\n",
      "                def on_text_delta(self, delta, snapshot):\n",
      "                    chatbot_queue.put(delta.value)\n",
      "\n",
      "                @override\n",
      "                def on_tool_call_created(self, tool_call: ToolCall):\n",
      "                    if isinstance(tool_call, dict):\n",
      "                        if \"type\" not in tool_call:\n",
      "                            tool_call[\"type\"] = \"function\"\n",
      "                        \n",
      "                        if tool_call[\"type\"] == \"function\":\n",
      "                            tool_call = FunctionToolCall(**tool_call)\n",
      "                        elif tool_call[\"type\"] == \"code_interpreter\":\n",
      "                            tool_call = CodeInterpreterToolCall(**tool_call)\n",
      "                        elif tool_call[\"type\"] == \"file_search\" or tool_call[\"type\"] == \"retrieval\":\n",
      "                            tool_call = FileSearchToolCall(**tool_call)\n",
      "                        else:\n",
      "                            raise ValueError(\"Invalid tool call type: \" + tool_call[\"type\"])\n",
      "\n",
      "                    # TODO: add support for code interpreter and retrieval tools\n",
      "                    if tool_call.type == \"function\":\n",
      "                        chatbot_queue.put(\"[new_message]\")\n",
      "                        self.message_output = MessageOutput(\"function\", self.recipient_agent_name, self.agent_name,\n",
      "                                                            str(tool_call.function))\n",
      "                        chatbot_queue.put(self.message_output.get_formatted_header() + \"\\n\")\n",
      "\n",
      "                @override\n",
      "                def on_tool_call_done(self, snapshot: ToolCall):\n",
      "                    if isinstance(snapshot, dict):\n",
      "                        if \"type\" not in snapshot:\n",
      "                            snapshot[\"type\"] = \"function\"\n",
      "                        \n",
      "                        if snapshot[\"type\"] == \"function\":\n",
      "                            snapshot = FunctionToolCall(**snapshot)\n",
      "                        elif snapshot[\"type\"] == \"code_interpreter\":\n",
      "                            snapshot = CodeInterpreterToolCall(**snapshot)\n",
      "                        elif snapshot[\"type\"] == \"file_search\":\n",
      "                            snapshot = FileSearchToolCall(**snapshot)\n",
      "                        else:\n",
      "                            raise ValueError(\"Invalid tool call type: \" + snapshot[\"type\"])\n",
      "                        \n",
      "                    self.message_output = None\n",
      "\n",
      "                    # TODO: add support for code interpreter and retrieval tools\n",
      "                    if snapshot.type != \"function\":\n",
      "                        return\n",
      "\n",
      "                    chatbot_queue.put(str(snapshot.function))\n",
      "\n",
      "                    if snapshot.function.name == \"SendMessage\":\n",
      "                        try:\n",
      "                            args = eval(snapshot.function.arguments)\n",
      "                            recipient = args[\"recipient\"]\n",
      "                            self.message_output = MessageOutput(\"text\", self.recipient_agent_name, recipient,\n",
      "                                                                args[\"message\"])\n",
      "\n",
      "                            chatbot_queue.put(\"[new_message]\")\n",
      "                            chatbot_queue.put(self.message_output.get_formatted_content())\n",
      "                        except Exception as e:\n",
      "                            pass\n",
      "\n",
      "                    self.message_output = None\n",
      "\n",
      "                @override\n",
      "                def on_run_step_done(self, run_step: RunStep) -> None:\n",
      "                    if run_step.type == \"tool_calls\":\n",
      "                        for tool_call in run_step.step_details.tool_calls:\n",
      "                            if tool_call.type != \"function\":\n",
      "                                continue\n",
      "\n",
      "                            if tool_call.function.name == \"SendMessage\":\n",
      "                                continue\n",
      "\n",
      "                            self.message_output = None\n",
      "                            chatbot_queue.put(\"[new_message]\")\n",
      "\n",
      "                            self.message_output = MessageOutput(\"function_output\", tool_call.function.name,\n",
      "                                                                self.recipient_agent_name,\n",
      "                                                                tool_call.function.output)\n",
      "\n",
      "                            chatbot_queue.put(self.message_output.get_formatted_header() + \"\\n\")\n",
      "                            chatbot_queue.put(tool_call.function.output)\n",
      "\n",
      "                @override\n",
      "                @classmethod\n",
      "                def on_all_streams_end(cls):\n",
      "                    cls.message_output = None\n",
      "                    chatbot_queue.put(\"[end]\")\n",
      "\n",
      "            def bot(original_message, history):\n",
      "                if not original_message:\n",
      "                    return \"\", history\n",
      "\n",
      "                nonlocal attachments\n",
      "                nonlocal message_file_names\n",
      "                nonlocal recipient_agent\n",
      "                nonlocal images\n",
      "                nonlocal uploading_files\n",
      "\n",
      "                if uploading_files:\n",
      "                    history.append([None, \"Uploading files... Please wait.\"])\n",
      "                    yield \"\", history\n",
      "                    return \"\", history\n",
      "\n",
      "                print(\"Message files: \", attachments)\n",
      "                print(\"Images: \", images)\n",
      "                \n",
      "                if images and len(images) > 0:\n",
      "                    original_message = [\n",
      "                        {\n",
      "                            \"type\": \"text\",\n",
      "                            \"text\": original_message,\n",
      "                        },\n",
      "                        *images\n",
      "                    ]\n",
      "\n",
      "\n",
      "                completion_thread = threading.Thread(target=self.get_completion_stream, args=(\n",
      "                    original_message, GradioEventHandler, [], recipient_agent, \"\", attachments, None))\n",
      "                completion_thread.start()\n",
      "\n",
      "                attachments = []\n",
      "                message_file_names = []\n",
      "                images = []\n",
      "                uploading_files = False\n",
      "\n",
      "                new_message = True\n",
      "                while True:\n",
      "                    try:\n",
      "                        bot_message = chatbot_queue.get(block=True)\n",
      "\n",
      "                        if bot_message == \"[end]\":\n",
      "                            completion_thread.join()\n",
      "                            break\n",
      "\n",
      "                        if bot_message == \"[new_message]\":\n",
      "                            new_message = True\n",
      "                            continue\n",
      "\n",
      "                        if new_message:\n",
      "                            history.append([None, bot_message])\n",
      "                            new_message = False\n",
      "                        else:\n",
      "                            history[-1][1] += bot_message\n",
      "\n",
      "                        yield \"\", history\n",
      "                    except queue.Empty:\n",
      "                        break\n",
      "\n",
      "            button.click(\n",
      "                user,\n",
      "                inputs=[msg, chatbot],\n",
      "                outputs=[msg, chatbot]\n",
      "            ).then(\n",
      "                bot, [msg, chatbot], [msg, chatbot]\n",
      "            )\n",
      "            dropdown.change(handle_dropdown_change, dropdown)\n",
      "            file_upload.change(handle_file_upload, file_upload)\n",
      "            msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(\n",
      "                bot, [msg, chatbot], [msg, chatbot]\n",
      "            )\n",
      "\n",
      "            # Enable queuing for streaming intermediate outputs\n",
      "            demo.queue(default_concurrency_limit=10)\n",
      "\n",
      "        # Launch the demo\n",
      "        demo.launch(**kwargs)\n",
      "        return demo\n",
      "\n",
      "    def _recipient_agent_completer(self, text, state):\n",
      "        \"\"\"\n",
      "        Autocomplete completer for recipient agent names.\n",
      "        \"\"\"\n",
      "        options = [agent for agent in self.recipient_agents if agent.lower().startswith(text.lower())]\n",
      "        if state < len(options):\n",
      "            return options[state]\n",
      "        else:\n",
      "            return None\n",
      "\n",
      "    def _setup_autocomplete(self):\n",
      "        \"\"\"\n",
      "        Sets up readline with the completer function.\n",
      "        \"\"\"\n",
      "        try:\n",
      "            import readline\n",
      "        except ImportError:\n",
      "            # Attempt to import pyreadline for Windows compatibility\n",
      "            try:\n",
      "                import pyreadline as readline\n",
      "            except ImportError:\n",
      "                print(\n",
      "                    \"Module 'readline' not found. Autocomplete will not work. If you are using Windows, try installing 'pyreadline3'.\")\n",
      "                return\n",
      "\n",
      "        if not readline:\n",
      "            return\n",
      "\n",
      "        try:\n",
      "            readline.set_completer(self._recipient_agent_completer)\n",
      "            readline.parse_and_bind('tab: complete')\n",
      "        except Exception as e:\n",
      "            print(f\"Error setting up autocomplete for agents in terminal: {e}. Autocomplete will not work.\")\n",
      "\n",
      "    def run_demo(self):\n",
      "        \"\"\"\n",
      "        Executes agency in the terminal with autocomplete for recipient agent names.\n",
      "        \"\"\"\n",
      "        from agency_swarm import AgencyEventHandler\n",
      "        class TermEventHandler(AgencyEventHandler):\n",
      "            message_output = None\n",
      "\n",
      "            @override\n",
      "            def on_message_created(self, message: Message) -> None:\n",
      "                if message.role == \"user\":\n",
      "                    self.message_output = MessageOutputLive(\"text\", self.agent_name, self.recipient_agent_name,\n",
      "                                                            \"\")\n",
      "                    self.message_output.cprint_update(message.content[0].text.value)\n",
      "                else:\n",
      "                    self.message_output = MessageOutputLive(\"text\", self.recipient_agent_name, self.agent_name, \"\")\n",
      "\n",
      "            @override\n",
      "            def on_message_done(self, message: Message) -> None:\n",
      "                self.message_output = None\n",
      "\n",
      "            @override\n",
      "            def on_text_delta(self, delta, snapshot):\n",
      "                self.message_output.cprint_update(snapshot.value)\n",
      "\n",
      "            @override\n",
      "            def on_tool_call_created(self, tool_call):\n",
      "                if isinstance(tool_call, dict):\n",
      "                    if \"type\" not in tool_call:\n",
      "                        tool_call[\"type\"] = \"function\"\n",
      "                    \n",
      "                    if tool_call[\"type\"] == \"function\":\n",
      "                        tool_call = FunctionToolCall(**tool_call)\n",
      "                    elif tool_call[\"type\"] == \"code_interpreter\":\n",
      "                        tool_call = CodeInterpreterToolCall(**tool_call)\n",
      "                    elif tool_call[\"type\"] == \"file_search\" or tool_call[\"type\"] == \"retrieval\":\n",
      "                        tool_call = FileSearchToolCall(**tool_call)\n",
      "                    else:\n",
      "                        raise ValueError(\"Invalid tool call type: \" + tool_call[\"type\"])\n",
      "\n",
      "                # TODO: add support for code interpreter and retirieval tools\n",
      "\n",
      "                if tool_call.type == \"function\":\n",
      "                    self.message_output = MessageOutputLive(\"function\", self.recipient_agent_name, self.agent_name,\n",
      "                                                            str(tool_call.function))\n",
      "\n",
      "            @override\n",
      "            def on_tool_call_delta(self, delta, snapshot):\n",
      "                if isinstance(snapshot, dict):\n",
      "                    if \"type\" not in snapshot:\n",
      "                        snapshot[\"type\"] = \"function\"\n",
      "                    \n",
      "                    if snapshot[\"type\"] == \"function\":\n",
      "                        snapshot = FunctionToolCall(**snapshot)\n",
      "                    elif snapshot[\"type\"] == \"code_interpreter\":\n",
      "                        snapshot = CodeInterpreterToolCall(**snapshot)\n",
      "                    elif snapshot[\"type\"] == \"file_search\":\n",
      "                        snapshot = FileSearchToolCall(**snapshot)\n",
      "                    else:\n",
      "                        raise ValueError(\"Invalid tool call type: \" + snapshot[\"type\"])\n",
      "                    \n",
      "                self.message_output.cprint_update(str(snapshot.function))\n",
      "\n",
      "            @override\n",
      "            def on_tool_call_done(self, snapshot):\n",
      "                self.message_output = None\n",
      "\n",
      "                # TODO: add support for code interpreter and retrieval tools\n",
      "                if snapshot.type != \"function\":\n",
      "                    return\n",
      "\n",
      "                if snapshot.function.name == \"SendMessage\":\n",
      "                    try:\n",
      "                        args = eval(snapshot.function.arguments)\n",
      "                        recipient = args[\"recipient\"]\n",
      "                        self.message_output = MessageOutputLive(\"text\", self.recipient_agent_name, recipient,\n",
      "                                                                \"\")\n",
      "\n",
      "                        self.message_output.cprint_update(args[\"message\"])\n",
      "                    except Exception as e:\n",
      "                        pass\n",
      "\n",
      "                self.message_output = None\n",
      "\n",
      "            @override\n",
      "            def on_run_step_done(self, run_step: RunStep) -> None:\n",
      "                if run_step.type == \"tool_calls\":\n",
      "                    for tool_call in run_step.step_details.tool_calls:\n",
      "                        if tool_call.type != \"function\":\n",
      "                            continue\n",
      "\n",
      "                        if tool_call.function.name == \"SendMessage\":\n",
      "                            continue\n",
      "\n",
      "                        self.message_output = None\n",
      "                        self.message_output = MessageOutputLive(\"function_output\", tool_call.function.name,\n",
      "                                                                self.recipient_agent_name, tool_call.function.output)\n",
      "                        self.message_output.cprint_update(tool_call.function.output)\n",
      "\n",
      "                    self.message_output = None\n",
      "\n",
      "            @override\n",
      "            def on_end(self):\n",
      "                self.message_output = None\n",
      "\n",
      "        self.recipient_agents = [str(agent.name) for agent in self.main_recipients]\n",
      "\n",
      "        self._setup_autocomplete()  # Prepare readline for autocomplete\n",
      "\n",
      "        while True:\n",
      "            console.rule()\n",
      "            text = input(\"\ud83d\udc64 USER: \")\n",
      "\n",
      "            if not text:\n",
      "                continue\n",
      "\n",
      "            if text.lower() == \"exit\":\n",
      "                break\n",
      "\n",
      "            recipient_agent = None\n",
      "            if \"@\" in text:\n",
      "                recipient_agent = text.split(\"@\")[1].split(\" \")[0]\n",
      "                text = text.replace(f\"@{recipient_agent}\", \"\").strip()\n",
      "                try:\n",
      "                    recipient_agent = \\\n",
      "                        [agent for agent in self.recipient_agents if agent.lower() == recipient_agent.lower()][0]\n",
      "                    recipient_agent = self._get_agent_by_name(recipient_agent)\n",
      "                except Exception as e:\n",
      "                    print(f\"Recipient agent {recipient_agent} not found.\")\n",
      "                    continue\n",
      "\n",
      "            self.get_completion_stream(message=text, event_handler=TermEventHandler, recipient_agent=recipient_agent)\n",
      "\n",
      "    def get_customgpt_schema(self, url: str):\n",
      "        \"\"\"Returns the OpenAPI schema for the agency from the CEO agent, that you can use to integrate with custom gpts.\n",
      "\n",
      "        Parameters:\n",
      "            url (str): Your server url where the api will be hosted.\n",
      "        \"\"\"\n",
      "\n",
      "        return self.ceo.get_openapi_schema(url)\n",
      "\n",
      "    def plot_agency_chart(self):\n",
      "        pass\n",
      "\n",
      "    def _init_agents(self):\n",
      "        \"\"\"\n",
      "        Initializes all agents in the agency with unique IDs, shared instructions, and OpenAI models.\n",
      "\n",
      "        This method iterates through each agent in the agency, assigns a unique ID, adds shared instructions, and initializes the OpenAI models for each agent.\n",
      "\n",
      "        There are no input parameters.\n",
      "\n",
      "        There are no output parameters as this method is used for internal initialization purposes within the Agency class.\n",
      "        \"\"\"\n",
      "        if self.settings_callbacks:\n",
      "            loaded_settings = self.settings_callbacks[\"load\"]()\n",
      "            with open(self.settings_path, 'w') as f:\n",
      "                json.dump(loaded_settings, f, indent=4)\n",
      "\n",
      "        for agent in self.agents:\n",
      "            if \"temp_id\" in agent.id:\n",
      "                agent.id = None\n",
      "\n",
      "            agent.add_shared_instructions(self.shared_instructions)\n",
      "            agent.settings_path = self.settings_path\n",
      "\n",
      "            if self.shared_files:\n",
      "                if isinstance(self.shared_files, str):\n",
      "                    self.shared_files = [self.shared_files]\n",
      "\n",
      "                if isinstance(agent.files_folder, str):\n",
      "                    agent.files_folder = [agent.files_folder]\n",
      "                    agent.files_folder += self.shared_files\n",
      "                elif isinstance(agent.files_folder, list):\n",
      "                    agent.files_folder += self.shared_files\n",
      "\n",
      "            if self.temperature is not None and agent.temperature is None:\n",
      "                agent.temperature = self.temperature\n",
      "            if self.top_p and agent.top_p is None:\n",
      "                agent.top_p = self.top_p\n",
      "            if self.max_prompt_tokens is not None and agent.max_prompt_tokens is None:\n",
      "                agent.max_prompt_tokens = self.max_prompt_tokens\n",
      "            if self.max_completion_tokens is not None and agent.max_completion_tokens is None:\n",
      "                agent.max_completion_tokens = self.max_completion_tokens\n",
      "            if self.truncation_strategy is not None and agent.truncation_strategy is None:\n",
      "                agent.truncation_strategy = self.truncation_strategy\n",
      "            \n",
      "            if not agent.shared_state:\n",
      "                agent.shared_state = self.shared_state\n",
      "\n",
      "            agent.init_oai()\n",
      "\n",
      "        if self.settings_callbacks:\n",
      "            with open(self.agents[0].get_settings_path(), 'r') as f:\n",
      "                settings = f.read()\n",
      "            settings = json.loads(settings)\n",
      "            self.settings_callbacks[\"save\"](settings)\n",
      "\n",
      "    def _init_threads(self):\n",
      "        \"\"\"\n",
      "        Initializes threads for communication between agents within the agency.\n",
      "\n",
      "        This method creates Thread objects for each pair of interacting agents as defined in the agents_and_threads attribute of the Agency. Each thread facilitates communication and task execution between an agent and its designated recipient agent.\n",
      "\n",
      "        No input parameters.\n",
      "\n",
      "        Output Parameters:\n",
      "            This method does not return any value but updates the agents_and_threads attribute with initialized Thread objects.\n",
      "        \"\"\"\n",
      "        self.main_thread = Thread(self.user, self.ceo)\n",
      "\n",
      "        # load thread ids\n",
      "        loaded_thread_ids = {}\n",
      "        if self.threads_callbacks:\n",
      "            loaded_thread_ids = self.threads_callbacks[\"load\"]()\n",
      "            if \"main_thread\" in loaded_thread_ids and loaded_thread_ids[\"main_thread\"]:\n",
      "                self.main_thread.id = loaded_thread_ids[\"main_thread\"]\n",
      "            else:\n",
      "                self.main_thread.init_thread()\n",
      "\n",
      "        for agent_name, threads in self.agents_and_threads.items():\n",
      "            for other_agent, items in threads.items():\n",
      "                self.agents_and_threads[agent_name][other_agent] = self.ThreadType(\n",
      "                    self._get_agent_by_name(items[\"agent\"]),\n",
      "                    self._get_agent_by_name(\n",
      "                        items[\"recipient_agent\"]))\n",
      "\n",
      "                if agent_name in loaded_thread_ids and other_agent in loaded_thread_ids[agent_name]:\n",
      "                    self.agents_and_threads[agent_name][other_agent].id = loaded_thread_ids[agent_name][other_agent]\n",
      "                elif self.threads_callbacks:\n",
      "                    self.agents_and_threads[agent_name][other_agent].init_thread()\n",
      "\n",
      "        # save thread ids\n",
      "        if self.threads_callbacks:\n",
      "            loaded_thread_ids = {}\n",
      "            for agent_name, threads in self.agents_and_threads.items():\n",
      "                loaded_thread_ids[agent_name] = {}\n",
      "                for other_agent, thread in threads.items():\n",
      "                    loaded_thread_ids[agent_name][other_agent] = thread.id\n",
      "\n",
      "            loaded_thread_ids[\"main_thread\"] = self.main_thread.id\n",
      "\n",
      "            self.threads_callbacks[\"save\"](loaded_thread_ids)\n",
      "\n",
      "    def _parse_agency_chart(self, agency_chart):\n",
      "        \"\"\"\n",
      "        Parses the provided agency chart to initialize and organize agents within the agency.\n",
      "\n",
      "        Parameters:\n",
      "            agency_chart: A structure representing the hierarchical organization of agents within the agency.\n",
      "                    It can contain Agent objects and lists of Agent objects.\n",
      "\n",
      "        This method iterates through each node in the agency chart. If a node is an Agent, it is set as the CEO if not already assigned.\n",
      "        If a node is a list, it iterates through the agents in the list, adding them to the agency and establishing communication\n",
      "        threads between them. It raises an exception if the agency chart is invalid or if multiple CEOs are defined.\n",
      "        \"\"\"\n",
      "        if not isinstance(agency_chart, list):\n",
      "            raise Exception(\"Invalid agency chart.\")\n",
      "\n",
      "        if len(agency_chart) == 0:\n",
      "            raise Exception(\"Agency chart cannot be empty.\")\n",
      "\n",
      "        for node in agency_chart:\n",
      "            if isinstance(node, Agent):\n",
      "                if not self.ceo:\n",
      "                    self.ceo = node\n",
      "                    self._add_agent(self.ceo)\n",
      "                else:\n",
      "                    self._add_agent(node)\n",
      "                self._add_main_recipient(node)\n",
      "\n",
      "            elif isinstance(node, list):\n",
      "                for i, agent in enumerate(node):\n",
      "                    if not isinstance(agent, Agent):\n",
      "                        raise Exception(\"Invalid agency chart.\")\n",
      "\n",
      "                    index = self._add_agent(agent)\n",
      "\n",
      "                    if i == len(node) - 1:\n",
      "                        continue\n",
      "\n",
      "                    if agent.name not in self.agents_and_threads.keys():\n",
      "                        self.agents_and_threads[agent.name] = {}\n",
      "\n",
      "                    if i < len(node) - 1:\n",
      "                        other_agent = node[i + 1]\n",
      "                        if other_agent.name == agent.name:\n",
      "                            continue\n",
      "                        if other_agent.name not in self.agents_and_threads[agent.name].keys():\n",
      "                            self.agents_and_threads[agent.name][other_agent.name] = {\n",
      "                                \"agent\": agent.name,\n",
      "                                \"recipient_agent\": other_agent.name,\n",
      "                            }\n",
      "            else:\n",
      "                raise Exception(\"Invalid agency chart.\")\n",
      "\n",
      "    def _add_agent(self, agent):\n",
      "        \"\"\"\n",
      "        Adds an agent to the agency, assigning a temporary ID if necessary.\n",
      "\n",
      "        Parameters:\n",
      "            agent (Agent): The agent to be added to the agency.\n",
      "\n",
      "        Returns:\n",
      "            int: The index of the added agent within the agency's agents list.\n",
      "\n",
      "        This method adds an agent to the agency's list of agents. If the agent does not have an ID, it assigns a temporary unique ID. It checks for uniqueness of the agent's name before addition. The method returns the index of the agent in the agency's agents list, which is used for referencing the agent within the agency.\n",
      "        \"\"\"\n",
      "        if not agent.id:\n",
      "            # assign temp id\n",
      "            agent.id = \"temp_id_\" + str(uuid.uuid4())\n",
      "        if agent.id not in self._get_agent_ids():\n",
      "            if agent.name in self._get_agent_names():\n",
      "                raise Exception(\"Agent names must be unique.\")\n",
      "            self.agents.append(agent)\n",
      "            return len(self.agents) - 1\n",
      "        else:\n",
      "            return self._get_agent_ids().index(agent.id)\n",
      "\n",
      "    def _add_main_recipient(self, agent):\n",
      "        \"\"\"\n",
      "        Adds an agent to the agency's list of main recipients.\n",
      "\n",
      "        Parameters:\n",
      "            agent (Agent): The agent to be added to the agency's list of main recipients.\n",
      "\n",
      "        This method adds an agent to the agency's list of main recipients. These are agents that can be directly contacted by the user.\n",
      "        \"\"\"\n",
      "        main_recipient_ids = [agent.id for agent in self.main_recipients]\n",
      "\n",
      "        if agent.id not in main_recipient_ids:\n",
      "            self.main_recipients.append(agent)\n",
      "\n",
      "    def _read_instructions(self, path):\n",
      "        \"\"\"\n",
      "        Reads shared instructions from a specified file and stores them in the agency.\n",
      "\n",
      "        Parameters:\n",
      "            path (str): The file path from which to read the shared instructions.\n",
      "\n",
      "        This method opens the file located at the given path, reads its contents, and stores these contents in the 'shared_instructions' attribute of the agency. This is used to provide common guidelines or instructions to all agents within the agency.\n",
      "        \"\"\"\n",
      "        path = path\n",
      "        with open(path, 'r') as f:\n",
      "            self.shared_instructions = f.read()\n",
      "\n",
      "    def _create_special_tools(self):\n",
      "        \"\"\"\n",
      "        Creates and assigns 'SendMessage' tools to each agent based on the agency's structure.\n",
      "\n",
      "        This method iterates through the agents and threads in the agency, creating SendMessage tools for each agent. These tools enable agents to send messages to other agents as defined in the agency's structure. The SendMessage tools are tailored to the specific recipient agents that each agent can communicate with.\n",
      "\n",
      "        No input parameters.\n",
      "\n",
      "        No output parameters; this method modifies the agents' toolset internally.\n",
      "        \"\"\"\n",
      "        for agent_name, threads in self.agents_and_threads.items():\n",
      "            recipient_names = list(threads.keys())\n",
      "            recipient_agents = self._get_agents_by_names(recipient_names)\n",
      "            if len(recipient_agents) == 0:\n",
      "                continue\n",
      "            agent = self._get_agent_by_name(agent_name)\n",
      "            agent.add_tool(self._create_send_message_tool(agent, recipient_agents))\n",
      "            if self.async_mode == 'threading':\n",
      "                agent.add_tool(self._create_get_response_tool(agent, recipient_agents))\n",
      "\n",
      "    def _create_send_message_tool(self, agent: Agent, recipient_agents: List[Agent]):\n",
      "        \"\"\"\n",
      "        Creates a SendMessage tool to enable an agent to send messages to specified recipient agents.\n",
      "\n",
      "\n",
      "        Parameters:\n",
      "            agent (Agent): The agent who will be sending messages.\n",
      "            recipient_agents (List[Agent]): A list of recipient agents who can receive messages.\n",
      "\n",
      "        Returns:\n",
      "            SendMessage: A SendMessage tool class that is dynamically created and configured for the given agent and its recipient agents. This tool allows the agent to send messages to the specified recipients, facilitating inter-agent communication within the agency.\n",
      "        \"\"\"\n",
      "        recipient_names = [agent.name for agent in recipient_agents]\n",
      "        recipients = Enum(\"recipient\", {name: name for name in recipient_names})\n",
      "\n",
      "        agent_descriptions = \"\"\n",
      "        for recipient_agent in recipient_agents:\n",
      "            if not recipient_agent.description:\n",
      "                continue\n",
      "            agent_descriptions += recipient_agent.name + \": \"\n",
      "            agent_descriptions += recipient_agent.description + \"\\n\"\n",
      "\n",
      "        outer_self = self\n",
      "\n",
      "        class SendMessage(BaseTool):\n",
      "            my_primary_instructions: str = Field(...,\n",
      "                                                 description=\"Please repeat your primary instructions step-by-step, including both completed \"\n",
      "                                                             \"and the following next steps that you need to perform. For multi-step, complex tasks, first break them down \"\n",
      "                                                             \"into smaller steps yourself. Then, issue each step individually to the \"\n",
      "                                                             \"recipient agent via the message parameter. Each identified step should be \"\n",
      "                                                             \"sent in separate message. Keep in mind, that the recipient agent does not have access \"\n",
      "                                                             \"to these instructions. You must include recipient agent-specific instructions \"\n",
      "                                                             \"in the message or additional_instructions parameters.\")\n",
      "            recipient: recipients = Field(..., description=agent_descriptions)\n",
      "            message: str = Field(...,\n",
      "                                 description=\"Specify the task required for the recipient agent to complete. Focus on \"\n",
      "                                             \"clarifying what the task entails, rather than providing exact \"\n",
      "                                             \"instructions.\")\n",
      "            message_files: Optional[List[str]] = Field(default=None,\n",
      "                                                       description=\"A list of file ids to be sent as attachments to this message. Only use this if you have the file id that starts with 'file-'.\",\n",
      "                                                       examples=[\"file-1234\", \"file-5678\"])\n",
      "            additional_instructions: str = Field(default=None,\n",
      "                                                 description=\"Any additional instructions or clarifications that you would like to provide to the recipient agent.\")\n",
      "            \n",
      "            class ToolConfig:\n",
      "                strict = False\n",
      "                one_call_at_a_time = outer_self.async_mode != 'threading'\n",
      "\n",
      "            @model_validator(mode='after')\n",
      "            def validate_files(self):\n",
      "                if \"file-\" in self.message or (\n",
      "                        self.additional_instructions and \"file-\" in self.additional_instructions):\n",
      "                    if not self.message_files:\n",
      "                        raise ValueError(\"You must include file ids in message_files parameter.\")\n",
      "\n",
      "            @field_validator('recipient')\n",
      "            def check_recipient(cls, value):\n",
      "                if value.value not in recipient_names:\n",
      "                    raise ValueError(f\"Recipient {value} is not valid. Valid recipients are: {recipient_names}\")\n",
      "                return value\n",
      "\n",
      "            def run(self):\n",
      "                thread = outer_self.agents_and_threads[self._caller_agent.name][self.recipient.value]\n",
      "\n",
      "                if not outer_self.async_mode == 'threading':\n",
      "                    message = thread.get_completion(message=self.message,\n",
      "                                                    message_files=self.message_files,\n",
      "                                                    event_handler=self._event_handler,\n",
      "                                                    yield_messages=not self._event_handler,\n",
      "                                                    additional_instructions=self.additional_instructions,\n",
      "                                                    )\n",
      "                else:\n",
      "                    message = thread.get_completion_async(message=self.message,\n",
      "                                                          message_files=self.message_files,\n",
      "                                                          additional_instructions=self.additional_instructions)\n",
      "\n",
      "                return message or \"\"\n",
      "\n",
      "        SendMessage._caller_agent = agent\n",
      "        if self.async_mode == 'threading':\n",
      "            SendMessage.__doc__ = self.send_message_tool_description_async\n",
      "        else:\n",
      "            SendMessage.__doc__ = self.send_message_tool_description\n",
      "\n",
      "        return SendMessage\n",
      "\n",
      "    def _create_get_response_tool(self, agent: Agent, recipient_agents: List[Agent]):\n",
      "        \"\"\"\n",
      "        Creates a CheckStatus tool to enable an agent to check the status of a task with a specified recipient agent.\n",
      "        \"\"\"\n",
      "        recipient_names = [agent.name for agent in recipient_agents]\n",
      "        recipients = Enum(\"recipient\", {name: name for name in recipient_names})\n",
      "\n",
      "        outer_self = self\n",
      "\n",
      "        class GetResponse(BaseTool):\n",
      "            \"\"\"This tool allows you to check the status of a task or get a response from a specified recipient agent, if the task has been completed. You must always use 'SendMessage' tool with the designated agent first.\"\"\"\n",
      "            recipient: recipients = Field(...,\n",
      "                                          description=f\"Recipient agent that you want to check the status of. Valid recipients are: {recipient_names}\")\n",
      "\n",
      "            @field_validator('recipient')\n",
      "            def check_recipient(cls, value):\n",
      "                if value.value not in recipient_names:\n",
      "                    raise ValueError(f\"Recipient {value} is not valid. Valid recipients are: {recipient_names}\")\n",
      "                return value\n",
      "\n",
      "            def run(self):\n",
      "                thread = outer_self.agents_and_threads[self._caller_agent.name][self.recipient.value]\n",
      "\n",
      "                return thread.check_status()\n",
      "\n",
      "        GetResponse._caller_agent = agent\n",
      "\n",
      "        return GetResponse\n",
      "\n",
      "    def _get_agent_by_name(self, agent_name):\n",
      "        \"\"\"\n",
      "        Retrieves an agent from the agency based on the agent's name.\n",
      "\n",
      "        Parameters:\n",
      "            agent_name (str): The name of the agent to be retrieved.\n",
      "\n",
      "        Returns:\n",
      "            Agent: The agent object with the specified name.\n",
      "\n",
      "        Raises:\n",
      "            Exception: If no agent with the given name is found in the agency.\n",
      "        \"\"\"\n",
      "        for agent in self.agents:\n",
      "            if agent.name == agent_name:\n",
      "                return agent\n",
      "        raise Exception(f\"Agent {agent_name} not found.\")\n",
      "\n",
      "    def _get_agents_by_names(self, agent_names):\n",
      "        \"\"\"\n",
      "        Retrieves a list of agent objects based on their names.\n",
      "\n",
      "        Parameters:\n",
      "            agent_names: A list of strings representing the names of the agents to be retrieved.\n",
      "\n",
      "        Returns:\n",
      "            A list of Agent objects corresponding to the given names.\n",
      "        \"\"\"\n",
      "        return [self._get_agent_by_name(agent_name) for agent_name in agent_names]\n",
      "\n",
      "    def _get_agent_ids(self):\n",
      "        \"\"\"\n",
      "        Retrieves the IDs of all agents currently in the agency.\n",
      "\n",
      "        Returns:\n",
      "            List[str]: A list containing the unique IDs of all agents.\n",
      "        \"\"\"\n",
      "        return [agent.id for agent in self.agents]\n",
      "\n",
      "    def _get_agent_names(self):\n",
      "        \"\"\"\n",
      "        Retrieves the names of all agents in the agency.\n",
      "\n",
      "        Returns:\n",
      "            List[str]: A list of names of all agents currently part of the agency.\n",
      "        \"\"\"\n",
      "        return [agent.name for agent in self.agents]\n",
      "\n",
      "    def _get_class_folder_path(self):\n",
      "        \"\"\"\n",
      "        Retrieves the absolute path of the directory containing the class file.\n",
      "\n",
      "        Returns:\n",
      "            str: The absolute path of the directory where the class file is located.\n",
      "        \"\"\"\n",
      "        return os.path.abspath(os.path.dirname(inspect.getfile(self.__class__)))\n",
      "\n",
      "    def delete(self):\n",
      "        \"\"\"\n",
      "        This method deletes the agency and all its agents, cleaning up any files and vector stores associated with each agent.\n",
      "        \"\"\"\n",
      "        for agent in self.agents:\n",
      "            agent.delete()\n"
    ],
    "startline": 1,
    "endline": 1190
  },
  {
    "path": "agency_swarm/agency/__init__.py",
    "code": [
      "from .agency import Agency\n"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/GenesisAgency.py",
    "code": [
      "from agency_swarm import Agency\n",
      "from .AgentCreator import AgentCreator\n",
      "\n",
      "from .GenesisCEO import GenesisCEO\n",
      "from .OpenAPICreator import OpenAPICreator\n",
      "from .ToolCreator import ToolCreator\n",
      "from agency_swarm.util.helpers import get_available_agent_descriptions\n",
      "\n",
      "class GenesisAgency(Agency):\n",
      "    def __init__(self, with_browsing=True, **kwargs):\n",
      "        if \"max_prompt_tokens\" not in kwargs:\n",
      "            kwargs[\"max_prompt_tokens\"] = 25000\n",
      "\n",
      "        if 'agency_chart' not in kwargs:\n",
      "            agent_creator = AgentCreator()\n",
      "            genesis_ceo = GenesisCEO()\n",
      "            tool_creator = ToolCreator()\n",
      "            openapi_creator = OpenAPICreator()\n",
      "            kwargs['agency_chart'] = [\n",
      "                genesis_ceo, tool_creator, agent_creator,\n",
      "                [genesis_ceo, agent_creator],\n",
      "                [agent_creator, tool_creator],\n",
      "            ]\n",
      "\n",
      "            if with_browsing:\n",
      "                from agency_swarm.agents.BrowsingAgent import BrowsingAgent\n",
      "                browsing_agent = BrowsingAgent()\n",
      "\n",
      "                browsing_agent.instructions += (\"\"\"\\n\n",
      "# BrowsingAgent's Primary instructions\n",
      "1. Browse the web to find the API documentation requested by the user. Prefer searching google directly for this API documentation page.\n",
      "2. Navigate to the API documentation page and ensure that it contains the necessary API endpoints descriptions. You can use the AnalyzeContent tool to check if the page contains the necessary API descriptions. If not, try perform another search in google and keep browsing until you find the right page.\n",
      "3. If you have confirmed that the page contains the necessary API documentation, export the page with ExportFile tool. Then, send the file_id back to the user along with a brief description of the API.\n",
      "4. Repeat these steps for each new agent, as requested by the user.\n",
      "                \"\"\")\n",
      "                kwargs['agency_chart'].append(openapi_creator)\n",
      "                kwargs['agency_chart'].append([openapi_creator, browsing_agent])\n",
      "\n",
      "        if 'shared_instructions' not in kwargs:\n",
      "            kwargs['shared_instructions'] = \"./manifesto.md\"\n",
      "\n",
      "        super().__init__(**kwargs)\n"
    ],
    "startline": 1,
    "endline": 42
  },
  {
    "path": "agency_swarm/agency/genesis/util.py",
    "code": [
      "import os\n",
      "from pathlib import Path\n",
      "\n",
      "\n",
      "def check_agency_path(self):\n",
      "    if not self._shared_state.get(\"default_folder\"):\n",
      "        self._shared_state.set('default_folder', Path.cwd())\n",
      "\n",
      "    if not self._shared_state.get(\"agency_path\") and not self.agency_name:\n",
      "        available_agencies = os.listdir(\"./\")\n",
      "        available_agencies = [agency for agency in available_agencies if os.path.isdir(agency)]\n",
      "        raise ValueError(f\"Please specify an agency. Available agencies are: {available_agencies}\")\n",
      "    elif not self._shared_state.get(\"agency_path\") and self.agency_name:\n",
      "        if not os.path.exists(os.path.join(\"./\", self.agency_name)):\n",
      "            available_agencies = os.listdir(\"./\")\n",
      "            available_agencies = [agency for agency in available_agencies if os.path.isdir(agency)]\n",
      "            raise ValueError(f\"Agency {self.agency_name} not found. Available agencies are: {available_agencies}\")\n",
      "        self._shared_state.set(\"agency_path\", os.path.join(\"./\", self.agency_name))\n",
      "\n",
      "\n",
      "def check_agent_path(self):\n",
      "    agent_path = os.path.join(self._shared_state.get(\"agency_path\"), self.agent_name)\n",
      "    if not os.path.exists(agent_path):\n",
      "        available_agents = os.listdir(self._shared_state.get(\"agency_path\"))\n",
      "        available_agents = [agent for agent in available_agents if\n",
      "                            os.path.isdir(os.path.join(self._shared_state.get(\"agency_path\"), agent))]\n",
      "        raise ValueError(f\"Agent {self.agent_name} not found. Available agents are: {available_agents}\")\n"
    ],
    "startline": 1,
    "endline": 27
  },
  {
    "path": "agency_swarm/agency/genesis/__init__.py",
    "code": [
      "from .GenesisAgency import GenesisAgency"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/AgentCreator.py",
    "code": [
      "from agency_swarm import Agent\n",
      "from .tools.ImportAgent import ImportAgent\n",
      "from .tools.CreateAgentTemplate import CreateAgentTemplate\n",
      "from .tools.ReadManifesto import ReadManifesto\n",
      "\n",
      "class AgentCreator(Agent):\n",
      "    def __init__(self):\n",
      "        super().__init__(\n",
      "            description=\"This agent is responsible for creating new agents for the agency.\",\n",
      "            instructions=\"./instructions.md\",\n",
      "            tools=[ImportAgent, CreateAgentTemplate, ReadManifesto],\n",
      "            temperature=0.3,\n",
      "        )"
    ],
    "startline": 1,
    "endline": 13
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/__init__.py",
    "code": [
      "from .AgentCreator import AgentCreator"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/tools/CreateAgentTemplate.py",
    "code": [
      "import os\n",
      "import shutil\n",
      "from typing import List\n",
      "\n",
      "from pydantic import Field, model_validator\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "from agency_swarm.agency.genesis.util import check_agency_path\n",
      "from agency_swarm.util import create_agent_template\n",
      "\n",
      "allowed_tools: List = [\"CodeInterpreter\"]\n",
      "\n",
      "web_developer_example_instructions = \"\"\"# Web Developer Agent Instructions\n",
      "\n",
      "You are an agent that builds responsive web applications using Next.js and Material-UI (MUI). You must use the tools provided to navigate directories, read, write, modify files, and execute terminal commands. \n",
      "\n",
      "### Primary Instructions:\n",
      "1. Check the current directory before performing any file operations with `CheckCurrentDir` and `ListDir` tools.\n",
      "2. Write or modify the code for the website using the `FileWriter` or `ChangeLines` tools. Make sure to use the correct file paths and file names. Read the file first if you need to modify it.\n",
      "3. Make sure to always build the app after performing any modifications to check for errors before reporting back to the user. Keep in mind that all files must be reflected on the current website\n",
      "4. Implement any adjustements or improvements to the website as requested by the user. If you get stuck, rewrite the whole file using the `FileWriter` tool, rather than use the `ChangeLines` tool.\n",
      "\"\"\"\n",
      "\n",
      "\n",
      "class CreateAgentTemplate(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool creates a template folder for a new agent. Always use this tool first, before creating tools or APIs for the agent.\n",
      "    \"\"\"\n",
      "    agent_name: str = Field(\n",
      "        ..., description=\"Name of the agent to be created. Cannot include special characters or spaces.\"\n",
      "    )\n",
      "    agent_description: str = Field(\n",
      "        ..., description=\"Description of the agent to be created.\"\n",
      "    )\n",
      "    instructions: str = Field(\n",
      "        ..., description=\"Instructions for the agent to be created in markdown format. \"\n",
      "                         \"Instructions should include a decription of the role and a specific step by step process \"\n",
      "                         \"that this agent need to perform in order to execute the tasks. \"\n",
      "                         \"The process must also be aligned with all the other agents in the agency. Agents should be \"\n",
      "                         \"able to collaborate with each other to achieve the common goal of the agency.\",\n",
      "        examples=[\n",
      "            web_developer_example_instructions,\n",
      "        ]\n",
      "    )\n",
      "    default_tools: List[str] = Field(\n",
      "        [], description=f\"List of default tools to be included in the agent. Possible values are {allowed_tools}.\"\n",
      "                        f\"CodeInterpreter allows the agent to execute python code in a remote python environment.\",\n",
      "        example=[\"CodeInterpreter\"],\n",
      "    )\n",
      "    agency_name: str = Field(\n",
      "        None, description=\"Name of the agency to create the tool for. Defaults to the agency currently being created.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        if not self._shared_state.get(\"manifesto_read\"):\n",
      "            raise ValueError(\"Please read the manifesto first with the ReadManifesto tool.\")\n",
      "\n",
      "        self._shared_state.set(\"agent_name\", self.agent_name)\n",
      "\n",
      "        os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "\n",
      "        # remove folder if it already exists\n",
      "        if os.path.exists(self.agent_name):\n",
      "            shutil.rmtree(self.agent_name)\n",
      "\n",
      "        create_agent_template(self.agent_name,\n",
      "                              self.agent_description,\n",
      "                              instructions=self.instructions,\n",
      "                              code_interpreter=True if \"CodeInterpreter\" in self.default_tools else None,\n",
      "                              include_example_tool=False)\n",
      "\n",
      "        # # create or append to init file\n",
      "        path = self._shared_state.get(\"agency_path\")\n",
      "        class_name = self.agent_name.replace(\" \", \"\").strip()\n",
      "        if not os.path.isfile(\"__init__.py\"):\n",
      "            with open(\"__init__.py\", \"w\") as f:\n",
      "                f.write(f\"from .{class_name} import {class_name}\")\n",
      "        else:\n",
      "            with open(\"__init__.py\", \"a\") as f:\n",
      "                f.write(f\"\\nfrom .{class_name} import {class_name}\")\n",
      "\n",
      "        # add agent on second line to agency.py\n",
      "        with open(\"agency.py\", \"r\") as f:\n",
      "            lines = f.readlines()\n",
      "            lines.insert(1, f\"from {class_name} import {class_name}\\n\")\n",
      "\n",
      "        with open(\"agency.py\", \"w\") as f:\n",
      "            f.writelines(lines)\n",
      "\n",
      "        os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "\n",
      "        if \"ceo\" in self.agent_name.lower():\n",
      "            return f\"You can tell the user that the process of creating {self.agent_name} has been completed, because CEO agent does not need to utilizie any tools or APIs.\"\n",
      "\n",
      "        return f\"Agent template has been created for {self.agent_name}. Please now tell ToolCreator to create tools for this agent or OpenAPICreator to create API schemas, if this agent needs to utilize any tools or APIs. If this is unclear, please ask the user for more information.\"\n",
      "\n",
      "    @model_validator(mode=\"after\")\n",
      "    def validate_tools(self):\n",
      "        check_agency_path(self)\n",
      "\n",
      "        for tool in self.default_tools:\n",
      "            if tool not in allowed_tools:\n",
      "                raise ValueError(f\"Tool {tool} is not allowed. Allowed tools are: {allowed_tools}\")\n"
    ],
    "startline": 1,
    "endline": 103
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/tools/ImportAgent.py",
    "code": [
      "import os\n",
      "\n",
      "from pydantic import Field, field_validator\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "from agency_swarm.util.cli import import_agent\n",
      "from agency_swarm.util.helpers import get_available_agent_descriptions, list_available_agents\n",
      "\n",
      "\n",
      "class ImportAgent(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool imports an existing agent from agency swarm framework. Please make sure to first use the GetAvailableAgents tool to get the list of available agents.\n",
      "    \"\"\"\n",
      "    agent_name: str = Field(...,\n",
      "                            description=get_available_agent_descriptions())\n",
      "    agency_path: str = Field(\n",
      "        None, description=\"Path to the agency where the agent will be imported. Default is the current agency.\")\n",
      "\n",
      "    def run(self):\n",
      "        if not self._shared_state.get(\"default_folder\"):\n",
      "            self._shared_state.set(\"default_folder\", os.getcwd())\n",
      "\n",
      "        if not self._shared_state.get(\"agency_path\") and not self.agency_path:\n",
      "            return \"Error: You must set the agency_path.\"\n",
      "\n",
      "        if self._shared_state.get(\"agency_path\"):\n",
      "            os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "        else:\n",
      "            os.chdir(self.agency_path)\n",
      "\n",
      "        import_agent(self.agent_name, \"./\")\n",
      "\n",
      "        # add agent on second line to agency.py\n",
      "        with open(\"agency.py\", \"r\") as f:\n",
      "            lines = f.readlines()\n",
      "            lines.insert(1, f\"from {self.agent_name} import {self.agent_name}\\n\")\n",
      "\n",
      "        with open(\"agency.py\", \"w\") as f:\n",
      "            f.writelines(lines)\n",
      "\n",
      "        os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "\n",
      "        return (f\"Success. {self.agent_name} has been imported. \"\n",
      "                f\"You can now tell the user to user proceed with next agents.\")\n",
      "\n",
      "    @field_validator(\"agent_name\", mode='after')\n",
      "    @classmethod\n",
      "    def agent_name_exists(cls, v):\n",
      "        available_agents = list_available_agents()\n",
      "        if v not in available_agents:\n",
      "            raise ValueError(\n",
      "                f\"Agent with name {v} does not exist. Available agents are: {available_agents}\")\n",
      "        return v\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    tool = ImportAgent(agent_name=\"Devid\")\n",
      "    tool._shared_state.set(\"agency_path\", \"./\")\n",
      "    tool.run()\n"
    ],
    "startline": 1,
    "endline": 58
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/tools/ReadManifesto.py",
    "code": [
      "import os\n",
      "\n",
      "from pydantic import Field\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "\n",
      "\n",
      "class ReadManifesto(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool reads a manifesto for the agency being created from a markdown file.\n",
      "    \"\"\"\n",
      "    agency_name: str = Field(\n",
      "        None, description=\"Name of the agency to create the tool for. Defaults to the agency currently being created.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        if not self._shared_state.get(\"default_folder\"):\n",
      "            self._shared_state.set('default_folder', os.getcwd())\n",
      "\n",
      "        if not self._shared_state.get(\"agency_path\") and not self.agency_name:\n",
      "            raise ValueError(\"Please specify the agency name. Ask user for clarification if needed.\")\n",
      "\n",
      "        if self.agency_name:\n",
      "            os.chdir(\"./\" + self.agency_name)\n",
      "        else:\n",
      "            os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "\n",
      "        with open(\"agency_manifesto.md\", \"r\") as f:\n",
      "            manifesto = f.read()\n",
      "\n",
      "        os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "\n",
      "        self._shared_state.set(\"manifesto_read\", True)\n",
      "\n",
      "        return manifesto\n"
    ],
    "startline": 1,
    "endline": 35
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/tools/util/get_modules.py",
    "code": [
      "import importlib.resources\n",
      "import pathlib\n",
      "\n",
      "\n",
      "def get_modules(module_name):\n",
      "    \"\"\"\n",
      "    Get all submodule names from a given module based on file names, without importing them,\n",
      "    excluding those containing '.agent' or '.genesis' in their paths.\n",
      "\n",
      "    Args:\n",
      "    - module_name: The name of the module to search through.\n",
      "\n",
      "    Returns:\n",
      "    - A list of submodule names found within the given module.\n",
      "    \"\"\"\n",
      "    submodule_names = []\n",
      "\n",
      "    try:\n",
      "        # Using importlib.resources to access the package contents\n",
      "        with importlib.resources.path(module_name, '') as package_path:\n",
      "            # Walk through the package directory using pathlib\n",
      "            for path in pathlib.Path(package_path).rglob('*.py'):\n",
      "                if path.name != '__init__.py':\n",
      "                    # Construct the module name from the file path\n",
      "                    relative_path = path.relative_to(package_path)\n",
      "                    module_path = '.'.join(relative_path.with_suffix('').parts)\n",
      "\n",
      "                    submodule_names.append(f\"{module_name}.{module_path}\")\n",
      "\n",
      "    except ImportError:\n",
      "        print(f\"Module {module_name} not found.\")\n",
      "        return submodule_names\n",
      "\n",
      "    submodule_names = [name for name in submodule_names if not name.endswith(\".agent\") and\n",
      "                       '.genesis' not in name and\n",
      "                       'util' not in name and\n",
      "                       'oai' not in name and\n",
      "                       'ToolFactory' not in name and\n",
      "                       'BaseTool' not in name]\n",
      "\n",
      "    # remove repetition at the end of the path like 'agency_swarm.agents.coding.CodingAgent.CodingAgent'\n",
      "    for i in range(len(submodule_names)):\n",
      "        splitted = submodule_names[i].split(\".\")\n",
      "        if splitted[-1] == splitted[-2]:\n",
      "            submodule_names[i] = \".\".join(splitted[:-1])\n",
      "\n",
      "    return submodule_names\n"
    ],
    "startline": 1,
    "endline": 47
  },
  {
    "path": "agency_swarm/agency/genesis/AgentCreator/tools/util/__init__.py",
    "code": [
      "from .get_modules import get_modules"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/GenesisCEO/GenesisCEO.py",
    "code": [
      "from pathlib import Path\n",
      "\n",
      "from agency_swarm import Agent\n",
      "from .tools.CreateAgencyFolder import CreateAgencyFolder\n",
      "from .tools.FinalizeAgency import FinalizeAgency\n",
      "from .tools.ReadRequirements import ReadRequirements\n",
      "\n",
      "\n",
      "class GenesisCEO(Agent):\n",
      "    def __init__(self):\n",
      "        super().__init__(\n",
      "            description=\"Acts as the overseer and communicator across the agency, ensuring alignment with the \"\n",
      "                        \"agency's goals.\",\n",
      "            instructions=\"./instructions.md\",\n",
      "            tools=[CreateAgencyFolder, FinalizeAgency, ReadRequirements],\n",
      "            temperature=0.4,\n",
      "        )\n",
      "\n",
      "\n"
    ],
    "startline": 1,
    "endline": 19
  },
  {
    "path": "agency_swarm/agency/genesis/GenesisCEO/__init__.py",
    "code": [
      "from .GenesisCEO import GenesisCEO"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/GenesisCEO/tools/CreateAgencyFolder.py",
    "code": [
      "import shutil\n",
      "from pathlib import Path\n",
      "\n",
      "from pydantic import Field, field_validator\n",
      "\n",
      "import agency_swarm.agency.genesis.GenesisAgency\n",
      "from agency_swarm import BaseTool\n",
      "\n",
      "import os\n",
      "\n",
      "\n",
      "class CreateAgencyFolder(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool creates or modifies an agency folder. You can use it again with the same agency_name to modify a previously created agency, if the user wants to change the agency chart or the manifesto.\n",
      "    \"\"\"\n",
      "    agency_name: str = Field(\n",
      "        ..., description=\"Name of the agency to be created. Must not contain spaces or special characters.\",\n",
      "        examples=[\"AgencyName\", \"MyAgency\", \"ExampleAgency\"]\n",
      "    )\n",
      "    agency_chart: str = Field(\n",
      "        ..., description=\"Agency chart to be passed into the Agency class.\",\n",
      "        examples=[\"[ceo, [ceo, dev], [ceo, va], [dev, va]]\"]\n",
      "    )\n",
      "    manifesto: str = Field(\n",
      "        ..., description=\"Manifesto for the agency, describing its goals and additional context shared by all agents \"\n",
      "                         \"in markdown format. It must include information about the working environment, the mission \"\n",
      "                         \"and the goals of the agency. Do not add descriptions of the agents themselves or the agency structure.\",\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        if not self._shared_state.get(\"default_folder\"):\n",
      "            self._shared_state.set('default_folder', Path.cwd())\n",
      "\n",
      "        if self._shared_state.get(\"agency_name\") is None:\n",
      "            os.mkdir(self.agency_name)\n",
      "            os.chdir(\"./\" + self.agency_name)\n",
      "            self._shared_state.set(\"agency_name\", self.agency_name)\n",
      "            self._shared_state.set(\"agency_path\", Path(\"./\").resolve())\n",
      "        elif self._shared_state.get(\"agency_name\") == self.agency_name and os.path.exists(self._shared_state.get(\"agency_path\")):\n",
      "            os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "            for file in os.listdir():\n",
      "                if file != \"__init__.py\" and os.path.isfile(file):\n",
      "                    os.remove(file)\n",
      "        else:\n",
      "            os.mkdir(self._shared_state.get(\"agency_path\"))\n",
      "            os.chdir(\"./\" + self.agency_name)\n",
      "\n",
      "        # check that agency chart is valid\n",
      "        if not self.agency_chart.startswith(\"[\") or not self.agency_chart.endswith(\"]\"):\n",
      "            raise ValueError(\"Agency chart must be a list of lists, except for the first agents.\")\n",
      "\n",
      "        # add new lines after every comma, except for those inside second brackets\n",
      "        # must transform from \"[ceo, [ceo, dev], [ceo, va], [dev, va] ]\"\n",
      "        # to \"[ceo, [ceo, dev],\\n [ceo, va],\\n [dev, va] ]\"\n",
      "        agency_chart = self.agency_chart.replace(\"],\", \"],\\n\")\n",
      "\n",
      "        # create init file\n",
      "        with open(\"__init__.py\", \"w\") as f:\n",
      "            f.write(\"\")\n",
      "\n",
      "        # create agency.py\n",
      "        with open(\"agency.py\", \"w\") as f:\n",
      "            f.write(agency_py.format(agency_chart=agency_chart))\n",
      "\n",
      "        # write manifesto\n",
      "        path = os.path.join(\"agency_manifesto.md\")\n",
      "        with open(path, \"w\") as f:\n",
      "            f.write(self.manifesto)\n",
      "\n",
      "        os.chdir(self._shared_state.get('default_folder'))\n",
      "\n",
      "        return f\"Agency folder has been created. You can now tell AgentCreator to create agents for {self.agency_name}.\\n\"\n",
      "\n",
      "\n",
      "agency_py = \"\"\"from agency_swarm import Agency\n",
      "\n",
      "\n",
      "agency = Agency({agency_chart},\n",
      "                shared_instructions='./agency_manifesto.md', # shared instructions for all agents\n",
      "                max_prompt_tokens=25000, # default tokens in conversation for all agents\n",
      "                temperature=0.3, # default temperature for all agents\n",
      "                )\n",
      "                \n",
      "if __name__ == '__main__':\n",
      "    agency.demo_gradio()\n",
      "\"\"\""
    ],
    "startline": 1,
    "endline": 86
  },
  {
    "path": "agency_swarm/agency/genesis/GenesisCEO/tools/FinalizeAgency.py",
    "code": [
      "import os\n",
      "from typing import List\n",
      "\n",
      "from pydantic import Field, model_validator, field_validator\n",
      "\n",
      "from agency_swarm import BaseTool, get_openai_client\n",
      "from agency_swarm.util import create_agent_template\n",
      "\n",
      "\n",
      "class FinalizeAgency(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool finalizes the agency structure and it's imports. Please make sure to use at only at the very end, after all agents have been created.\n",
      "    \"\"\"\n",
      "    agency_path: str = Field(\n",
      "        None, description=\"Path to the agency folder. Defaults to the agency currently being created.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        agency_path = None\n",
      "        if self._shared_state.get(\"agency_path\"):\n",
      "            os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "            agency_path = self._shared_state.get(\"agency_path\")\n",
      "        else:\n",
      "            os.chdir(self.agency_path)\n",
      "            agency_path = self.agency_path\n",
      "\n",
      "        client = get_openai_client()\n",
      "\n",
      "        # read agency.py\n",
      "        with open(\"./agency.py\", \"r\") as f:\n",
      "            agency_py = f.read()\n",
      "            f.close()\n",
      "\n",
      "        res = client.chat.completions.create(\n",
      "            model=\"gpt-3.5-turbo\",\n",
      "            messages=examples + [\n",
      "                {'role': \"user\", 'content': agency_py},\n",
      "            ],\n",
      "            temperature=0.0,\n",
      "        )\n",
      "\n",
      "        message = res.choices[0].message.content\n",
      "\n",
      "        # write agency.py\n",
      "        with open(\"./agency.py\", \"w\") as f:\n",
      "            f.write(message)\n",
      "            f.close()\n",
      "\n",
      "        return f\"Successfully finalized {agency_path} structure. You can now instruct the user to run the agency.py file.\"\n",
      "\n",
      "    @model_validator(mode=\"after\")\n",
      "    def validate_agency_path(self):\n",
      "        if not self._shared_state.get(\"agency_path\") and not self.agency_path:\n",
      "            raise ValueError(\"Agency path not found. Please specify the agency_path. Ask user for clarification if needed.\")\n",
      "\n",
      "\n",
      "SYSTEM_PROMPT = \"\"\"\"Please read the file provided by the user and fix all the imports and indentation accordingly. \n",
      "\n",
      "Only output the full valid python code and nothing else.\"\"\"\n",
      "\n",
      "example_input = \"\"\"\n",
      "from agency_swarm import Agency\n",
      "\n",
      "from CEO import CEO\n",
      "from NewsAnalysisAgent import NewsAnalysisAgent\n",
      "from PriceTrackingAgent import PriceTrackingAgent\n",
      "\n",
      "\n",
      "agency = Agency([ceo, [ceo, news_analysis],\n",
      " [ceo, price_tracking],\n",
      " [news_analysis, price_tracking]],\n",
      "shared_instructions='./agency_manifesto.md')\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    agency.demo_gradio()\n",
      "\"\"\"\n",
      "\n",
      "example_output = \"\"\"from agency_swarm import Agency\n",
      "from CEO import CEO\n",
      "from NewsAnalysisAgent import NewsAnalysisAgent\n",
      "from PriceTrackingAgent import PriceTrackingAgent\n",
      "\n",
      "ceo = CEO()\n",
      "news_analysis = NewsAnalysisAgent()\n",
      "price_tracking = PriceTrackingAgent()\n",
      "\n",
      "agency = Agency([ceo, [ceo, market_analyst],\n",
      "                 [ceo, news_curator],\n",
      "                 [market_analyst, news_curator]],\n",
      "                shared_instructions='./agency_manifesto.md')\n",
      "    \n",
      "if __name__ == '__main__':\n",
      "    agency.demo_gradio()\"\"\"\n",
      "\n",
      "examples = [\n",
      "    {'role': \"system\", 'content': SYSTEM_PROMPT},\n",
      "    {'role': \"user\", 'content': example_input},\n",
      "    {'role': \"assistant\", 'content': example_output}\n",
      "]\n"
    ],
    "startline": 1,
    "endline": 99
  },
  {
    "path": "agency_swarm/agency/genesis/GenesisCEO/tools/ReadRequirements.py",
    "code": [
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field\n",
      "import os\n",
      "\n",
      "\n",
      "class ReadRequirements(BaseTool):\n",
      "    \"\"\"\n",
      "    Use this tool to read the agency requirements if user provides them as a file.\n",
      "    \"\"\"\n",
      "\n",
      "    file_path: str = Field(\n",
      "        ..., description=\"The path to the file that needs to be read.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        \"\"\"\n",
      "        Checks if the file exists, and if so, opens the specified file, reads its contents, and returns them.\n",
      "        If the file does not exist, raises a ValueError.\n",
      "        \"\"\"\n",
      "        if not os.path.exists(self.file_path):\n",
      "            raise ValueError(f\"File path does not exist: {self.file_path}\")\n",
      "\n",
      "        try:\n",
      "            with open(self.file_path, 'r', encoding='utf-8') as file:\n",
      "                content = file.read()\n",
      "            return content\n",
      "        except Exception as e:\n",
      "            return f\"An error occurred while reading the file: {str(e)}\"\n"
    ],
    "startline": 1,
    "endline": 28
  },
  {
    "path": "agency_swarm/agency/genesis/OpenAPICreator/OpenAPICreator.py",
    "code": [
      "from agency_swarm import Agent\n",
      "from .tools.CreateToolsFromOpenAPISpec import CreateToolsFromOpenAPISpec\n",
      "\n",
      "\n",
      "class OpenAPICreator(Agent):\n",
      "    def __init__(self):\n",
      "        super().__init__(\n",
      "            description=\"This agent is responsible for creating new tools from an OpenAPI specifications.\",\n",
      "            instructions=\"./instructions.md\",\n",
      "            tools=[CreateToolsFromOpenAPISpec]\n",
      "        )"
    ],
    "startline": 1,
    "endline": 11
  },
  {
    "path": "agency_swarm/agency/genesis/OpenAPICreator/__init__.py",
    "code": [
      "from .OpenAPICreator import OpenAPICreator"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/OpenAPICreator/tools/CreateToolsFromOpenAPISpec.py",
    "code": [
      "import os\n",
      "\n",
      "from pydantic import Field, field_validator, model_validator\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "\n",
      "import json\n",
      "\n",
      "from agency_swarm.agency.genesis.util import check_agency_path, check_agent_path\n",
      "from agency_swarm.tools import ToolFactory\n",
      "from agency_swarm.util.openapi import validate_openapi_spec\n",
      "\n",
      "\n",
      "class CreateToolsFromOpenAPISpec(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool creates a set of tools from an OpenAPI specification. Each method in the specification is converted to a separate tool.\n",
      "    \"\"\"\n",
      "    agent_name: str = Field(\n",
      "        ..., description=\"Name of the agent to create the API for. Must be an existing agent.\"\n",
      "    )\n",
      "    openapi_spec: str = Field(\n",
      "        ..., description=\"OpenAPI specification for the tool to be created as a valid JSON string. Only the relevant \"\n",
      "                         \"endpoints must be included. Responses are not required. Each method should contain \"\n",
      "                         \"an operation id and a description. Do not truncate this schema. \"\n",
      "                         \"It must be a full valid OpenAPI 3.1.0 specification.\",\n",
      "        examples=[\n",
      "            '{\\n  \"openapi\": \"3.1.0\",\\n  \"info\": {\\n    \"title\": \"Get weather data\",\\n    \"description\": \"Retrieves current weather data for a location.\",\\n    \"version\": \"v1.0.0\"\\n  },\\n  \"servers\": [\\n    {\\n      \"url\": \"https://weather.example.com\"\\n    }\\n  ],\\n  \"paths\": {\\n    \"/location\": {\\n      \"get\": {\\n        \"description\": \"Get temperature for a specific location\",\\n        \"operationId\": \"GetCurrentWeather\",\\n        \"parameters\": [\\n          {\\n            \"name\": \"location\",\\n            \"in\": \"query\",\\n            \"description\": \"The city and state to retrieve the weather for\",\\n            \"required\": true,\\n            \"schema\": {\\n              \"type\": \"string\"\\n            }\\n          }\\n        ],\\n        \"deprecated\": false\\n      }\\n    }\\n  },\\n  \"components\": {\\n    \"schemas\": {}\\n  }\\n}'])\n",
      "    agency_name: str = Field(\n",
      "        None, description=\"Name of the agency to create the tool for. Defaults to the agency currently being created.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "\n",
      "        os.chdir(self.agent_name)\n",
      "\n",
      "        try:\n",
      "            try:\n",
      "                tools = ToolFactory.from_openapi_schema(self.openapi_spec)\n",
      "            except Exception as e:\n",
      "                raise ValueError(f\"Error creating tools from OpenAPI Spec: {e}\")\n",
      "\n",
      "            if len(tools) == 0:\n",
      "                return \"No tools created. Please check the OpenAPI specification.\"\n",
      "\n",
      "            tool_names = [tool.__name__ for tool in tools]\n",
      "\n",
      "            # save openapi spec\n",
      "            folder_path = \"./\" + self.agent_name + \"/\"\n",
      "            os.chdir(folder_path)\n",
      "\n",
      "            api_name = json.loads(self.openapi_spec)[\"info\"][\"title\"]\n",
      "\n",
      "            api_name = api_name.replace(\"API\", \"Api\").replace(\" \", \"\")\n",
      "\n",
      "            api_name = ''.join(['_' + i.lower() if i.isupper() else i for i in api_name]).lstrip('_')\n",
      "\n",
      "            with open(\"schemas/\" + api_name + \".json\", \"w\") as f:\n",
      "                f.write(self.openapi_spec)\n",
      "\n",
      "            return \"Successfully added OpenAPI Schema to \" + self._shared_state.get(\"agent_name\")\n",
      "        finally:\n",
      "            os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "\n",
      "    @field_validator(\"openapi_spec\", mode='before')\n",
      "    @classmethod\n",
      "    def validate_openapi_spec(cls, v):\n",
      "        try:\n",
      "            validate_openapi_spec(v)\n",
      "        except json.JSONDecodeError as e:\n",
      "            raise ValueError(\"Invalid JSON format:\", e)\n",
      "        except Exception as e:\n",
      "            raise ValueError(\"Error validating OpenAPI schema:\", e)\n",
      "        return v\n",
      "\n",
      "    @model_validator(mode=\"after\")\n",
      "    def validate_agent_name(self):\n",
      "        check_agency_path(self)\n",
      "\n",
      "        check_agent_path(self)\n",
      "\n"
    ],
    "startline": 1,
    "endline": 81
  },
  {
    "path": "agency_swarm/agency/genesis/ToolCreator/ToolCreator.py",
    "code": [
      "from agency_swarm import Agent\n",
      "from .tools.CreateTool import CreateTool\n",
      "from .tools.TestTool import TestTool\n",
      "\n",
      "\n",
      "class ToolCreator(Agent):\n",
      "    def __init__(self):\n",
      "        super().__init__(\n",
      "            description=\"This agent is responsible for creating new tools for the agency using python code.\",\n",
      "            instructions=\"./instructions.md\",\n",
      "            tools=[CreateTool, TestTool],\n",
      "            temperature=0,\n",
      "        )\n",
      "\n",
      "\n"
    ],
    "startline": 1,
    "endline": 15
  },
  {
    "path": "agency_swarm/agency/genesis/ToolCreator/__init__.py",
    "code": [
      "from .ToolCreator import ToolCreator"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agency/genesis/ToolCreator/tools/CreateTool.py",
    "code": [
      "import os\n",
      "import re\n",
      "from typing import Literal\n",
      "\n",
      "from pydantic import Field, field_validator, model_validator\n",
      "\n",
      "from agency_swarm import get_openai_client\n",
      "from agency_swarm.agency.genesis.util import check_agency_path\n",
      "from agency_swarm.tools import BaseTool\n",
      "\n",
      "prompt = \"\"\"# Agency Swarm Overview\n",
      "\n",
      "Agency Swarm started as a desire and effort of Arsenii Shatokhin (aka VRSEN) to fully automate his AI Agency with AI. By building this framework, we aim to simplify the agent creation process and enable anyone to create a collaborative swarm of agents (Agencies), each with distinct roles and capabilities. \n",
      "\n",
      "# ToolCreator Agent Instructions for Agency Swarm Framework\n",
      "\n",
      "As a ToolCreator Agent within the Agency Swarm framework, your mission is to develop tools that enhance the capabilities of other agents. These tools are pivotal for enabling agents to communicate, collaborate, and efficiently achieve their collective objectives. Below are detailed instructions to guide you through the process of creating tools, ensuring they are both functional and align with the framework's standards.\n",
      "\n",
      "### Tool Creation Guide\n",
      "\n",
      "When creating a tool, you are essentially defining a new class that extends `BaseTool`. This process involves several key steps, outlined below.\n",
      "\n",
      "#### 1. Import Necessary Modules\n",
      "\n",
      "Start by importing `BaseTool` from `agency_swarm.tools` and `Field` from `pydantic`. These imports will serve as the foundation for your custom tool class. Import any additional packages necessary to implement the tool's logic.\n",
      "\n",
      "#### 2. Define Your Tool Class\n",
      "\n",
      "Create a new class that inherits from `BaseTool`. This class will encapsulate the functionality of your tool. `BaseTool` class inherits from the Pydantic's `BaseModel` class.\n",
      "\n",
      "#### 3. Specify Tool Fields\n",
      "\n",
      "Define the fields your tool will use, utilizing Pydantic's `Field` for clear descriptions and validation. These fields represent the inputs your tool will work with, including only variables that vary with each use. Define any constant variables like api keys globally.\n",
      "\n",
      "#### 4. Implement the `run` Method\n",
      "\n",
      "The `run` method is where your tool's logic is executed. Use the fields defined earlier to perform the tool's intended task. It must contain the actual fully functional correct python code. It can utilize various python packages, previously imported in step 1. Do not include any placeholders or hypothetical examples in the code.\n",
      "\n",
      "### Example of a Custom Tool\n",
      "\n",
      "```python\n",
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field\n",
      "import os\n",
      "\n",
      "account_id = \"MY_ACCOUNT_ID\"\n",
      "api_key = os.getenv(\"MY_API_KEY\") # or access_token = os.getenv(\"MY_ACCESS_TOKEN\")\n",
      "\n",
      "class MyCustomTool(BaseTool):\n",
      "    \\\"\\\"\\\"\n",
      "    A brief description of what the custom tool does.\n",
      "    The docstring should clearly explain the tool's purpose and functionality.\n",
      "    It will be used by the agent to determine when to use this tool.\n",
      "    \\\"\\\"\\\"\n",
      "\n",
      "    # Define the fields with descriptions using Pydantic Field\n",
      "    example_field: str = Field(\n",
      "        ..., description=\"Description of the example field, explaining its purpose and usage for the Agent.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        \\\"\\\"\\\"\n",
      "        The implementation of the run method, where the tool's main functionality is executed.\n",
      "        This method should utilize the fields defined above to perform the task.\n",
      "        \\\"\\\"\\\"\n",
      "        # Your custom tool logic goes here\n",
      "        # Example: \n",
      "        # do_something(self.example_field, api_key, account_id)\n",
      "\n",
      "        # Return the result of the tool's operation as a string\n",
      "        return \"Result of MyCustomTool operation\"\n",
      "```\n",
      "\n",
      "To share state between 2 or more tools, you can use the `shared_state` attribute of the tool. It is a dictionary that can be used to store and retrieve values across different tools. This can be useful for passing information between tools or agents. Here is an example of how to use the `shared_state`:\n",
      "\n",
      "```python\n",
      "class MyCustomTool(BaseTool):\n",
      "    def run(self):\n",
      "        # Access the shared state\n",
      "        value = self._shared_state.get(\"key\")\n",
      "        \n",
      "        # Update the shared state\n",
      "        self._shared_state.set(\"key\", \"value\")\n",
      "        \n",
      "        return \"Result of MyCustomTool operation\"\n",
      "        \n",
      "# Access shared state in another tool\n",
      "class AnotherTool(BaseTool):\n",
      "    def run(self):\n",
      "        # Access the shared state\n",
      "        value = self._shared_state.get(\"key\")\n",
      "        \n",
      "        return \"Result of AnotherTool operation\"\n",
      "```\n",
      "\n",
      "This is useful to pass information between tools or agents or to verify the state of the system.  \n",
      "\n",
      "Remember, you must output the resulting python tool code as a whole in a code block, so the user can just copy and paste it into his program. Each tool code snippet must be ready to use. It must not contain any placeholders or hypothetical examples.\"\"\"\n",
      "\n",
      "history = [\n",
      "            {\n",
      "                \"role\": \"system\",\n",
      "                \"content\": prompt\n",
      "            },\n",
      "        ]\n",
      "\n",
      "\n",
      "class CreateTool(BaseTool):\n",
      "    \"\"\"This tool creates other custom tools for the agent, based on your requirements and details.\"\"\"\n",
      "    agent_name: str = Field(\n",
      "        ..., description=\"Name of the agent to create the tool for.\"\n",
      "    )\n",
      "    tool_name: str = Field(..., description=\"Name of the tool class in camel case.\", examples=[\"ExampleTool\"])\n",
      "    requirements: str = Field(\n",
      "        ...,\n",
      "        description=\"The comprehensive requirements explaning the primary functionality of the tool. It must not contain any code or implementation details.\"\n",
      "    )\n",
      "    details: str = Field(\n",
      "        None, description=\"Additional details or error messages, class, function, and variable names.\"\n",
      "    )\n",
      "    mode: Literal[\"write\", \"modify\"] = Field(\n",
      "        ..., description=\"The mode of operation for the tool. 'write' is used to create a new tool or overwrite an existing one. 'modify' is used to modify an existing tool.\"\n",
      "    )\n",
      "    agency_name: str = Field(\n",
      "        None, description=\"Name of the agency to create the tool for. Defaults to the agency currently being created.\"\n",
      "    )\n",
      "\n",
      "    class ToolConfig:\n",
      "        one_call_at_a_time: bool = True\n",
      "\n",
      "    def run(self):\n",
      "        if self.agency_name:\n",
      "            os.chdir(\"./\" + self.agency_name)\n",
      "        else:\n",
      "            os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "        os.chdir(self.agent_name)\n",
      "\n",
      "        client = get_openai_client()\n",
      "\n",
      "        if self.mode == \"write\":\n",
      "            message = f\"Please create a '{self.tool_name}' tool that meets the following requirements: '{self.requirements}'.\\n\\nThe tool class must be named '{self.tool_name}'.\"\n",
      "        else:\n",
      "            message = f\"Please rewrite a '{self.tool_name}' according to the following requirements: '{self.requirements}'.\\n\\nThe tool class must be named '{self.tool_name}'.\"\n",
      "\n",
      "        if self.details:\n",
      "            message += f\"\\nAdditional Details: {self.details}\"\n",
      "\n",
      "        if self.mode == \"modify\":\n",
      "            message += f\"\\nThe existing file content is as follows:\"\n",
      "\n",
      "            try:\n",
      "                with open(\"./tools/\" + self.tool_name + \".py\", 'r') as file:\n",
      "                    prev_content = file.read()\n",
      "                    message += f\"\\n\\n```{prev_content}```\"\n",
      "            except Exception as e:\n",
      "                os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "                return f'Error reading {self.tool_name}: {e}'\n",
      "\n",
      "        history.append({\n",
      "                \"role\": \"user\",\n",
      "                \"content\": message\n",
      "            })\n",
      "\n",
      "        messages = history.copy()\n",
      "\n",
      "        # use the last 6 messages\n",
      "        messages = messages[-6:]\n",
      "\n",
      "        # add system message upfront\n",
      "        messages.insert(0, history[0])\n",
      "\n",
      "        n = 0\n",
      "        code = \"\"\n",
      "        content = \"\"\n",
      "        while n < 3:\n",
      "            resp = client.chat.completions.create(\n",
      "                messages=messages,\n",
      "                model=\"gpt-4o\",\n",
      "                temperature=0,\n",
      "            )\n",
      "\n",
      "            content = resp.choices[0].message.content\n",
      "\n",
      "            messages.append(\n",
      "                {\n",
      "                    \"role\": \"assistant\",\n",
      "                    \"content\": content\n",
      "                }\n",
      "            )\n",
      "\n",
      "            pattern = r\"```(?:[a-zA-Z]+\\n)?(.*?)```\"\n",
      "            match = re.findall(pattern, content, re.DOTALL)\n",
      "            if match:\n",
      "                code = match[-1].strip()\n",
      "                history.append(\n",
      "                    {\n",
      "                        \"role\": \"assistant\",\n",
      "                        \"content\": content\n",
      "                    }\n",
      "                )\n",
      "                break\n",
      "            else:\n",
      "                messages.append(\n",
      "                    {\n",
      "                        \"role\": \"user\",\n",
      "                        \"content\": f\"Error: Could not find the python code block in the response. Please try again.\"\n",
      "                    }\n",
      "                )\n",
      "\n",
      "            n += 1\n",
      "\n",
      "        if n == 3 or not code:\n",
      "            # remove last message from history\n",
      "            history.pop()\n",
      "            os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "            return \"Error: Could not generate a valid file.\"\n",
      "        try:\n",
      "            with open(\"./tools/\" + self.tool_name + \".py\", \"w\") as file:\n",
      "                file.write(code)\n",
      "\n",
      "            os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "            return f'{content}\\n\\nPlease make sure to now test this tool if possible.'\n",
      "        except Exception as e:\n",
      "            os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "            return f'Error writing to file: {e}'\n",
      "\n",
      "    @field_validator(\"requirements\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_requirements(cls, v):\n",
      "        if \"placeholder\" in v:\n",
      "            raise ValueError(\"Requirements contain placeholders. \"\n",
      "                             \"Please never user placeholders. Instead, implement only the code that you are confident about.\")\n",
      "\n",
      "        # check if code is included in requirements\n",
      "        pattern = r'(```)((.*\\n){5,})(```)'\n",
      "        if re.search(pattern, v):\n",
      "            raise ValueError(\n",
      "                \"Requirements contain a code snippet. Please never include code snippets in requirements. \"\n",
      "                \"Requirements must be a description of the complete file to be written. You can include specific class, function, and variable names, but not the actual code.\"\n",
      "            )\n",
      "\n",
      "        return v\n",
      "\n",
      "    @field_validator(\"details\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_details(cls, v):\n",
      "        if len(v) == 0:\n",
      "            raise ValueError(\"Details are required. Remember this tool does not have access to other files. Please provide additional details like relevant documentation, error messages, or class, function, and variable names from other files that this file depends on.\")\n",
      "        return v\n",
      "\n",
      "    @model_validator(mode=\"after\")\n",
      "    def validate_agency_name(self):\n",
      "        if not self.agent_name and not self._shared_state.get(\"agent_name\"):\n",
      "            raise ValueError(\"Please provide agent name.\")\n",
      "\n",
      "        check_agency_path(self)\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    tool = CreateTool(\n",
      "        requirements=\"Write a program that takes a list of integers as input and returns the sum of all the integers in the list.\",\n",
      "        mode=\"write\",\n",
      "        file_path=\"test.py\",\n",
      "    )\n",
      "    print(tool.run())"
    ],
    "startline": 1,
    "endline": 265
  },
  {
    "path": "agency_swarm/agency/genesis/ToolCreator/tools/TestTool.py",
    "code": [
      "import os\n",
      "from typing import Optional\n",
      "\n",
      "from pydantic import Field, model_validator\n",
      "\n",
      "from agency_swarm.agency.genesis.util import check_agency_path\n",
      "from agency_swarm.tools import BaseTool, ToolFactory\n",
      "\n",
      "\n",
      "class TestTool(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool tests other tools defined in tools.py file with the given arguments. Make sure to define the run method before testing.\n",
      "    \"\"\"\n",
      "    agent_name: str = Field(\n",
      "        ..., description=\"Name of the agent to test the tool for.\"\n",
      "    )\n",
      "    chain_of_thought: str = Field(\n",
      "        ..., description=\"Think step by step to determine the correct arguments for testing.\", exclude=True\n",
      "    )\n",
      "    tool_name: str = Field(..., description=\"Name of the tool to be run.\")\n",
      "    arguments: Optional[str] = Field(...,\n",
      "                                     description=\"Arguments to be passed to the tool for testing \"\n",
      "                                                 \"in serialized JSON format.\")\n",
      "    agency_name: str = Field(\n",
      "        None, description=\"Name of the agency to create the tool for. Defaults to the agency currently being created.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        if self.agency_name:\n",
      "            os.chdir(\"./\" + self.agency_name)\n",
      "        else:\n",
      "            os.chdir(self._shared_state.get(\"agency_path\"))\n",
      "        os.chdir(self.agent_name)\n",
      "\n",
      "        # import tool by self.tool_name from local tools.py file\n",
      "        try:\n",
      "            tool = ToolFactory.from_file(f\"./tools/{self.tool_name}.py\")\n",
      "        except Exception as e:\n",
      "            raise ValueError(f\"Error importing tool {self.tool_name}: {e}\")\n",
      "        finally:\n",
      "            os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "\n",
      "        try:\n",
      "            if not self.arguments:\n",
      "                output = tool().run()\n",
      "            else:\n",
      "                output = tool(**eval(self.arguments)).run()\n",
      "        except Exception as e:\n",
      "            raise ValueError(f\"Error running tool {self.tool_name}: {e}\")\n",
      "        finally:\n",
      "            os.chdir(self._shared_state.get(\"default_folder\"))\n",
      "\n",
      "        if not output:\n",
      "            raise ValueError(f\"Tool {self.tool_name} did not return any output.\")\n",
      "\n",
      "        return f\"Successfully initialized and ran tool. Output: '{output}'\"\n",
      "\n",
      "    @model_validator(mode=\"after\")\n",
      "    def validate_tool_name(self):\n",
      "        check_agency_path(self)\n",
      "\n",
      "        if not self.agent_name and not self._shared_state.get(\"agent_name\"):\n",
      "            raise ValueError(\"Please provide agent name.\")\n",
      "\n",
      "        agent_name = self.agent_name or self._shared_state.get(\"agent_name\")\n",
      "\n",
      "        tool_path = os.path.join(self._shared_state.get(\"agency_path\"), agent_name)\n",
      "        tool_path = os.path.join(str(tool_path), \"tools\")\n",
      "        tool_path = os.path.join(tool_path, self.tool_name + \".py\")\n",
      "\n",
      "\n",
      "        # check if tools.py file exists\n",
      "        if not os.path.isfile(tool_path):\n",
      "            available_tools = os.listdir(os.path.join(self._shared_state.get(\"agency_path\"), agent_name))\n",
      "            available_tools = [tool for tool in available_tools if tool.endswith(\".py\")]\n",
      "            available_tools = [tool for tool in available_tools if\n",
      "                               not tool.startswith(\"__\") and not tool.startswith(\".\")]\n",
      "            available_tools = [tool.replace(\".py\", \"\") for tool in available_tools]\n",
      "            available_tools = \", \".join(available_tools)\n",
      "            raise ValueError(f\"Tool {self.tool_name} not found. Available tools are: {available_tools}\")\n",
      "\n",
      "        agent_path = os.path.join(self._shared_state.get(\"agency_path\"), self.agent_name)\n",
      "        if not os.path.exists(agent_path):\n",
      "            available_agents = os.listdir(self._shared_state.get(\"agency_path\"))\n",
      "            available_agents = [agent for agent in available_agents if\n",
      "                                os.path.isdir(os.path.join(self._shared_state.get(\"agency_path\"), agent))]\n",
      "            raise ValueError(f\"Agent {self.agent_name} not found. Available agents are: {available_agents}\")\n",
      "\n",
      "        return True\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    TestTool._shared_state.data = {\"agency_path\": \"/Users/vrsen/Projects/agency-swarm/agency-swarm/TestAgency\",\n",
      "                              \"default_folder\": \"/Users/vrsen/Projects/agency-swarm/agency-swarm/TestAgency\"}\n",
      "    test_tool = TestTool(agent_name=\"TestAgent\", tool_name=\"PrintTestTool\", arguments=\"{}\", chain_of_thought=\"\")\n",
      "    print(test_tool.run())\n"
    ],
    "startline": 1,
    "endline": 96
  },
  {
    "path": "agency_swarm/agents/agent.py",
    "code": [
      "import copy\n",
      "import inspect\n",
      "import json\n",
      "import os\n",
      "from typing import Dict, Union, Any, Type, Literal, TypedDict, Optional\n",
      "from typing import List\n",
      "\n",
      "from deepdiff import DeepDiff\n",
      "from openai import NotFoundError\n",
      "from openai.types.beta.assistant import ToolResources\n",
      "\n",
      "from agency_swarm.tools import BaseTool, ToolFactory, Retrieval\n",
      "from agency_swarm.tools import FileSearch, CodeInterpreter\n",
      "from agency_swarm.tools.oai.FileSearch import FileSearchConfig\n",
      "from agency_swarm.util.oai import get_openai_client\n",
      "from agency_swarm.util.openapi import validate_openapi_spec\n",
      "from agency_swarm.util.shared_state import SharedState\n",
      "from pydantic import BaseModel\n",
      "from openai.lib._parsing._completions import type_to_response_format_param\n",
      "\n",
      "class ExampleMessage(TypedDict):\n",
      "    role: Literal[\"user\", \"assistant\"]\n",
      "    content: str\n",
      "    attachments: Optional[List[dict]]\n",
      "    metadata: Optional[Dict[str, str]]\n",
      "\n",
      "\n",
      "class Agent():\n",
      "    _shared_state: SharedState = None\n",
      "    \n",
      "    @property\n",
      "    def assistant(self):\n",
      "        if not hasattr(self, '_assistant') or self._assistant is None:\n",
      "            raise Exception(\"Assistant is not initialized. Please run init_oai() first.\")\n",
      "        return self._assistant\n",
      "\n",
      "    @assistant.setter\n",
      "    def assistant(self, value):\n",
      "        self._assistant = value\n",
      "\n",
      "    @property\n",
      "    def functions(self):\n",
      "        return [tool for tool in self.tools if issubclass(tool, BaseTool)]\n",
      "    \n",
      "    @property\n",
      "    def shared_state(self):\n",
      "        return self._shared_state\n",
      "\n",
      "    @shared_state.setter\n",
      "    def shared_state(self, value):\n",
      "        self._shared_state = value\n",
      "        for tool in self.tools:\n",
      "            if issubclass(tool, BaseTool):\n",
      "                tool._shared_state = value\n",
      "\n",
      "    def response_validator(self, message: str | list) -> str:\n",
      "        \"\"\"\n",
      "        Validates the response from the agent. If the response is invalid, it must raise an exception with instructions\n",
      "        for the caller agent on how to proceed.\n",
      "\n",
      "        Parameters:\n",
      "            message (str): The response from the agent.\n",
      "\n",
      "        Returns:\n",
      "            str: The validated response.\n",
      "        \"\"\"\n",
      "        return message\n",
      "\n",
      "    def __init__(\n",
      "            self,\n",
      "            id: str = None,\n",
      "            name: str = None,\n",
      "            description: str = None,\n",
      "            instructions: str = \"\",\n",
      "            tools: List[Union[Type[BaseTool], Type[FileSearch], Type[CodeInterpreter], type[Retrieval]]] = None,\n",
      "            tool_resources: ToolResources = None,\n",
      "            temperature: float = None,\n",
      "            top_p: float = None,\n",
      "            response_format: Union[str, dict, type] = \"auto\",\n",
      "            tools_folder: str = None,\n",
      "            files_folder: Union[List[str], str] = None,\n",
      "            schemas_folder: Union[List[str], str] = None,\n",
      "            api_headers: Dict[str, Dict[str, str]] = None,\n",
      "            api_params: Dict[str, Dict[str, str]] = None,\n",
      "            file_ids: List[str] = None,\n",
      "            metadata: Dict[str, str] = None,\n",
      "            model: str = \"gpt-4o-2024-08-06\",\n",
      "            validation_attempts: int = 1,\n",
      "            max_prompt_tokens: int = None,\n",
      "            max_completion_tokens: int = None,\n",
      "            truncation_strategy: dict = None,\n",
      "            examples: List[ExampleMessage] = None,\n",
      "            file_search: FileSearchConfig = None,\n",
      "            parallel_tool_calls: bool = True,\n",
      "    ):\n",
      "        \"\"\"\n",
      "        Initializes an Agent with specified attributes, tools, and OpenAI client.\n",
      "\n",
      "        Parameters:\n",
      "            id (str, optional): Loads the assistant from OpenAI assistant ID. Assistant will be created or loaded from settings if ID is not provided. Defaults to None.\n",
      "            name (str, optional): Name of the agent. Defaults to the class name if not provided.\n",
      "            description (str, optional): A brief description of the agent's purpose. Defaults to None.\n",
      "            instructions (str, optional): Path to a file containing specific instructions for the agent. Defaults to an empty string.\n",
      "            tools (List[Union[Type[BaseTool], Type[Retrieval], Type[CodeInterpreter]]], optional): A list of tools (as classes) that the agent can use. Defaults to an empty list.\n",
      "            tool_resources (ToolResources, optional): A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code_interpreter tool requires a list of file IDs, while the file_search tool requires a list of vector store IDs. Defaults to None.\n",
      "            temperature (float, optional): The temperature parameter for the OpenAI API. Defaults to None.\n",
      "            top_p (float, optional): The top_p parameter for the OpenAI API. Defaults to None.\n",
      "            response_format (Union[str, Dict, type], optional): The response format for the OpenAI API. If BaseModel is provided, it will be converted to a response format. Defaults to None.\n",
      "            tools_folder (str, optional): Path to a directory containing tools associated with the agent. Each tool must be defined in a separate file. File must be named as the class name of the tool. Defaults to None.\n",
      "            files_folder (Union[List[str], str], optional): Path or list of paths to directories containing files associated with the agent. Defaults to None.\n",
      "            schemas_folder (Union[List[str], str], optional): Path or list of paths to directories containing OpenAPI schemas associated with the agent. Defaults to None.\n",
      "            api_headers (Dict[str,Dict[str, str]], optional): Headers to be used for the openapi requests. Each key must be a full filename from schemas_folder. Defaults to an empty dictionary.\n",
      "            api_params (Dict[str, Dict[str, str]], optional): Extra params to be used for the openapi requests. Each key must be a full filename from schemas_folder. Defaults to an empty dictionary.\n",
      "            metadata (Dict[str, str], optional): Metadata associated with the agent. Defaults to an empty dictionary.\n",
      "            model (str, optional): The model identifier for the OpenAI API. Defaults to \"gpt-4o\".\n",
      "            validation_attempts (int, optional): Number of attempts to validate the response with response_validator function. Defaults to 1.\n",
      "            max_prompt_tokens (int, optional): Maximum number of tokens allowed in the prompt. Defaults to None.\n",
      "            max_completion_tokens (int, optional): Maximum number of tokens allowed in the completion. Defaults to None.\n",
      "            truncation_strategy (TruncationStrategy, optional): Truncation strategy for the OpenAI API. Defaults to None.\n",
      "            examples (List[Dict], optional): A list of example messages for the agent. Defaults to None.\n",
      "            file_search (FileSearchConfig, optional): A dictionary containing the file search tool configuration. Defaults to None.\n",
      "            parallel_tool_calls (bool, optional): Whether to enable parallel function calling during tool use. Defaults to True.\n",
      "\n",
      "        This constructor sets up the agent with its unique properties, initializes the OpenAI client, reads instructions if provided, and uploads any associated files.\n",
      "        \"\"\"\n",
      "        # public attributes\n",
      "        self.id = id\n",
      "        self.name = name if name else self.__class__.__name__\n",
      "        self.description = description\n",
      "        self.instructions = instructions\n",
      "        self.tools = tools[:] if tools is not None else []\n",
      "        self.tools = [tool for tool in self.tools if tool.__name__ != \"ExampleTool\"]\n",
      "        self.tool_resources = tool_resources\n",
      "        self.temperature = temperature\n",
      "        self.top_p = top_p\n",
      "        self.response_format = response_format\n",
      "        # use structured outputs if response_format is a BaseModel\n",
      "        if isinstance(self.response_format, type):\n",
      "            self.response_format = type_to_response_format_param(self.response_format)\n",
      "        self.tools_folder = tools_folder\n",
      "        self.files_folder = files_folder if files_folder else []\n",
      "        self.schemas_folder = schemas_folder if schemas_folder else []\n",
      "        self.api_headers = api_headers if api_headers else {}\n",
      "        self.api_params = api_params if api_params else {}\n",
      "        self.metadata = metadata if metadata else {}\n",
      "        self.model = model\n",
      "        self.validation_attempts = validation_attempts\n",
      "        self.max_prompt_tokens = max_prompt_tokens\n",
      "        self.max_completion_tokens = max_completion_tokens\n",
      "        self.truncation_strategy = truncation_strategy\n",
      "        self.examples = examples\n",
      "        self.file_search = file_search\n",
      "        self.parallel_tool_calls = parallel_tool_calls\n",
      "\n",
      "        self.settings_path = './settings.json'\n",
      "\n",
      "        # private attributes\n",
      "        self._assistant: Any = None\n",
      "        self._shared_instructions = None\n",
      "\n",
      "        # init methods\n",
      "        self.client = get_openai_client()\n",
      "        self._read_instructions()\n",
      "\n",
      "        # upload files\n",
      "        self._upload_files()\n",
      "        if file_ids:\n",
      "            print(\"Warning: 'file_ids' parameter is deprecated. Please use 'tool_resources' parameter instead.\")\n",
      "            self.add_file_ids(file_ids, \"file_search\")\n",
      "\n",
      "        self._parse_schemas()\n",
      "        self._parse_tools_folder()\n",
      "\n",
      "    # --- OpenAI Assistant Methods ---\n",
      "\n",
      "    def init_oai(self):\n",
      "        \"\"\"\n",
      "        Initializes the OpenAI assistant for the agent.\n",
      "\n",
      "        This method handles the initialization and potential updates of the agent's OpenAI assistant. It loads the assistant based on a saved ID, updates the assistant if necessary, or creates a new assistant if it doesn't exist. After initialization or update, it saves the assistant's settings.\n",
      "\n",
      "        Output:\n",
      "            self: Returns the agent instance for chaining methods or further processing.\n",
      "        \"\"\"\n",
      "\n",
      "        # check if settings.json exists\n",
      "        path = self.get_settings_path()\n",
      "\n",
      "        # load assistant from id\n",
      "        if self.id:\n",
      "            self.assistant = self.client.beta.assistants.retrieve(self.id)\n",
      "\n",
      "            # Assign attributes to self if they are None\n",
      "            self.instructions = self.instructions or self.assistant.instructions\n",
      "            self.name = self.name if self.name != self.__class__.__name__ else self.assistant.name\n",
      "            self.description = self.description or self.assistant.description\n",
      "            self.temperature = self.assistant.temperature if self.temperature is None else self.temperature\n",
      "            self.top_p = self.top_p or self.assistant.top_p\n",
      "            self.response_format = self.response_format or self.assistant.response_format\n",
      "            if not isinstance(self.response_format, str):\n",
      "                self.response_format = self.response_format or self.response_format.model_dump()\n",
      "            else:\n",
      "                self.response_format = self.response_format or self.assistant.response_format\n",
      "            self.tool_resources = self.tool_resources or self.assistant.tool_resources.model_dump()\n",
      "            self.metadata = self.metadata or self.assistant.metadata\n",
      "            self.model = self.model or self.assistant.model\n",
      "            self.tool_resources = self.tool_resources or self.assistant.tool_resources.model_dump()\n",
      "\n",
      "            for tool in self.assistant.tools:\n",
      "                # update assistants created with v1\n",
      "                if tool.type == \"retrieval\":\n",
      "                    self.client.beta.assistants.update(self.id, tools=self.get_oai_tools())\n",
      "\n",
      "            # # update assistant if parameters are different\n",
      "            # if not self._check_parameters(self.assistant.model_dump()):\n",
      "            #     self._update_assistant()\n",
      "\n",
      "            return self\n",
      "\n",
      "        # load assistant from settings\n",
      "        if os.path.exists(path):\n",
      "            with open(path, 'r') as f:\n",
      "                settings = json.load(f)\n",
      "                # iterate settings and find the assistant with the same name\n",
      "                for assistant_settings in settings:\n",
      "                    if assistant_settings['name'] == self.name:\n",
      "                        try:\n",
      "                            self.assistant = self.client.beta.assistants.retrieve(assistant_settings['id'])\n",
      "                            self.id = assistant_settings['id']\n",
      "\n",
      "                            # update assistant if parameters are different\n",
      "                            if not self._check_parameters(self.assistant.model_dump()):\n",
      "                                print(\"Updating agent... \" + self.name)\n",
      "                                self._update_assistant()\n",
      "\n",
      "                            if self.assistant.tool_resources:\n",
      "                                self.tool_resources = self.assistant.tool_resources.model_dump()\n",
      "\n",
      "                            self._update_settings()\n",
      "                            return self\n",
      "                        except NotFoundError:\n",
      "                            continue\n",
      "\n",
      "        # create assistant if settings.json does not exist or assistant with the same name does not exist\n",
      "        self.assistant = self.client.beta.assistants.create(\n",
      "            model=self.model,\n",
      "            name=self.name,\n",
      "            description=self.description,\n",
      "            instructions=self.instructions,\n",
      "            tools=self.get_oai_tools(),\n",
      "            tool_resources=self.tool_resources,\n",
      "            metadata=self.metadata,\n",
      "            temperature=self.temperature,\n",
      "            top_p=self.top_p,\n",
      "            response_format=self.response_format,\n",
      "        )\n",
      "\n",
      "        if self.assistant.tool_resources:\n",
      "            self.tool_resources = self.assistant.tool_resources.model_dump()\n",
      "\n",
      "        self.id = self.assistant.id\n",
      "\n",
      "        self._save_settings()\n",
      "\n",
      "        return self\n",
      "\n",
      "    def _update_assistant(self):\n",
      "        \"\"\"\n",
      "        Updates the existing assistant's parameters on the OpenAI server.\n",
      "\n",
      "        This method updates the assistant's details such as name, description, instructions, tools, file IDs, metadata, and the model. It only updates parameters that have non-empty values. After updating the assistant, it also updates the local settings file to reflect these changes.\n",
      "\n",
      "        No input parameters are directly passed to this method as it uses the agent's instance attributes.\n",
      "\n",
      "        No output parameters are returned, but the method updates the assistant's details on the OpenAI server and locally updates the settings file.\n",
      "        \"\"\"\n",
      "        tool_resources = copy.deepcopy(self.tool_resources)\n",
      "        if tool_resources and tool_resources.get('file_search'):\n",
      "            tool_resources['file_search'].pop('vector_stores', None)\n",
      "\n",
      "        params = {\n",
      "            \"name\": self.name,\n",
      "            \"description\": self.description,\n",
      "            \"instructions\": self.instructions,\n",
      "            \"tools\": self.get_oai_tools(),\n",
      "            \"tool_resources\": tool_resources,\n",
      "            \"temperature\": self.temperature,\n",
      "            \"top_p\": self.top_p,\n",
      "            \"response_format\": self.response_format,\n",
      "            \"metadata\": self.metadata,\n",
      "            \"model\": self.model\n",
      "        }\n",
      "        params = {k: v for k, v in params.items() if v}\n",
      "        self.assistant = self.client.beta.assistants.update(\n",
      "            self.id,\n",
      "            **params,\n",
      "        )\n",
      "        self._update_settings()\n",
      "\n",
      "    def _upload_files(self):\n",
      "        def add_id_to_file(f_path, id):\n",
      "            \"\"\"Add file id to file name\"\"\"\n",
      "            if os.path.isfile(f_path):\n",
      "                file_name, file_ext = os.path.splitext(f_path)\n",
      "                f_path_new = file_name + \"_\" + id + file_ext\n",
      "                os.rename(f_path, f_path_new)\n",
      "                return f_path_new\n",
      "\n",
      "        def get_id_from_file(f_path):\n",
      "            \"\"\"Get file id from file name\"\"\"\n",
      "            if os.path.isfile(f_path):\n",
      "                file_name, file_ext = os.path.splitext(f_path)\n",
      "                file_name = os.path.basename(file_name)\n",
      "                file_name = file_name.split(\"_\")\n",
      "                if len(file_name) > 1:\n",
      "                    return file_name[-1] if \"file-\" in file_name[-1] else None\n",
      "                else:\n",
      "                    return None\n",
      "\n",
      "        files_folders = self.files_folder if isinstance(self.files_folder, list) else [self.files_folder]\n",
      "\n",
      "        file_search_ids = []\n",
      "        code_interpreter_ids = []\n",
      "\n",
      "        for files_folder in files_folders:\n",
      "            if isinstance(files_folder, str):\n",
      "                f_path = files_folder\n",
      "\n",
      "                if not os.path.isdir(f_path):\n",
      "                    f_path = os.path.join(self.get_class_folder_path(), files_folder)\n",
      "                    f_path = os.path.normpath(f_path)\n",
      "\n",
      "                if os.path.isdir(f_path):\n",
      "                    f_paths = os.listdir(f_path)\n",
      "\n",
      "                    f_paths = [f for f in f_paths if not f.startswith(\".\")]\n",
      "\n",
      "                    f_paths = [os.path.join(f_path, f) for f in f_paths]\n",
      "\n",
      "                    code_interpreter_file_extensions = [\n",
      "                        \".json\",  # JSON\n",
      "                        \".csv\",  # CSV\n",
      "                        \".xml\",  # XML\n",
      "                        \".jpeg\",  # JPEG\n",
      "                        \".jpg\",  # JPEG\n",
      "                        \".gif\",  # GIF\n",
      "                        \".png\",  # PNG\n",
      "                        \".zip\"  # ZIP\n",
      "                    ]\n",
      "\n",
      "                    for f_path in f_paths:\n",
      "                        file_ext = os.path.splitext(f_path)[1]\n",
      "\n",
      "                        f_path = f_path.strip()\n",
      "                        file_id = get_id_from_file(f_path)\n",
      "                        if file_id:\n",
      "                            print(\"File already uploaded. Skipping... \" + os.path.basename(f_path))\n",
      "                        else:\n",
      "                            print(\"Uploading new file... \" + os.path.basename(f_path))\n",
      "                            with open(f_path, 'rb') as f:\n",
      "                                file_id = self.client.with_options(\n",
      "                                    timeout=80 * 1000,\n",
      "                                ).files.create(file=f, purpose=\"assistants\").id\n",
      "                                f.close()\n",
      "                            add_id_to_file(f_path, file_id)\n",
      "\n",
      "                        if file_ext in code_interpreter_file_extensions:\n",
      "                            code_interpreter_ids.append(file_id)\n",
      "                        else:\n",
      "                            file_search_ids.append(file_id)\n",
      "                else:\n",
      "                    print(f\"Files folder '{f_path}' is not a directory. Skipping...\", )\n",
      "            else:\n",
      "                print(\"Files folder path must be a string or list of strings. Skipping... \", files_folder)\n",
      "\n",
      "        if FileSearch not in self.tools and file_search_ids:\n",
      "            print(\"Detected files without FileSearch. Adding FileSearch tool...\")\n",
      "            self.add_tool(FileSearch)\n",
      "        if CodeInterpreter not in self.tools and code_interpreter_ids:\n",
      "            print(\"Detected files without FileSearch. Adding FileSearch tool...\")\n",
      "            self.add_tool(CodeInterpreter)\n",
      "\n",
      "        self.add_file_ids(file_search_ids, \"file_search\")\n",
      "        self.add_file_ids(code_interpreter_ids, \"code_interpreter\")\n",
      "\n",
      "    # --- Tool Methods ---\n",
      "\n",
      "    # TODO: fix 2 methods below\n",
      "    def add_tool(self, tool):\n",
      "        if not isinstance(tool, type):\n",
      "            raise Exception(\"Tool must not be initialized.\")\n",
      "        if issubclass(tool, FileSearch):\n",
      "            # check that tools name is not already in tools\n",
      "            for t in self.tools:\n",
      "                if issubclass(t, FileSearch):\n",
      "                    return\n",
      "            self.tools.append(tool)\n",
      "        elif issubclass(tool, CodeInterpreter):\n",
      "            for t in self.tools:\n",
      "                if issubclass(t, CodeInterpreter):\n",
      "                    return\n",
      "            self.tools.append(tool)\n",
      "        elif issubclass(tool, Retrieval):\n",
      "            for t in self.tools:\n",
      "                if issubclass(t, Retrieval):\n",
      "                    return\n",
      "            self.tools.append(tool)\n",
      "        elif issubclass(tool, BaseTool):\n",
      "            if tool.__name__ == \"ExampleTool\":\n",
      "                print(\"Skipping importing ExampleTool...\")\n",
      "                return\n",
      "            for t in self.tools:\n",
      "                if t.__name__ == tool.__name__:\n",
      "                    self.tools.remove(t)\n",
      "            self.tools.append(tool)\n",
      "        else:\n",
      "            raise Exception(\"Invalid tool type.\")\n",
      "\n",
      "    def get_oai_tools(self):\n",
      "        tools = []\n",
      "        for tool in self.tools:\n",
      "            if not isinstance(tool, type):\n",
      "                print(tool)\n",
      "                raise Exception(\"Tool must not be initialized.\")\n",
      "\n",
      "            if issubclass(tool, FileSearch):\n",
      "                tools.append(tool(file_search=self.file_search).model_dump(exclude_none=True))\n",
      "            elif issubclass(tool, CodeInterpreter):\n",
      "                tools.append(tool().model_dump())\n",
      "            elif issubclass(tool, Retrieval):\n",
      "                tools.append(tool().model_dump())\n",
      "            elif issubclass(tool, BaseTool):\n",
      "                tools.append({\n",
      "                    \"type\": \"function\",\n",
      "                    \"function\": tool.openai_schema\n",
      "                })\n",
      "            else:\n",
      "                raise Exception(\"Invalid tool type.\")\n",
      "        return tools\n",
      "\n",
      "    def _parse_schemas(self):\n",
      "        schemas_folders = self.schemas_folder if isinstance(self.schemas_folder, list) else [self.schemas_folder]\n",
      "\n",
      "        for schemas_folder in schemas_folders:\n",
      "            if isinstance(schemas_folder, str):\n",
      "                f_path = schemas_folder\n",
      "\n",
      "                if not os.path.isdir(f_path):\n",
      "                    f_path = os.path.join(self.get_class_folder_path(), schemas_folder)\n",
      "                    f_path = os.path.normpath(f_path)\n",
      "\n",
      "                if os.path.isdir(f_path):\n",
      "                    f_paths = os.listdir(f_path)\n",
      "\n",
      "                    f_paths = [f for f in f_paths if not f.startswith(\".\")]\n",
      "\n",
      "                    f_paths = [os.path.join(f_path, f) for f in f_paths]\n",
      "\n",
      "                    for f_path in f_paths:\n",
      "                        with open(f_path, 'r') as f:\n",
      "                            openapi_spec = f.read()\n",
      "                            f.close()\n",
      "                        try:\n",
      "                            validate_openapi_spec(openapi_spec)\n",
      "                        except Exception as e:\n",
      "                            print(\"Invalid OpenAPI schema: \" + os.path.basename(f_path))\n",
      "                            raise e\n",
      "                        try:\n",
      "                            headers = None\n",
      "                            params = None\n",
      "                            if os.path.basename(f_path) in self.api_headers:\n",
      "                                headers = self.api_headers[os.path.basename(f_path)]\n",
      "                            if os.path.basename(f_path) in self.api_params:\n",
      "                                params = self.api_params[os.path.basename(f_path)]\n",
      "                            tools = ToolFactory.from_openapi_schema(openapi_spec, headers=headers, params=params)\n",
      "                        except Exception as e:\n",
      "                            print(\"Error parsing OpenAPI schema: \" + os.path.basename(f_path))\n",
      "                            raise e\n",
      "                        for tool in tools:\n",
      "                            self.add_tool(tool)\n",
      "                else:\n",
      "                    print(\"Schemas folder path is not a directory. Skipping... \", f_path)\n",
      "            else:\n",
      "                print(\"Schemas folder path must be a string or list of strings. Skipping... \", schemas_folder)\n",
      "\n",
      "    def _parse_tools_folder(self):\n",
      "        if not self.tools_folder:\n",
      "            return\n",
      "\n",
      "        if not os.path.isdir(self.tools_folder):\n",
      "            self.tools_folder = os.path.join(self.get_class_folder_path(), self.tools_folder)\n",
      "            self.tools_folder = os.path.normpath(self.tools_folder)\n",
      "\n",
      "        if os.path.isdir(self.tools_folder):\n",
      "            f_paths = os.listdir(self.tools_folder)\n",
      "            f_paths = [f for f in f_paths if not f.startswith(\".\") and not f.startswith(\"__\")]\n",
      "            f_paths = [os.path.join(self.tools_folder, f) for f in f_paths]\n",
      "            for f_path in f_paths:\n",
      "                if not f_path.endswith(\".py\"):\n",
      "                    continue\n",
      "                if os.path.isfile(f_path):\n",
      "                    try:\n",
      "                        tool = ToolFactory.from_file(f_path)\n",
      "                        self.add_tool(tool)\n",
      "                    except Exception as e:\n",
      "                        print(f\"Error parsing tool file {os.path.basename(f_path)}: {e}. Skipping...\")\n",
      "                else:\n",
      "                    print(\"Items in tools folder must be files. Skipping... \", f_path)\n",
      "        else:\n",
      "            print(\"Tools folder path is not a directory. Skipping... \", self.tools_folder)\n",
      "\n",
      "    def get_openapi_schema(self, url):\n",
      "        \"\"\"Get openapi schema that contains all tools from the agent as different api paths. Make sure to call this after agency has been initialized.\"\"\"\n",
      "        if self.assistant is None:\n",
      "            raise Exception(\n",
      "                \"Assistant is not initialized. Please initialize the agency first, before using this method\")\n",
      "\n",
      "        return ToolFactory.get_openapi_schema(self.tools, url)\n",
      "\n",
      "    # --- Settings Methods ---\n",
      "\n",
      "    def _check_parameters(self, assistant_settings, debug=False):\n",
      "        \"\"\"\n",
      "        Checks if the agent's parameters match with the given assistant settings.\n",
      "\n",
      "        Parameters:\n",
      "            assistant_settings (dict): A dictionary containing the settings of an assistant.\n",
      "            debug (bool): If True, prints debug statements. Default is False.\n",
      "\n",
      "        Returns:\n",
      "            bool: True if all the agent's parameters match the assistant settings, False otherwise.\n",
      "\n",
      "        This method compares the current agent's parameters such as name, description, instructions, tools, file IDs, metadata, and model with the given assistant settings. It uses DeepDiff to compare complex structures like tools and metadata. If any parameter does not match, it returns False; otherwise, it returns True.\n",
      "        \"\"\"\n",
      "        if self.name != assistant_settings['name']:\n",
      "            if debug:\n",
      "                print(f\"Name mismatch: {self.name} != {assistant_settings['name']}\")\n",
      "            return False\n",
      "\n",
      "        if self.description != assistant_settings['description']:\n",
      "            if debug:\n",
      "                print(f\"Description mismatch: {self.description} != {assistant_settings['description']}\")\n",
      "            return False\n",
      "\n",
      "        if self.instructions != assistant_settings['instructions']:\n",
      "            if debug:\n",
      "                print(f\"Instructions mismatch: {self.instructions} != {assistant_settings['instructions']}\")\n",
      "            return False\n",
      "\n",
      "        tools_diff = DeepDiff(self.get_oai_tools(), assistant_settings['tools'], ignore_order=True)\n",
      "        if tools_diff != {}:\n",
      "            if debug:\n",
      "                print(f\"Tools mismatch: {tools_diff}\")\n",
      "                print(\"local tools: \", self.get_oai_tools())\n",
      "                print(\"assistant tools: \", assistant_settings['tools'])\n",
      "            return False\n",
      "\n",
      "        if self.temperature != assistant_settings['temperature']:\n",
      "            if debug:\n",
      "                print(f\"Temperature mismatch: {self.temperature} != {assistant_settings['temperature']}\")\n",
      "            return False\n",
      "\n",
      "        if self.top_p != assistant_settings['top_p']:\n",
      "            if debug:\n",
      "                print(f\"Top_p mismatch: {self.top_p} != {assistant_settings['top_p']}\")\n",
      "            return False\n",
      "\n",
      "        tool_resources_settings = copy.deepcopy(self.tool_resources)\n",
      "        if tool_resources_settings and tool_resources_settings.get('file_search'):\n",
      "            tool_resources_settings['file_search'].pop('vector_stores', None)\n",
      "        tool_resources_diff = DeepDiff(tool_resources_settings, assistant_settings['tool_resources'], ignore_order=True)\n",
      "        if tool_resources_diff != {}:\n",
      "            if debug:\n",
      "                print(f\"Tool resources mismatch: {tool_resources_diff}\")\n",
      "            return False\n",
      "\n",
      "        metadata_diff = DeepDiff(self.metadata, assistant_settings['metadata'], ignore_order=True)\n",
      "        if metadata_diff != {}:\n",
      "            if debug:\n",
      "                print(f\"Metadata mismatch: {metadata_diff}\")\n",
      "            return False\n",
      "\n",
      "        if self.model != assistant_settings['model']:\n",
      "            if debug:\n",
      "                print(f\"Model mismatch: {self.model} != {assistant_settings['model']}\")\n",
      "            return False\n",
      "\n",
      "        response_format_diff = DeepDiff(self.response_format, assistant_settings['response_format'], ignore_order=True)\n",
      "        if response_format_diff != {}:\n",
      "            if debug:\n",
      "                print(f\"Response format mismatch: {response_format_diff}\")\n",
      "            return False\n",
      "\n",
      "        return True\n",
      "\n",
      "    def _save_settings(self):\n",
      "        path = self.get_settings_path()\n",
      "        # check if settings.json exists\n",
      "        if not os.path.isfile(path):\n",
      "            with open(path, 'w') as f:\n",
      "                json.dump([self.assistant.model_dump()], f, indent=4)\n",
      "        else:\n",
      "            settings = []\n",
      "            with open(path, 'r') as f:\n",
      "                settings = json.load(f)\n",
      "                settings.append(self.assistant.model_dump())\n",
      "            with open(path, 'w') as f:\n",
      "                json.dump(settings, f, indent=4)\n",
      "\n",
      "    def _update_settings(self):\n",
      "        path = self.get_settings_path()\n",
      "        # check if settings.json exists\n",
      "        if os.path.isfile(path):\n",
      "            settings = []\n",
      "            with open(path, 'r') as f:\n",
      "                settings = json.load(f)\n",
      "                for i, assistant_settings in enumerate(settings):\n",
      "                    if assistant_settings['id'] == self.id:\n",
      "                        settings[i] = self.assistant.model_dump()\n",
      "                        break\n",
      "            with open(path, 'w') as f:\n",
      "                json.dump(settings, f, indent=4)\n",
      "\n",
      "    # --- Helper Methods ---\n",
      "\n",
      "    def add_file_ids(self, file_ids: List[str], tool_resource: Literal[\"code_interpreter\", \"file_search\"]):\n",
      "        if not file_ids:\n",
      "            return\n",
      "\n",
      "        if self.tool_resources is None:\n",
      "            self.tool_resources = {}\n",
      "\n",
      "        if tool_resource == \"code_interpreter\":\n",
      "            if CodeInterpreter not in self.tools:\n",
      "                raise Exception(\"CodeInterpreter tool not found in tools.\")\n",
      "\n",
      "            if tool_resource not in self.tool_resources or self.tool_resources[\n",
      "                tool_resource] is None:\n",
      "                self.tool_resources[tool_resource] = {\n",
      "                    \"file_ids\": file_ids\n",
      "                }\n",
      "\n",
      "            self.tool_resources[tool_resource]['file_ids'] = file_ids\n",
      "        elif tool_resource == \"file_search\":\n",
      "            if FileSearch not in self.tools:\n",
      "                raise Exception(\"FileSearch tool not found in tools.\")\n",
      "\n",
      "            if tool_resource not in self.tool_resources or self.tool_resources[\n",
      "                tool_resource] is None:\n",
      "                self.tool_resources[tool_resource] = {\n",
      "                    \"vector_stores\": [{\n",
      "                        \"file_ids\": file_ids\n",
      "                    }]\n",
      "                }\n",
      "            elif not self.tool_resources[tool_resource].get('vector_store_ids'):\n",
      "                self.tool_resources[tool_resource]['vector_stores'] = [{\n",
      "                    \"file_ids\": file_ids\n",
      "                }]\n",
      "            else:\n",
      "                vector_store_id = self.tool_resources[tool_resource]['vector_store_ids'][0]\n",
      "                self.client.beta.vector_stores.file_batches.create(\n",
      "                    vector_store_id=vector_store_id,\n",
      "                    file_ids=file_ids\n",
      "                )\n",
      "        else:\n",
      "            raise Exception(\"Invalid tool resource.\")\n",
      "\n",
      "    def get_settings_path(self):\n",
      "        return self.settings_path\n",
      "\n",
      "    def _read_instructions(self):\n",
      "        class_instructions_path = os.path.normpath(os.path.join(self.get_class_folder_path(), self.instructions))\n",
      "        if os.path.isfile(class_instructions_path):\n",
      "            with open(class_instructions_path, 'r') as f:\n",
      "                self.instructions = f.read()\n",
      "        elif os.path.isfile(self.instructions):\n",
      "            with open(self.instructions, 'r') as f:\n",
      "                self.instructions = f.read()\n",
      "        elif \"./instructions.md\" in self.instructions or \"./instructions.txt\" in self.instructions:\n",
      "            raise Exception(\"Instructions file not found.\")\n",
      "\n",
      "    def get_class_folder_path(self):\n",
      "        try:\n",
      "            # First, try to use the __file__ attribute of the module\n",
      "            return os.path.abspath(os.path.dirname(self.__module__.__file__))\n",
      "        except (TypeError, OSError, AttributeError) as e:\n",
      "            # If that fails, fall back to inspect\n",
      "            try:\n",
      "                class_file = inspect.getfile(self.__class__)\n",
      "            except (TypeError, OSError, AttributeError) as e:\n",
      "                return \"./\"\n",
      "            return os.path.abspath(os.path.realpath(os.path.dirname(class_file)))\n",
      "\n",
      "    def add_shared_instructions(self, instructions: str):\n",
      "        if not instructions:\n",
      "            return\n",
      "\n",
      "        if self._shared_instructions is None:\n",
      "            self._shared_instructions = instructions\n",
      "        else:\n",
      "            self.instructions = self.instructions.replace(self._shared_instructions, \"\")\n",
      "            self.instructions = self.instructions.strip().strip(\"\\n\")\n",
      "            self._shared_instructions = instructions\n",
      "\n",
      "        self.instructions = self._shared_instructions + \"\\n\\n\" + self.instructions\n",
      "\n",
      "    # --- Cleanup Methods ---\n",
      "    def delete(self):\n",
      "        \"\"\"Deletes assistant, all vector stores, and all files associated with the agent.\"\"\"\n",
      "        self._delete_assistant()\n",
      "        self._delete_files()\n",
      "        self._delete_settings()\n",
      "\n",
      "    def _delete_files(self):\n",
      "        if not self.tool_resources:\n",
      "            return\n",
      "\n",
      "        file_ids = []\n",
      "        if self.tool_resources.get('code_interpreter'):\n",
      "            file_ids = self.tool_resources['code_interpreter'].get('file_ids', [])\n",
      "\n",
      "        if self.tool_resources.get('file_search'):\n",
      "            file_search_vector_store_ids = self.tool_resources['file_search'].get('vector_store_ids', [])\n",
      "            for vector_store_id in file_search_vector_store_ids:\n",
      "                files = self.client.beta.vector_stores.files.list(vector_store_id=vector_store_id, limit=100)\n",
      "                for file in files:\n",
      "                    file_ids.append(file.id)\n",
      "\n",
      "                self.client.beta.vector_stores.delete(vector_store_id)\n",
      "\n",
      "        for file_id in file_ids:\n",
      "            self.client.files.delete(file_id)\n",
      "\n",
      "    def _delete_assistant(self):\n",
      "        self.client.beta.assistants.delete(self.id)\n",
      "        self._delete_settings()\n",
      "\n",
      "    def _delete_settings(self):\n",
      "        path = self.get_settings_path()\n",
      "        # check if settings.json exists\n",
      "        if os.path.isfile(path):\n",
      "            settings = []\n",
      "            with open(path, 'r') as f:\n",
      "                settings = json.load(f)\n",
      "                for i, assistant_settings in enumerate(settings):\n",
      "                    if assistant_settings['id'] == self.id:\n",
      "                        settings.pop(i)\n",
      "                        break\n",
      "            with open(path, 'w') as f:\n",
      "                json.dump(settings, f, indent=4)\n"
    ],
    "startline": 1,
    "endline": 750
  },
  {
    "path": "agency_swarm/agents/__init__.py",
    "code": [
      "from .agent import Agent\n",
      "from .BrowsingAgent import BrowsingAgent\n",
      "from .Devid import Devid"
    ],
    "startline": 1,
    "endline": 3
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/BrowsingAgent.py",
    "code": [
      "import json\n",
      "import re\n",
      "\n",
      "from agency_swarm.agents import Agent\n",
      "from agency_swarm.tools.oai import FileSearch\n",
      "from typing_extensions import override\n",
      "import base64\n",
      "\n",
      "\n",
      "class BrowsingAgent(Agent):\n",
      "    SCREENSHOT_FILE_NAME = \"screenshot.jpg\"\n",
      "\n",
      "    def __init__(self, selenium_config=None, **kwargs):\n",
      "        from .tools.util.selenium import set_selenium_config\n",
      "        super().__init__(\n",
      "            name=\"BrowsingAgent\",\n",
      "            description=\"This agent is designed to navigate and search web effectively.\",\n",
      "            instructions=\"./instructions.md\",\n",
      "            files_folder=\"./files\",\n",
      "            schemas_folder=\"./schemas\",\n",
      "            tools=[],\n",
      "            tools_folder=\"./tools\",\n",
      "            temperature=0,\n",
      "            max_prompt_tokens=16000,\n",
      "            model=\"gpt-4o\",\n",
      "            validation_attempts=25,\n",
      "            **kwargs\n",
      "        )\n",
      "        if selenium_config is not None:\n",
      "            set_selenium_config(selenium_config)\n",
      "\n",
      "        self.prev_message = \"\"\n",
      "\n",
      "    @override\n",
      "    def response_validator(self, message):\n",
      "        from .tools.util.selenium import get_web_driver, set_web_driver\n",
      "        from .tools.util import highlight_elements_with_labels, remove_highlight_and_labels\n",
      "        from selenium.webdriver.common.by import By\n",
      "        from selenium.webdriver.support.select import Select\n",
      "\n",
      "        # Filter out everything in square brackets\n",
      "        filtered_message = re.sub(r'\\[.*?\\]', '', message).strip()\n",
      "        \n",
      "        if filtered_message and self.prev_message == filtered_message:\n",
      "            raise ValueError(\"Do not repeat yourself. If you are stuck, try a different approach or search in google for the page you are looking for directly.\")\n",
      "        \n",
      "        self.prev_message = filtered_message\n",
      "\n",
      "        if \"[send screenshot]\" in message.lower():\n",
      "            wd = get_web_driver()\n",
      "            remove_highlight_and_labels(wd)\n",
      "            self.take_screenshot()\n",
      "            response_text = \"Here is the screenshot of the current web page:\"\n",
      "\n",
      "        elif '[highlight clickable elements]' in message.lower():\n",
      "            wd = get_web_driver()\n",
      "            highlight_elements_with_labels(wd, 'a, button, div[onclick], div[role=\"button\"], div[tabindex], '\n",
      "                                               'span[onclick], span[role=\"button\"], span[tabindex]')\n",
      "            self._shared_state.set(\"elements_highlighted\", 'a, button, div[onclick], div[role=\"button\"], div[tabindex], '\n",
      "                                               'span[onclick], span[role=\"button\"], span[tabindex]')\n",
      "\n",
      "            self.take_screenshot()\n",
      "\n",
      "            all_elements = wd.find_elements(By.CSS_SELECTOR, '.highlighted-element')\n",
      "\n",
      "            all_element_texts = [element.text for element in all_elements]\n",
      "\n",
      "            element_texts_json = {}\n",
      "            for i, element_text in enumerate(all_element_texts):\n",
      "                element_texts_json[str(i + 1)] = self.remove_unicode(element_text)\n",
      "            \n",
      "            element_texts_json = {k: v for k, v in element_texts_json.items() if v}\n",
      "\n",
      "            element_texts_formatted = \", \".join([f\"{k}: {v}\" for k, v in element_texts_json.items()])\n",
      "\n",
      "            response_text = (\"Here is the screenshot of the current web page with highlighted clickable elements. \\n\\n\"\n",
      "                             \"Texts of the elements are: \" + element_texts_formatted + \".\\n\\n\"\n",
      "                             \"Elements without text are not shown, but are available on screenshot. \\n\"\n",
      "                             \"Please make sure to analyze the screenshot to find the clickable element you need to click on.\")\n",
      "\n",
      "        elif '[highlight text fields]' in message.lower():\n",
      "            wd = get_web_driver()\n",
      "            highlight_elements_with_labels(wd, 'input, textarea')\n",
      "            self._shared_state.set(\"elements_highlighted\", \"input, textarea\")\n",
      "\n",
      "            self.take_screenshot()\n",
      "\n",
      "            all_elements = wd.find_elements(By.CSS_SELECTOR, '.highlighted-element')\n",
      "\n",
      "            all_element_texts = [element.text for element in all_elements]\n",
      "\n",
      "            element_texts_json = {}\n",
      "            for i, element_text in enumerate(all_element_texts):\n",
      "                element_texts_json[str(i + 1)] = self.remove_unicode(element_text)\n",
      "\n",
      "            element_texts_formatted = \", \".join([f\"{k}: {v}\" for k, v in element_texts_json.items()])\n",
      "\n",
      "            response_text = (\"Here is the screenshot of the current web page with highlighted text fields: \\n\"\n",
      "                             \"Texts of the elements are: \" + element_texts_formatted + \".\\n\"\n",
      "                             \"Please make sure to analyze the screenshot to find the text field you need to fill.\")\n",
      "\n",
      "        elif '[highlight dropdowns]' in message.lower():\n",
      "            wd = get_web_driver()\n",
      "            highlight_elements_with_labels(wd, 'select')\n",
      "            self._shared_state.set(\"elements_highlighted\", \"select\")\n",
      "\n",
      "            self.take_screenshot()\n",
      "\n",
      "            all_elements = wd.find_elements(By.CSS_SELECTOR, '.highlighted-element')\n",
      "\n",
      "            all_selector_values = {}\n",
      "\n",
      "            i = 0\n",
      "            for element in all_elements:\n",
      "                select = Select(element)\n",
      "                options = select.options\n",
      "                selector_values = {}\n",
      "                for j, option in enumerate(options):\n",
      "                    selector_values[str(j)] = option.text\n",
      "                    if j > 10:\n",
      "                        break\n",
      "                all_selector_values[str(i + 1)] = selector_values\n",
      "\n",
      "            all_selector_values = {k: v for k, v in all_selector_values.items() if v}\n",
      "            all_selector_values_formatted = \", \".join([f\"{k}: {v}\" for k, v in all_selector_values.items()])\n",
      "\n",
      "            response_text = (\"Here is the screenshot with highlighted dropdowns. \\n\"\n",
      "                             \"Selector values are: \" + all_selector_values_formatted + \".\\n\"\n",
      "                             \"Please make sure to analyze the screenshot to find the dropdown you need to select.\")\n",
      "\n",
      "        else:\n",
      "            return message\n",
      "\n",
      "        set_web_driver(wd)\n",
      "        content = self.create_response_content(response_text)\n",
      "        raise ValueError(content)\n",
      "\n",
      "    def take_screenshot(self):\n",
      "        from .tools.util.selenium import get_web_driver\n",
      "        from .tools.util import get_b64_screenshot\n",
      "        wd = get_web_driver()\n",
      "        screenshot = get_b64_screenshot(wd)\n",
      "        screenshot_data = base64.b64decode(screenshot)\n",
      "        with open(self.SCREENSHOT_FILE_NAME, \"wb\") as screenshot_file:\n",
      "            screenshot_file.write(screenshot_data)\n",
      "\n",
      "    def create_response_content(self, response_text):\n",
      "        with open(self.SCREENSHOT_FILE_NAME, \"rb\") as file:\n",
      "            file_id = self.client.files.create(\n",
      "                file=file,\n",
      "                purpose=\"vision\",\n",
      "            ).id\n",
      "\n",
      "        content = [\n",
      "            {\"type\": \"text\", \"text\": response_text},\n",
      "            {\n",
      "                \"type\": \"image_file\",\n",
      "                \"image_file\": {\"file_id\": file_id}\n",
      "            }\n",
      "        ]\n",
      "        return content\n",
      "\n",
      "    # Function to check for Unicode escape sequences\n",
      "    def remove_unicode(self, data):\n",
      "        return re.sub(r'[^\\x00-\\x7F]+', '', data)\n",
      "\n"
    ],
    "startline": 1,
    "endline": 166
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/__init__.py",
    "code": [
      "from .BrowsingAgent import BrowsingAgent"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/ClickElement.py",
    "code": [
      "import time\n",
      "\n",
      "from pydantic import Field\n",
      "from selenium.webdriver.common.by import By\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util import get_web_driver, set_web_driver\n",
      "from .util.highlights import remove_highlight_and_labels\n",
      "\n",
      "\n",
      "class ClickElement(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool clicks on an element on the current web page based on its number.\n",
      "\n",
      "    Before using this tool make sure to highlight clickable elements on the page by outputting '[highlight clickable elements]' message.\n",
      "    \"\"\"\n",
      "    element_number: int = Field(\n",
      "        ...,\n",
      "        description=\"The number of the element to click on. The element numbers are displayed on the page after highlighting elements.\",\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "\n",
      "        if 'button' not in self._shared_state.get(\"elements_highlighted\", \"\"):\n",
      "            raise ValueError(\"Please highlight clickable elements on the page first by outputting '[highlight clickable elements]' message. You must output just the message without calling the tool first, so the user can respond with the screenshot.\")\n",
      "\n",
      "        all_elements = wd.find_elements(By.CSS_SELECTOR, '.highlighted-element')\n",
      "\n",
      "        # iterate through all elements with a number in the text\n",
      "        try:\n",
      "            element_text = all_elements[self.element_number - 1].text\n",
      "            element_text = element_text.strip() if element_text else \"\"\n",
      "            # Subtract 1 because sequence numbers start at 1, but list indices start at 0\n",
      "            try:\n",
      "                all_elements[self.element_number - 1].click()\n",
      "            except Exception as e:\n",
      "                if \"element click intercepted\" in str(e).lower():\n",
      "                    wd.execute_script(\"arguments[0].click();\", all_elements[self.element_number - 1])\n",
      "                else:\n",
      "                    raise e\n",
      "\n",
      "            time.sleep(3)\n",
      "\n",
      "            result = f\"Clicked on element {self.element_number}. Text on clicked element: '{element_text}'. Current URL is {wd.current_url} To further analyze the page, output '[send screenshot]' command.\"\n",
      "        except IndexError:\n",
      "            result = \"Element number is invalid. Please try again with a valid element number.\"\n",
      "        except Exception as e:\n",
      "            result = str(e)\n",
      "\n",
      "        wd = remove_highlight_and_labels(wd)\n",
      "\n",
      "        wd.execute_script(\"document.body.style.zoom='1.5'\")\n",
      "\n",
      "        set_web_driver(wd)\n",
      "\n",
      "        self._shared_state.set(\"elements_highlighted\", \"\")\n",
      "\n",
      "        return result"
    ],
    "startline": 1,
    "endline": 59
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/ExportFile.py",
    "code": [
      "import base64\n",
      "import os\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util import get_web_driver\n",
      "\n",
      "\n",
      "class ExportFile(BaseTool):\n",
      "    \"\"\"This tool converts the current full web page into a file and returns its file_id. You can then send this file id back to the user for further processing.\"\"\"\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "        from agency_swarm import get_openai_client\n",
      "        client = get_openai_client()\n",
      "\n",
      "        # Define the parameters for the PDF\n",
      "        params = {\n",
      "            'landscape': False,\n",
      "            'displayHeaderFooter': False,\n",
      "            'printBackground': True,\n",
      "            'preferCSSPageSize': True,\n",
      "        }\n",
      "\n",
      "        # Execute the command to print to PDF\n",
      "        result = wd.execute_cdp_cmd('Page.printToPDF', params)\n",
      "        pdf = result['data']\n",
      "\n",
      "        pdf_bytes = base64.b64decode(pdf)\n",
      "\n",
      "        # Save the PDF to a file\n",
      "        with open(\"exported_file.pdf\", \"wb\") as f:\n",
      "            f.write(pdf_bytes)\n",
      "\n",
      "        file_id = client.files.create(file=open(\"exported_file.pdf\", \"rb\"), purpose=\"assistants\",).id\n",
      "\n",
      "        self._shared_state.set(\"file_id\", file_id)\n",
      "\n",
      "        return \"Success. File exported with id: `\" + file_id + \"` You can now send this file id back to the user.\"\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    wd = get_web_driver()\n",
      "    wd.get(\"https://www.google.com\")\n",
      "    tool = ExportFile()\n",
      "    tool.run()\n"
    ],
    "startline": 1,
    "endline": 45
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/GoBack.py",
    "code": [
      "import time\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "\n",
      "from .util.selenium import get_web_driver, set_web_driver\n",
      "\n",
      "\n",
      "class GoBack(BaseTool):\n",
      "    \"\"\"W\n",
      "    This tool allows you to go back 1 page in the browser history. Use it in case of a mistake or if a page shows you unexpected content.\n",
      "    \"\"\"\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "\n",
      "        wd.back()\n",
      "\n",
      "        time.sleep(3)\n",
      "\n",
      "        set_web_driver(wd)\n",
      "\n",
      "        return \"Success. Went back 1 page. Current URL is: \" + wd.current_url\n"
    ],
    "startline": 1,
    "endline": 22
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/ReadURL.py",
    "code": [
      "import time\n",
      "\n",
      "from pydantic import Field\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util.selenium import get_web_driver, set_web_driver\n",
      "\n",
      "\n",
      "class ReadURL(BaseTool):\n",
      "    \"\"\"\n",
      "This tool reads a single URL and opens it in your current browser window. For each new source, either navigate directly to a URL that you believe contains the answer to the user's question or perform a Google search (e.g., 'https://google.com/search?q=search') if necessary. \n",
      "\n",
      "If you are unsure of the direct URL, do not guess. Instead, use the ClickElement tool to click on links that might contain the desired information on the current web page.\n",
      "\n",
      "Note: This tool only supports opening one URL at a time. The previous URL will be closed when you open a new one.\n",
      "    \"\"\"\n",
      "    chain_of_thought: str = Field(\n",
      "        ..., description=\"Think step-by-step about where you need to navigate next to find the necessary information.\",\n",
      "        exclude=True\n",
      "    )\n",
      "    url: str = Field(\n",
      "        ..., description=\"URL of the webpage.\", examples=[\"https://google.com/search?q=search\"]\n",
      "    )\n",
      "\n",
      "    class ToolConfig:\n",
      "        one_call_at_a_time: bool = True\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "\n",
      "        wd.get(self.url)\n",
      "\n",
      "        time.sleep(2)\n",
      "\n",
      "        set_web_driver(wd)\n",
      "\n",
      "        self._shared_state.set(\"elements_highlighted\", \"\")\n",
      "\n",
      "        return \"Current URL is: \" + wd.current_url + \"\\n\" + \"Please output '[send screenshot]' next to analyze the current web page or '[highlight clickable elements]' for further navigation.\"\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    tool = ReadURL(url=\"https://google.com\")\n",
      "    print(tool.run())"
    ],
    "startline": 1,
    "endline": 44
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/Scroll.py",
    "code": [
      "from typing import Literal\n",
      "\n",
      "from pydantic import Field\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util.selenium import get_web_driver, set_web_driver\n",
      "\n",
      "\n",
      "class Scroll(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool allows you to scroll the current web page up or down by 1 screen height.\n",
      "    \"\"\"\n",
      "    direction: Literal[\"up\", \"down\"] = Field(\n",
      "        ..., description=\"Direction to scroll.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "\n",
      "        height = wd.get_window_size()['height']\n",
      "\n",
      "        # Get the zoom level\n",
      "        zoom_level = wd.execute_script(\"return document.body.style.zoom || '1';\")\n",
      "        zoom_level = float(zoom_level.strip('%')) / 100 if '%' in zoom_level else float(zoom_level)\n",
      "\n",
      "        # Adjust height by zoom level\n",
      "        adjusted_height = height / zoom_level\n",
      "\n",
      "        current_scroll_position = wd.execute_script(\"return window.pageYOffset;\")\n",
      "        total_scroll_height = wd.execute_script(\"return document.body.scrollHeight;\")\n",
      "\n",
      "        result = \"\"\n",
      "\n",
      "        if self.direction == \"up\":\n",
      "            if current_scroll_position == 0:\n",
      "                # Reached the top of the page\n",
      "                result = \"Reached the top of the page. Cannot scroll up any further.\\n\"\n",
      "            else:\n",
      "                wd.execute_script(f\"window.scrollBy(0, -{adjusted_height});\")\n",
      "                result = \"Scrolled up by 1 screen height. Make sure to output '[send screenshot]' command to analyze the page after scrolling.\"\n",
      "\n",
      "        elif self.direction == \"down\":\n",
      "            if current_scroll_position + adjusted_height >= total_scroll_height:\n",
      "                # Reached the bottom of the page\n",
      "                result = \"Reached the bottom of the page. Cannot scroll down any further.\\n\"\n",
      "            else:\n",
      "                wd.execute_script(f\"window.scrollBy(0, {adjusted_height});\")\n",
      "                result = \"Scrolled down by 1 screen height. Make sure to output '[send screenshot]' command to analyze the page after scrolling.\"\n",
      "\n",
      "        set_web_driver(wd)\n",
      "\n",
      "        return result\n",
      "\n"
    ],
    "startline": 1,
    "endline": 53
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/SelectDropdown.py",
    "code": [
      "from typing import Dict\n",
      "from pydantic import Field, model_validator\n",
      "from selenium.webdriver.common.by import By\n",
      "from selenium.webdriver.support.select import Select\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util import get_web_driver, set_web_driver\n",
      "from .util.highlights import remove_highlight_and_labels\n",
      "\n",
      "\n",
      "class SelectDropdown(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool selects an option in a dropdown on the current web page based on the description of that element and which option to select.\n",
      "\n",
      "    Before using this tool make sure to highlight dropdown elements on the page by outputting '[highlight dropdowns]' message.\n",
      "    \"\"\"\n",
      "\n",
      "    key_value_pairs: Dict[str, str] = Field(...,\n",
      "        description=\"A dictionary where the key is the sequence number of the dropdown element and the value is the index of the option to select.\",\n",
      "        examples=[{\"1\": 0, \"2\": 1}, {\"3\": 2}]\n",
      "    )\n",
      "\n",
      "    @model_validator(mode='before')\n",
      "    @classmethod\n",
      "    def check_key_value_pairs(cls, data):\n",
      "        if not data.get('key_value_pairs'):\n",
      "            raise ValueError(\n",
      "                \"key_value_pairs is required. Example format: \"\n",
      "                \"key_value_pairs={'1': 0, '2': 1}\"\n",
      "            )\n",
      "        return data\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "\n",
      "        if 'select' not in self._shared_state.get(\"elements_highlighted\", \"\"):\n",
      "            raise ValueError(\"Please highlight dropdown elements on the page first by outputting '[highlight dropdowns]' message. You must output just the message without calling the tool first, so the user can respond with the screenshot.\")\n",
      "\n",
      "        all_elements = wd.find_elements(By.CSS_SELECTOR, '.highlighted-element')\n",
      "\n",
      "        try:\n",
      "            for key, value in self.key_value_pairs.items():\n",
      "                key = int(key)\n",
      "                element = all_elements[key - 1]\n",
      "\n",
      "                select = Select(element)\n",
      "\n",
      "                # Select the first option (index 0)\n",
      "                select.select_by_index(int(value))\n",
      "            result = f\"Success. Option is selected in the dropdown. To further analyze the page, output '[send screenshot]' command.\"\n",
      "        except Exception as e:\n",
      "            result = str(e)\n",
      "\n",
      "        remove_highlight_and_labels(wd)\n",
      "\n",
      "        set_web_driver(wd)\n",
      "\n",
      "        return result\n"
    ],
    "startline": 1,
    "endline": 58
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/SendKeys.py",
    "code": [
      "import time\n",
      "from typing import Dict\n",
      "\n",
      "from pydantic import Field\n",
      "from selenium.webdriver import Keys\n",
      "from selenium.webdriver.common.by import By\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util import get_web_driver, set_web_driver\n",
      "from .util.highlights import remove_highlight_and_labels\n",
      "\n",
      "\n",
      "from pydantic import model_validator\n",
      "\n",
      "class SendKeys(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool sends keys into input fields on the current webpage based on the description of that element and what needs to be typed. It then clicks \"Enter\" on the last element to submit the form. You do not need to tell it to press \"Enter\"; it will do that automatically.\n",
      "\n",
      "    Before using this tool make sure to highlight the input elements on the page by outputting '[highlight text fields]' message.\n",
      "    \"\"\"\n",
      "    elements_and_texts: Dict[int, str] = Field(...,\n",
      "        description=\"A dictionary where the key is the element number and the value is the text to be typed.\",\n",
      "        examples=[\n",
      "            {52: \"johndoe@gmail.com\", 53: \"password123\"},\n",
      "            {3: \"John Doe\", 4: \"123 Main St\"},\n",
      "        ]\n",
      "    )\n",
      "\n",
      "    @model_validator(mode='before')  \n",
      "    @classmethod\n",
      "    def check_elements_and_texts(cls, data):\n",
      "        if not data.get('elements_and_texts'):\n",
      "            raise ValueError(\n",
      "                \"elements_and_texts is required. Example format: \"\n",
      "                \"elements_and_texts={1: 'John Doe', 2: '123 Main St'}\"\n",
      "            )\n",
      "        return data\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "        if 'input' not in self._shared_state.get(\"elements_highlighted\", \"\"):\n",
      "            raise ValueError(\"Please highlight input elements on the page first by outputting '[highlight text fields]' message. You must output just the message without calling the tool first, so the user can respond with the screenshot.\")\n",
      "\n",
      "        all_elements = wd.find_elements(By.CSS_SELECTOR, '.highlighted-element')\n",
      "\n",
      "        i = 0\n",
      "        try:\n",
      "            for key, value in self.elements_and_texts.items():\n",
      "                key = int(key)\n",
      "                element = all_elements[key - 1]\n",
      "\n",
      "                try:\n",
      "                    element.click()\n",
      "                    element.send_keys(Keys.CONTROL + \"a\")  # Select all text in input\n",
      "                    element.send_keys(Keys.DELETE)\n",
      "                    element.clear()\n",
      "                except Exception as e:\n",
      "                    pass\n",
      "                element.send_keys(value)\n",
      "                # send enter key to the last element\n",
      "                if i == len(self.elements_and_texts) - 1:\n",
      "                    element.send_keys(Keys.RETURN)\n",
      "                    time.sleep(3)\n",
      "                i += 1\n",
      "            result = f\"Sent input to element and pressed Enter. Current URL is {wd.current_url} To further analyze the page, output '[send screenshot]' command.\"\n",
      "        except Exception as e:\n",
      "            result = str(e)\n",
      "\n",
      "        remove_highlight_and_labels(wd)\n",
      "\n",
      "        set_web_driver(wd)\n",
      "\n",
      "        return result\n"
    ],
    "startline": 1,
    "endline": 73
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/SolveCaptcha.py",
    "code": [
      "import base64\n",
      "import time\n",
      "\n",
      "from selenium.webdriver.common.by import By\n",
      "from selenium.webdriver.support.expected_conditions import presence_of_element_located, \\\n",
      "    frame_to_be_available_and_switch_to_it\n",
      "from selenium.webdriver.support.wait import WebDriverWait\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util import get_b64_screenshot, remove_highlight_and_labels\n",
      "from .util.selenium import get_web_driver\n",
      "from agency_swarm.util import get_openai_client\n",
      "\n",
      "\n",
      "class SolveCaptcha(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool asks a human to solve captcha on the current webpage. Make sure that captcha is visible before running it.\n",
      "    \"\"\"\n",
      "\n",
      "    def run(self):\n",
      "        wd = get_web_driver()\n",
      "\n",
      "        try:\n",
      "            WebDriverWait(wd, 10).until(\n",
      "                frame_to_be_available_and_switch_to_it((By.XPATH, \"//iframe[@title='reCAPTCHA']\"))\n",
      "            )\n",
      "\n",
      "            element = WebDriverWait(wd, 3).until(\n",
      "                presence_of_element_located((By.ID, \"recaptcha-anchor\"))\n",
      "            )\n",
      "        except Exception as e:\n",
      "            return \"Could not find captcha checkbox\"\n",
      "\n",
      "        try:\n",
      "            # Scroll the element into view\n",
      "            wd.execute_script(\"arguments[0].scrollIntoView(true);\", element)\n",
      "            time.sleep(1)  # Give some time for the scrolling to complete\n",
      "\n",
      "            # Click the element using JavaScript\n",
      "            wd.execute_script(\"arguments[0].click();\", element)\n",
      "        except Exception as e:\n",
      "            return f\"Could not click captcha checkbox: {str(e)}\"\n",
      "\n",
      "        try:\n",
      "            # Now check if the reCAPTCHA is checked\n",
      "            WebDriverWait(wd, 3).until(\n",
      "                lambda d: d.find_element(By.CLASS_NAME, \"recaptcha-checkbox\").get_attribute(\n",
      "                    \"aria-checked\") == \"true\"\n",
      "            )\n",
      "\n",
      "            return \"Success\"\n",
      "        except Exception as e:\n",
      "            pass\n",
      "\n",
      "        wd.switch_to.default_content()\n",
      "\n",
      "        client = get_openai_client()\n",
      "\n",
      "        WebDriverWait(wd, 10).until(\n",
      "            frame_to_be_available_and_switch_to_it(\n",
      "                (By.XPATH, \"//iframe[@title='recaptcha challenge expires in two minutes']\"))\n",
      "        )\n",
      "\n",
      "        time.sleep(2)\n",
      "\n",
      "        attempts = 0\n",
      "        while attempts < 5:\n",
      "            tiles = wd.find_elements(By.CLASS_NAME, \"rc-imageselect-tile\")\n",
      "\n",
      "            # filter out tiles with rc-imageselect-dynamic-selected class\n",
      "            tiles = [tile for tile in tiles if\n",
      "                     not tile.get_attribute(\"class\").endswith(\"rc-imageselect-dynamic-selected\")]\n",
      "\n",
      "            image_content = []\n",
      "            i = 0\n",
      "            for tile in tiles:\n",
      "                i += 1\n",
      "                screenshot = get_b64_screenshot(wd, tile)\n",
      "\n",
      "                image_content.append(\n",
      "                    {\n",
      "                        \"type\": \"text\",\n",
      "                        \"text\": f\"Image {i}:\",\n",
      "                    }\n",
      "                )\n",
      "                image_content.append(\n",
      "                    {\n",
      "                        \"type\": \"image_url\",\n",
      "                        \"image_url\":\n",
      "                            {\n",
      "                                \"url\": f\"data:image/jpeg;base64,{screenshot}\",\n",
      "                                \"detail\": \"high\",\n",
      "                            }\n",
      "                    },\n",
      "                )\n",
      "            # highlight all titles with rc-imageselect-tile class but not with rc-imageselect-dynamic-selected\n",
      "            # wd = highlight_elements_with_labels(wd, 'td.rc-imageselect-tile:not(.rc-imageselect-dynamic-selected)')\n",
      "\n",
      "            # screenshot = get_b64_screenshot(wd, wd.find_element(By.ID, \"rc-imageselect\"))\n",
      "\n",
      "            task_text = wd.find_element(By.CLASS_NAME, \"rc-imageselect-instructions\").text.strip().replace(\"\\n\",\n",
      "                                                                                                           \" \")\n",
      "\n",
      "            continuous_task = 'once there are none left' in task_text.lower()\n",
      "\n",
      "            task_text = task_text.replace(\"Click verify\", \"Output 0\")\n",
      "            task_text = task_text.replace(\"click skip\", \"Output 0\")\n",
      "            task_text = task_text.replace(\"once\", \"if\")\n",
      "            task_text = task_text.replace(\"none left\", \"none\")\n",
      "            task_text = task_text.replace(\"all\", \"only\")\n",
      "            task_text = task_text.replace(\"squares\", \"images\")\n",
      "\n",
      "            additional_info = \"\"\n",
      "            if len(tiles) > 9:\n",
      "                additional_info = (\"Keep in mind that all images are a part of a bigger image \"\n",
      "                                   \"from left to right, and top to bottom. The grid is 4x4. \")\n",
      "\n",
      "            messages = [\n",
      "                {\n",
      "                    \"role\": \"system\",\n",
      "                    \"content\": f\"\"\"You are an advanced AI designed to support users with visual impairments. \n",
      "                    User will provide you with {i} images numbered from 1 to {i}. Your task is to output \n",
      "                    the numbers of the images that contain the requested object, or at least some part of the requested \n",
      "                    object. {additional_info}If there are no individual images that satisfy this condition, output 0.\n",
      "                    \"\"\".replace(\"\\n\", \"\"),\n",
      "                },\n",
      "                {\n",
      "                    \"role\": \"user\",\n",
      "                    \"content\": [\n",
      "                        *image_content,\n",
      "                        {\n",
      "                            \"type\": \"text\",\n",
      "                            \"text\": f\"{task_text}. Only output numbers separated by commas and nothing else. \"\n",
      "                                    f\"Output 0 if there are none.\"\n",
      "                        }\n",
      "                    ]\n",
      "                }]\n",
      "\n",
      "            response = client.chat.completions.create(\n",
      "                model=\"gpt-4o\",\n",
      "                messages=messages,\n",
      "                max_tokens=1024,\n",
      "                temperature=0.0,\n",
      "            )\n",
      "\n",
      "            message = response.choices[0].message\n",
      "            message_text = message.content\n",
      "\n",
      "            # check if 0 is in the message\n",
      "            if \"0\" in message_text and \"10\" not in message_text:\n",
      "                # Find the button by its ID\n",
      "                verify_button = wd.find_element(By.ID, \"recaptcha-verify-button\")\n",
      "\n",
      "                verify_button_text = verify_button.text\n",
      "\n",
      "                # Click the button\n",
      "                wd.execute_script(\"arguments[0].click();\", verify_button)\n",
      "\n",
      "                time.sleep(1)\n",
      "\n",
      "                try:\n",
      "                    if self.verify_checkbox(wd):\n",
      "                        return \"Success. Captcha solved.\"\n",
      "                except Exception as e:\n",
      "                    print('Not checked')\n",
      "                    pass\n",
      "\n",
      "            else:\n",
      "                numbers = [int(s.strip()) for s in message_text.split(\",\") if s.strip().isdigit()]\n",
      "\n",
      "                # Click the tiles based on the provided numbers\n",
      "                for number in numbers:\n",
      "                    wd.execute_script(\"arguments[0].click();\", tiles[number - 1])\n",
      "                    time.sleep(0.5)\n",
      "\n",
      "                time.sleep(3)\n",
      "\n",
      "                if not continuous_task:\n",
      "                    # Find the button by its ID\n",
      "                    verify_button = wd.find_element(By.ID, \"recaptcha-verify-button\")\n",
      "\n",
      "                    verify_button_text = verify_button.text\n",
      "\n",
      "                    # Click the button\n",
      "                    wd.execute_script(\"arguments[0].click();\", verify_button)\n",
      "\n",
      "                    try:\n",
      "                        if self.verify_checkbox(wd):\n",
      "                            return \"Success. Captcha solved.\"\n",
      "                    except Exception as e:\n",
      "                        pass\n",
      "                else:\n",
      "                    continue\n",
      "\n",
      "            if \"verify\" in verify_button_text.lower():\n",
      "                attempts += 1\n",
      "\n",
      "        wd = remove_highlight_and_labels(wd)\n",
      "\n",
      "        wd.switch_to.default_content()\n",
      "\n",
      "        # close captcha\n",
      "        try:\n",
      "            element = WebDriverWait(wd, 3).until(\n",
      "                presence_of_element_located((By.XPATH, \"//iframe[@title='reCAPTCHA']\"))\n",
      "            )\n",
      "\n",
      "            wd.execute_script(f\"document.elementFromPoint({element.location['x']}, {element.location['y']-10}).click();\")\n",
      "        except Exception as e:\n",
      "            print(e)\n",
      "            pass\n",
      "\n",
      "        return \"Could not solve captcha.\"\n",
      "\n",
      "    def verify_checkbox(self, wd):\n",
      "        wd.switch_to.default_content()\n",
      "\n",
      "        try:\n",
      "            WebDriverWait(wd, 10).until(\n",
      "                frame_to_be_available_and_switch_to_it((By.XPATH, \"//iframe[@title='reCAPTCHA']\"))\n",
      "            )\n",
      "\n",
      "            WebDriverWait(wd, 5).until(\n",
      "                lambda d: d.find_element(By.CLASS_NAME, \"recaptcha-checkbox\").get_attribute(\n",
      "                    \"aria-checked\") == \"true\"\n",
      "            )\n",
      "\n",
      "            return True\n",
      "        except Exception as e:\n",
      "            wd.switch_to.default_content()\n",
      "\n",
      "            WebDriverWait(wd, 10).until(\n",
      "                frame_to_be_available_and_switch_to_it(\n",
      "                    (By.XPATH, \"//iframe[@title='recaptcha challenge expires in two minutes']\"))\n",
      "            )\n",
      "\n",
      "        return False\n",
      "\n"
    ],
    "startline": 1,
    "endline": 238
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/WebPageSummarizer.py",
    "code": [
      "from selenium.webdriver.common.by import By\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "from .util import get_web_driver, set_web_driver\n",
      "\n",
      "\n",
      "class WebPageSummarizer(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool summarizes the content of the current web page, extracting the main points and providing a concise summary.\n",
      "    \"\"\"\n",
      "\n",
      "    def run(self):\n",
      "        from agency_swarm import get_openai_client\n",
      "\n",
      "        wd = get_web_driver()\n",
      "        client = get_openai_client()\n",
      "\n",
      "        content = wd.find_element(By.TAG_NAME, \"body\").text\n",
      "\n",
      "        # only use the first 10000 characters\n",
      "        content = \" \".join(content.split()[:10000])\n",
      "\n",
      "        completion = client.chat.completions.create(\n",
      "            model=\"gpt-3.5-turbo\",\n",
      "            messages=[\n",
      "                {\"role\": \"system\", \"content\": \"Your task is to summarize the content of the provided webpage. The summary should be concise and informative, capturing the main points and takeaways of the page.\"},\n",
      "                {\"role\": \"user\", \"content\": \"Summarize the content of the following webpage:\\n\\n\" + content},\n",
      "            ],\n",
      "            temperature=0.0,\n",
      "        )\n",
      "\n",
      "        return completion.choices[0].message.content\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    wd = get_web_driver()\n",
      "    wd.get(\"https://en.wikipedia.org/wiki/Python_(programming_language)\")\n",
      "    set_web_driver(wd)\n",
      "    tool = WebPageSummarizer()\n",
      "    print(tool.run())"
    ],
    "startline": 1,
    "endline": 39
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/__init__.py",
    "code": [
      "from .Scroll import Scroll\n",
      "from .ReadURL import ReadURL\n",
      "from .SendKeys import SendKeys\n",
      "from .ClickElement import ClickElement\n",
      "from .GoBack import GoBack\n",
      "from .SelectDropdown import SelectDropdown\n",
      "from .SolveCaptcha import SolveCaptcha\n",
      "from .ExportFile import ExportFile\n",
      "from .WebPageSummarizer import WebPageSummarizer"
    ],
    "startline": 1,
    "endline": 9
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/util/get_b64_screenshot.py",
    "code": [
      "\n",
      "def get_b64_screenshot(wd, element=None):\n",
      "    if element:\n",
      "        screenshot_b64 = element.screenshot_as_base64\n",
      "    else:\n",
      "        screenshot_b64 = wd.get_screenshot_as_base64()\n",
      "\n",
      "    return screenshot_b64"
    ],
    "startline": 1,
    "endline": 8
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/util/highlights.py",
    "code": [
      "def highlight_elements_with_labels(driver, selector):\n",
      "    \"\"\"\n",
      "    This function highlights clickable elements like buttons, links, and certain divs and spans\n",
      "    that match the given CSS selector on the webpage with a red border and ensures that labels are visible and positioned\n",
      "    correctly within the viewport.\n",
      "\n",
      "    :param driver: Instance of Selenium WebDriver.\n",
      "    :param selector: CSS selector for the elements to be highlighted.\n",
      "    \"\"\"\n",
      "    script = f\"\"\"\n",
      "        // Helper function to check if an element is visible\n",
      "        function isElementVisible(element) {{\n",
      "            var rect = element.getBoundingClientRect();\n",
      "            if (rect.width <= 0 || rect.height <= 0 || \n",
      "                rect.top >= (window.innerHeight || document.documentElement.clientHeight) || \n",
      "                rect.bottom <= 0 || \n",
      "                rect.left >= (window.innerWidth || document.documentElement.clientWidth) || \n",
      "                rect.right <= 0) {{\n",
      "                return false;\n",
      "            }}\n",
      "            // Check if any parent element is hidden, which would hide this element as well\n",
      "            var parent = element;\n",
      "            while (parent) {{\n",
      "                var style = window.getComputedStyle(parent);\n",
      "                if (style.display === 'none' || style.visibility === 'hidden') {{\n",
      "                    return false;\n",
      "                }}\n",
      "                parent = parent.parentElement;\n",
      "            }}\n",
      "            return true;\n",
      "        }}\n",
      "\n",
      "        // Remove previous labels and styles if they exist\n",
      "        document.querySelectorAll('.highlight-label').forEach(function(label) {{\n",
      "            label.remove();\n",
      "        }});\n",
      "        document.querySelectorAll('.highlighted-element').forEach(function(element) {{\n",
      "            element.classList.remove('highlighted-element');\n",
      "            element.removeAttribute('data-highlighted');\n",
      "        }});\n",
      "\n",
      "        // Inject custom style for highlighting elements\n",
      "        var styleElement = document.getElementById('highlight-style');\n",
      "        if (!styleElement) {{\n",
      "            styleElement = document.createElement('style');\n",
      "            styleElement.id = 'highlight-style';\n",
      "            document.head.appendChild(styleElement);\n",
      "        }}\n",
      "        styleElement.textContent = `\n",
      "            .highlighted-element {{ \n",
      "                border: 2px solid red !important; \n",
      "                position: relative; \n",
      "                box-sizing: border-box; \n",
      "            }}\n",
      "            .highlight-label {{ \n",
      "                position: absolute; \n",
      "                z-index: 2147483647; \n",
      "                background: yellow; \n",
      "                color: black; \n",
      "                font-size: 25px; \n",
      "                padding: 3px 5px; \n",
      "                border: 1px solid black; \n",
      "                border-radius: 3px; \n",
      "                white-space: nowrap; \n",
      "                box-shadow: 0px 0px 2px #000; \n",
      "                top: -25px; \n",
      "                left: 0; \n",
      "                display: none;\n",
      "            }}\n",
      "        `;\n",
      "\n",
      "        // Function to create and append a label to the body\n",
      "        function createAndAdjustLabel(element, index) {{\n",
      "            if (!isElementVisible(element)) return;\n",
      "\n",
      "            element.classList.add('highlighted-element');\n",
      "            var label = document.createElement('div');\n",
      "            label.className = 'highlight-label';\n",
      "            label.textContent = index.toString();\n",
      "            label.style.display = 'block'; // Make the label visible\n",
      "\n",
      "            // Calculate label position\n",
      "            var rect = element.getBoundingClientRect();\n",
      "            var top = rect.top + window.scrollY - 25; // Position label above the element\n",
      "            var left = rect.left + window.scrollX;\n",
      "\n",
      "            label.style.top = top + 'px';\n",
      "            label.style.left = left + 'px';\n",
      "\n",
      "            document.body.appendChild(label); // Append the label to the body\n",
      "        }}\n",
      "\n",
      "        // Select all clickable elements and apply the styles\n",
      "        var allElements = document.querySelectorAll('{selector}');\n",
      "        var index = 1;\n",
      "        allElements.forEach(function(element) {{\n",
      "            // Check if the element is not already highlighted and is visible\n",
      "            if (!element.dataset.highlighted && isElementVisible(element)) {{\n",
      "                element.dataset.highlighted = 'true';\n",
      "                createAndAdjustLabel(element, index++);\n",
      "            }}\n",
      "        }});\n",
      "        \"\"\"\n",
      "\n",
      "    driver.execute_script(script)\n",
      "\n",
      "    return driver\n",
      "\n",
      "\n",
      "def remove_highlight_and_labels(driver):\n",
      "    \"\"\"\n",
      "    This function removes all red borders and labels from the webpage elements,\n",
      "    reversing the changes made by the highlight functions using Selenium WebDriver.\n",
      "\n",
      "    :param driver: Instance of Selenium WebDriver.\n",
      "    \"\"\"\n",
      "    selector = ('a, button, input, textarea, div[onclick], div[role=\"button\"], div[tabindex], span[onclick], '\n",
      "                'span[role=\"button\"], span[tabindex]')\n",
      "    script = f\"\"\"\n",
      "        // Remove all labels\n",
      "        document.querySelectorAll('.highlight-label').forEach(function(label) {{\n",
      "            label.remove();\n",
      "        }});\n",
      "\n",
      "        // Remove the added style for red borders\n",
      "        var highlightStyle = document.getElementById('highlight-style');\n",
      "        if (highlightStyle) {{\n",
      "            highlightStyle.remove();\n",
      "        }}\n",
      "\n",
      "        // Remove inline styles added by highlighting function\n",
      "        document.querySelectorAll('{selector}').forEach(function(element) {{\n",
      "            element.style.border = '';\n",
      "        }});\n",
      "        \"\"\"\n",
      "\n",
      "    driver.execute_script(script)\n",
      "\n",
      "    return driver"
    ],
    "startline": 1,
    "endline": 139
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/util/selenium.py",
    "code": [
      "import os\n",
      "\n",
      "wd = None\n",
      "\n",
      "selenium_config = {\n",
      "    \"chrome_profile_path\": None,\n",
      "    \"headless\": True,\n",
      "    \"full_page_screenshot\": True,\n",
      "}\n",
      "\n",
      "\n",
      "def get_web_driver():\n",
      "    print(\"Initializing WebDriver...\")\n",
      "    try:\n",
      "        from selenium import webdriver\n",
      "        from selenium.webdriver.chrome.service import Service as ChromeService\n",
      "        print(\"Selenium imported successfully.\")\n",
      "    except ImportError:\n",
      "        print(\"Selenium not installed. Please install it with pip install selenium\")\n",
      "        raise ImportError\n",
      "\n",
      "    try:\n",
      "        from webdriver_manager.chrome import ChromeDriverManager\n",
      "        print(\"webdriver_manager imported successfully.\")\n",
      "    except ImportError:\n",
      "        print(\"webdriver_manager not installed. Please install it with pip install webdriver-manager\")\n",
      "        raise ImportError\n",
      "\n",
      "    try:\n",
      "        from selenium_stealth import stealth\n",
      "        print(\"selenium_stealth imported successfully.\")\n",
      "    except ImportError:\n",
      "        print(\"selenium_stealth not installed. Please install it with pip install selenium-stealth\")\n",
      "        raise ImportError\n",
      "\n",
      "    global wd, selenium_config\n",
      "\n",
      "    if wd:\n",
      "        print(\"Returning existing WebDriver instance.\")\n",
      "        return wd\n",
      "\n",
      "    chrome_profile_path = selenium_config.get(\"chrome_profile_path\", None)\n",
      "    profile_directory = None\n",
      "    user_data_dir = None\n",
      "    if isinstance(chrome_profile_path, str) and os.path.exists(chrome_profile_path):\n",
      "        profile_directory = os.path.split(chrome_profile_path)[-1].strip(\"\\\\\").rstrip(\"/\")\n",
      "        user_data_dir = os.path.split(chrome_profile_path)[0].strip(\"\\\\\").rstrip(\"/\")\n",
      "        print(f\"Using Chrome profile: {profile_directory}\")\n",
      "        print(f\"Using Chrome user data dir: {user_data_dir}\")\n",
      "        print(f\"Using Chrome profile path: {chrome_profile_path}\")\n",
      "\n",
      "    chrome_options = webdriver.ChromeOptions()\n",
      "    print(\"ChromeOptions initialized.\")\n",
      "\n",
      "    chrome_driver_path = \"/usr/bin/chromedriver\"\n",
      "    if not os.path.exists(chrome_driver_path):\n",
      "        print(\"ChromeDriver not found at /usr/bin/chromedriver. Installing using webdriver_manager.\")\n",
      "        chrome_driver_path = ChromeDriverManager().install()\n",
      "    else:\n",
      "        print(f\"ChromeDriver found at {chrome_driver_path}.\")\n",
      "\n",
      "    if selenium_config.get(\"headless\", False):\n",
      "        chrome_options.add_argument('--headless')\n",
      "        print(\"Headless mode enabled.\")\n",
      "    if selenium_config.get(\"full_page_screenshot\", False):\n",
      "        chrome_options.add_argument(\"--start-maximized\")\n",
      "        print(\"Full page screenshot mode enabled.\")\n",
      "    else:\n",
      "        chrome_options.add_argument(\"--window-size=1920,1080\")\n",
      "        print(\"Window size set to 1920,1080.\")\n",
      "\n",
      "    chrome_options.add_argument(\"--no-sandbox\")\n",
      "    chrome_options.add_argument(\"--disable-gpu\")\n",
      "    chrome_options.add_argument(\"--disable-dev-shm-usage\")\n",
      "    chrome_options.add_argument(\"--remote-debugging-port=9222\")\n",
      "    chrome_options.add_argument(\"--disable-extensions\")\n",
      "    chrome_options.add_argument(\"--disable-popup-blocking\")\n",
      "    chrome_options.add_argument(\"--ignore-certificate-errors\")\n",
      "    chrome_options.add_argument(\"--disable-blink-features=AutomationControlled\")\n",
      "    chrome_options.add_argument(\"--disable-web-security\")\n",
      "    chrome_options.add_argument(\"--allow-running-insecure-content\")\n",
      "    chrome_options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\n",
      "    chrome_options.add_experimental_option(\"useAutomationExtension\", False)\n",
      "    print(\"Chrome options configured.\")\n",
      "\n",
      "    if user_data_dir and profile_directory:\n",
      "        chrome_options.add_argument(f\"user-data-dir={user_data_dir}\")\n",
      "        chrome_options.add_argument(f\"profile-directory={profile_directory}\")\n",
      "        print(f\"Using user data dir: {user_data_dir} and profile directory: {profile_directory}\")\n",
      "\n",
      "    try:\n",
      "        wd = webdriver.Chrome(service=ChromeService(chrome_driver_path), options=chrome_options)\n",
      "        print(\"WebDriver initialized successfully.\")\n",
      "        if wd.capabilities['chrome']['userDataDir']:\n",
      "            print(f\"Profile path in use: {wd.capabilities['chrome']['userDataDir']}\")\n",
      "    except Exception as e:\n",
      "        print(f\"Error initializing WebDriver: {e}\")\n",
      "        raise e\n",
      "\n",
      "    if not selenium_config.get(\"chrome_profile_path\", None):\n",
      "        stealth(\n",
      "            wd,\n",
      "            languages=[\"en-US\", \"en\"],\n",
      "            vendor=\"Google Inc.\",\n",
      "            platform=\"Win32\",\n",
      "            webgl_vendor=\"Intel Inc.\",\n",
      "            renderer=\"Intel Iris OpenGL Engine\",\n",
      "            fix_hairline=True,\n",
      "        )\n",
      "        print(\"Stealth mode configured.\")\n",
      "\n",
      "    wd.implicitly_wait(3)\n",
      "    print(\"Implicit wait set to 3 seconds.\")\n",
      "\n",
      "    return wd\n",
      "\n",
      "\n",
      "def set_web_driver(new_wd):\n",
      "    # remove all popups\n",
      "    js_script = \"\"\"\n",
      "    var popUpSelectors = ['modal', 'popup', 'overlay', 'dialog']; // Add more selectors that are commonly used for pop-ups\n",
      "    popUpSelectors.forEach(function(selector) {\n",
      "        var elements = document.querySelectorAll(selector);\n",
      "        elements.forEach(function(element) {\n",
      "            // You can choose to hide or remove; here we're removing the element\n",
      "            element.parentNode.removeChild(element);\n",
      "        });\n",
      "    });\n",
      "    \"\"\"\n",
      "\n",
      "    new_wd.execute_script(js_script)\n",
      "\n",
      "    # Close LinkedIn specific popups\n",
      "    if \"linkedin.com\" in new_wd.current_url:\n",
      "        linkedin_js_script = \"\"\"\n",
      "        var linkedinSelectors = ['div.msg-overlay-list-bubble', 'div.ml4.msg-overlay-list-bubble__tablet-height'];\n",
      "        linkedinSelectors.forEach(function(selector) {\n",
      "            var elements = document.querySelectorAll(selector);\n",
      "            elements.forEach(function(element) {\n",
      "                element.parentNode.removeChild(element);\n",
      "            });\n",
      "        });\n",
      "        \"\"\"\n",
      "        new_wd.execute_script(linkedin_js_script)\n",
      "\n",
      "    new_wd.execute_script(\"document.body.style.zoom='1.2'\")\n",
      "\n",
      "    global wd\n",
      "    wd = new_wd\n",
      "\n",
      "\n",
      "def set_selenium_config(config):\n",
      "    global selenium_config\n",
      "    selenium_config = config\n"
    ],
    "startline": 1,
    "endline": 154
  },
  {
    "path": "agency_swarm/agents/BrowsingAgent/tools/util/__init__.py",
    "code": [
      "from .get_b64_screenshot import get_b64_screenshot\n",
      "from .selenium import get_web_driver, set_web_driver\n",
      "from .highlights import remove_highlight_and_labels, highlight_elements_with_labels\n"
    ],
    "startline": 1,
    "endline": 3
  },
  {
    "path": "agency_swarm/agents/Devid/Devid.py",
    "code": [
      "from typing_extensions import override\n",
      "import re\n",
      "from agency_swarm.agents import Agent\n",
      "from agency_swarm.tools import FileSearch\n",
      "from agency_swarm.util.validators import llm_validator\n",
      "\n",
      "\n",
      "class Devid(Agent):\n",
      "    def __init__(self):\n",
      "        super().__init__(\n",
      "            name=\"Devid\",\n",
      "            description=\"Devid is an AI software engineer capable of performing advanced coding tasks.\",\n",
      "            instructions=\"./instructions.md\",\n",
      "            files_folder=\"./files\",\n",
      "            schemas_folder=\"./schemas\",\n",
      "            tools=[FileSearch],\n",
      "            tools_folder=\"./tools\",\n",
      "            validation_attempts=1,\n",
      "            temperature=0,\n",
      "            max_prompt_tokens=25000,\n",
      "        )\n",
      "\n",
      "    @override\n",
      "    def response_validator(self, message):\n",
      "        pattern = r'(```)((.*\\n){5,})(```)'\n",
      "\n",
      "        if re.search(pattern, message):\n",
      "            # take only first 100 characters\n",
      "            raise ValueError(\n",
      "                \"You returned code snippet. Please never return code snippets to me. \"\n",
      "                \"Use the FileWriter tool to write the code locally. Then, test it if possible. Continue.\"\n",
      "            )\n",
      "\n",
      "        llm_validator(statement=\"Verify whether the update from the AI Developer Agent confirms the task's \"\n",
      "                                \"successful completion. If the task remains unfinished, provide guidance \"\n",
      "                                \"within the 'reason' argument on the next steps the agent should take. For \"\n",
      "                                \"instance, if the agent encountered an error, advise the inclusion of debug \"\n",
      "                                \"statements for another attempt. Should the agent outline potential \"\n",
      "                                \"solutions or further actions, direct the agent to execute those plans. \"\n",
      "                                \"Message does not have to contain code snippets. Just confirmation.\",\n",
      "                      client=self.client)(message)\n",
      "\n",
      "        return message\n"
    ],
    "startline": 1,
    "endline": 43
  },
  {
    "path": "agency_swarm/agents/Devid/__init__.py",
    "code": [
      "from .Devid import Devid"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/agents/Devid/tools/ChangeFile.py",
    "code": [
      "import os\n",
      "from enum import Enum\n",
      "from typing import Literal, Optional, List\n",
      "\n",
      "from pydantic import Field, model_validator, field_validator, BaseModel\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "\n",
      "class LineChange(BaseModel):\n",
      "    \"\"\"\n",
      "    Line changes to be made.\n",
      "    \"\"\"\n",
      "    line_number: int = Field(\n",
      "        ..., description=\"Line number to change.\",\n",
      "        examples=[1, 2, 3]\n",
      "    )\n",
      "    new_line: Optional[str] = Field(\n",
      "        None, description=\"New line to replace the old line. Not required only for delete mode.\",\n",
      "        examples=[\"This is a new line\"]\n",
      "    )\n",
      "    mode: Literal[\"replace\", \"insert\", \"delete\"] = Field(\n",
      "        \"replace\", description='Mode to use for the line change. \"replace\" replaces the line with the new line. '\n",
      "                               '\"insert\" inserts the new line at the specified line number, moving the previous line down.'\n",
      "                               ' \"delete\" deletes the specified line number.',\n",
      "    )\n",
      "\n",
      "    @model_validator(mode='after')\n",
      "    def validate_new_line(self):\n",
      "        mode, new_line = self.mode, self.new_line\n",
      "        if mode == \"delete\" and new_line is not None:\n",
      "            raise ValueError(\"new_line should not be specified for delete mode.\")\n",
      "        elif mode in [\"replace\", \"insert\"] and new_line is None:\n",
      "            raise ValueError(\"new_line should be specified for replace and insert modes.\")\n",
      "        return self\n",
      "\n",
      "\n",
      "class ChangeFile(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool changes specified lines in a file. Returns the new file contents with line numbers at the start of each line.\n",
      "    \"\"\"\n",
      "    chain_of_thought: str = Field(\n",
      "        ..., description=\"Please think step-by-step about the required changes to the file in order to construct a fully functioning and correct program according to the requirements.\",\n",
      "        exclude=True,\n",
      "    )\n",
      "    file_path: str = Field(\n",
      "        ..., description=\"Path to the file with extension.\",\n",
      "        examples=[\"./file.txt\", \"./file.json\", \"../../file.py\"]\n",
      "    )\n",
      "    changes: List[LineChange] = Field(\n",
      "        ..., description=\"Line changes to be made to the file.\",\n",
      "        examples=[{\"line_number\": 1, \"new_line\": \"This is a new line\", \"mode\": \"replace\"}]\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        # read file\n",
      "        with open(self.file_path, \"r\") as f:\n",
      "            file_contents = f.readlines()\n",
      "\n",
      "            # Process changes in a way that accounts for modifications affecting line numbers\n",
      "            for change in sorted(self.changes, key=lambda x: x.line_number, reverse=True):\n",
      "                try:\n",
      "                    if change.mode == \"replace\" and 0 < change.line_number <= len(file_contents):\n",
      "                        file_contents[change.line_number - 1] = change.new_line + '\\n'\n",
      "                    elif change.mode == \"insert\":\n",
      "                        file_contents.insert(change.line_number - 1, change.new_line + '\\n')\n",
      "                    elif change.mode == \"delete\" and 0 < change.line_number <= len(file_contents):\n",
      "                        file_contents.pop(change.line_number - 1)\n",
      "                except IndexError:\n",
      "                    return f\"Error: Line number {change.line_number} is out of the file's range.\"\n",
      "\n",
      "        # write file\n",
      "        with open(self.file_path, \"w\") as f:\n",
      "            f.writelines(file_contents)\n",
      "\n",
      "        with open(self.file_path, \"r\") as f:\n",
      "            file_contents = f.readlines()\n",
      "\n",
      "        # return file contents with line numbers\n",
      "        return \"\\n\".join([f\"{i + 1}. {line}\" for i, line in enumerate(file_contents)])\n",
      "\n",
      "    # use field validation to ensure that the file path is valid\n",
      "    @field_validator(\"file_path\", mode='after')\n",
      "    @classmethod\n",
      "    def validate_file_path(cls, v: str):\n",
      "        if not os.path.exists(v):\n",
      "            raise ValueError(\"File path does not exist.\")\n",
      "\n",
      "        return v"
    ],
    "startline": 1,
    "endline": 88
  },
  {
    "path": "agency_swarm/agents/Devid/tools/CheckCurrentDir.py",
    "code": [
      "from pydantic import Field\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "\n",
      "\n",
      "class CheckCurrentDir(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool checks the current directory path.\n",
      "    \"\"\"\n",
      "    chain_of_thought: str = Field(\n",
      "        ...,\n",
      "        description=\"Please think step-by-step about what you need to do next, after checking current directory to solve the task.\",\n",
      "        exclude=True,\n",
      "    )\n",
      "\n",
      "    class ToolConfig:\n",
      "        one_call_at_a_time: bool = True\n",
      "\n",
      "    def run(self):\n",
      "        import os\n",
      "\n",
      "        return os.getcwd()\n"
    ],
    "startline": 1,
    "endline": 22
  },
  {
    "path": "agency_swarm/agents/Devid/tools/CommandExecutor.py",
    "code": [
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field\n",
      "import subprocess\n",
      "import shlex\n",
      "from dotenv import load_dotenv, find_dotenv\n",
      "\n",
      "class CommandExecutor(BaseTool):\n",
      "    \"\"\"\n",
      "    Executes a specified command in the terminal and captures the output.\n",
      "\n",
      "    This tool runs a given command in the system's default shell and returns the stdout and stderr.\n",
      "    \"\"\"\n",
      "\n",
      "    command: str = Field(\n",
      "        ..., description=\"The command to execute in the terminal.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        \"\"\"\n",
      "        Executes the command and captures its output.\n",
      "\n",
      "        Returns:\n",
      "            A dictionary containing the standard output (stdout), standard error (stderr),\n",
      "            and the exit code of the command.\n",
      "        \"\"\"\n",
      "        load_dotenv(find_dotenv() or None)\n",
      "        # Ensure the command is safely split for subprocess\n",
      "        command_parts = shlex.split(self.command)\n",
      "\n",
      "        # Execute the command and capture the output\n",
      "        result = subprocess.run(command_parts, capture_output=True, text=True)\n",
      "\n",
      "        # check if the command failed\n",
      "        if result.returncode != 0 or result.stderr:\n",
      "            return (f\"stdout: {result.stdout}\\nstderr: {result.stderr}\\nexit code: {result.returncode}\\n\\n\"\n",
      "                    f\"Please add error handling and continue debugging until the command runs successfully.\")\n",
      "\n",
      "        return f\"stdout: {result.stdout}\\nstderr: {result.stderr}\\nexit code: {result.returncode}\"\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    tool = CommandExecutor(command=\"ls -l\")\n",
      "    print(tool.run())\n"
    ],
    "startline": 1,
    "endline": 42
  },
  {
    "path": "agency_swarm/agents/Devid/tools/DirectoryNavigator.py",
    "code": [
      "import os\n",
      "from pydantic import Field, model_validator, field_validator\n",
      "\n",
      "from agency_swarm.tools import BaseTool\n",
      "\n",
      "\n",
      "class DirectoryNavigator(BaseTool):\n",
      "    \"\"\"Allows you to navigate directories. Do not use this tool more than once at a time.\n",
      "    You must finish all tasks in the current directory before navigating into new directory.\"\"\"\n",
      "    path: str = Field(\n",
      "        ..., description=\"The path of the directory to navigate to.\"\n",
      "    )\n",
      "    create: bool = Field(\n",
      "        False, description=\"If True, the directory will be created if it does not exist.\"\n",
      "    )\n",
      "\n",
      "    class ToolConfig:\n",
      "        one_call_at_a_time: bool = True\n",
      "\n",
      "    def run(self):\n",
      "        try:\n",
      "            os.chdir(self.path)\n",
      "            return f'Successfully changed directory to: {self.path}'\n",
      "        except Exception as e:\n",
      "            return f'Error changing directory: {e}'\n",
      "\n",
      "    @field_validator(\"create\", mode=\"before\")\n",
      "    @classmethod\n",
      "    def validate_create(cls, v):\n",
      "        if not isinstance(v, bool):\n",
      "            if v.lower() == \"true\":\n",
      "                return True\n",
      "            elif v.lower() == \"false\":\n",
      "                return False\n",
      "        return v\n",
      "\n",
      "    @model_validator(mode='after')\n",
      "    def validate_path(self):\n",
      "        if not os.path.isdir(self.path):\n",
      "            if \"/mnt/data\" in self.path:\n",
      "                raise ValueError(\"You tried to access an openai file directory with a local directory reader tool. \" +\n",
      "                                 \"Please use the `myfiles_browser` tool to access openai files instead. \" +\n",
      "                                 \"Your local files are most likely located in your current directory.\")\n",
      "\n",
      "            if self.create:\n",
      "                os.makedirs(self.path)\n",
      "            else:\n",
      "                raise ValueError(f\"The path {self.path} does not exist. Please provide a valid directory path. \" +\n",
      "                                 \"If you want to create the directory, set the `create` parameter to True.\")\n",
      "\n",
      "        return self\n"
    ],
    "startline": 1,
    "endline": 51
  },
  {
    "path": "agency_swarm/agents/Devid/tools/FileMover.py",
    "code": [
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field\n",
      "import shutil\n",
      "import os\n",
      "\n",
      "class FileMover(BaseTool):\n",
      "    \"\"\"\n",
      "    FileMover is a tool designed to move files from a source path to a destination path. If the destination directory does not exist, it will be created.\n",
      "    \"\"\"\n",
      "\n",
      "    source_path: str = Field(\n",
      "        ..., description=\"The full path of the file to move, including the file name and extension.\"\n",
      "    )\n",
      "    destination_path: str = Field(\n",
      "        ..., description=\"The destination path where the file should be moved, including the new file name and extension if changing.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        \"\"\"\n",
      "        Executes the file moving operation from the source path to the destination path.\n",
      "        It checks if the destination directory exists and creates it if necessary, then moves the file.\n",
      "        \"\"\"\n",
      "        if not os.path.exists(self.source_path):\n",
      "            return f\"Source file does not exist at {self.source_path}\"\n",
      "\n",
      "        # Ensure the destination directory exists\n",
      "        destination_dir = os.path.dirname(self.destination_path)\n",
      "        if not os.path.exists(destination_dir):\n",
      "            os.makedirs(destination_dir)\n",
      "\n",
      "        # Move the file\n",
      "        shutil.move(self.source_path, self.destination_path)\n",
      "\n",
      "        return f\"File moved successfully from {self.source_path} to {self.destination_path}\"\n"
    ],
    "startline": 1,
    "endline": 34
  },
  {
    "path": "agency_swarm/agents/Devid/tools/FileReader.py",
    "code": [
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field, field_validator\n",
      "\n",
      "\n",
      "class FileReader(BaseTool):\n",
      "    \"\"\"This tool reads a file and returns the contents along with line numbers on the left.\"\"\"\n",
      "    file_path: str = Field(\n",
      "        ..., description=\"Path to the file to read with extension.\",\n",
      "        examples=[\"./file.txt\", \"./file.json\", \"../../file.py\"]\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        # read file\n",
      "        with open(self.file_path, \"r\") as f:\n",
      "            file_contents = f.readlines()\n",
      "\n",
      "        # return file contents\n",
      "        return \"\\n\".join([f\"{i + 1}. {line}\" for i, line in enumerate(file_contents)])\n",
      "\n",
      "    @field_validator(\"file_path\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_file_path(cls, v):\n",
      "        if \"file-\" in v:\n",
      "            raise ValueError(\"You tried to access an openai file with a wrong file reader tool. \"\n",
      "                             \"Please use the `myfiles_browser` tool to access openai files instead.\"\n",
      "                             \"This tool is only for reading local files.\")\n",
      "        return v\n"
    ],
    "startline": 1,
    "endline": 27
  },
  {
    "path": "agency_swarm/agents/Devid/tools/FileWriter.py",
    "code": [
      "from typing import List, Literal, Optional\n",
      "\n",
      "import json\n",
      "\n",
      "import os\n",
      "from agency_swarm.util.validators import llm_validator\n",
      "\n",
      "from agency_swarm import get_openai_client\n",
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field, field_validator\n",
      "import re\n",
      "\n",
      "from .util import format_file_deps\n",
      "\n",
      "history = [\n",
      "            {\n",
      "                \"role\": \"system\",\n",
      "                \"content\": \"As a top-tier software engineer focused on developing programs incrementally, you are entrusted with the creation or modification of files based on user requirements. It's imperative to operate under the assumption that all necessary dependencies are pre-installed and accessible, and the file in question will be deployed in an appropriate environment. Furthermore, it is presumed that all other modules or files upon which this file relies are accurate and error-free. Your output should be encapsulated within a code block, without specifying the programming language. Prior to embarking on the coding process, you must outline a methodical, step-by-step plan to precisely fulfill the requirements \u2014 no more, no less. It is crucial to ensure that the final code block is a complete file, without any truncation. This file should embody a flawless, fully operational program, inclusive of all requisite imports and functions, devoid of any placeholders, unless specified otherwise by the user.\"\n",
      "            },\n",
      "        ]\n",
      "\n",
      "\n",
      "class FileWriter(BaseTool):\n",
      "    \"\"\"This tools allows you to write new files or modify existing files according to specified requirements. In 'write' mode, it creates a new file or overwrites an existing one. In 'modify' mode, it modifies an existing file according to the provided requirements.\n",
      "    Note: This tool does not have access to other files within the project. You must provide all necessary details to ensure that the generated file can be used in conjunction with other files in this project.\"\"\"\n",
      "    file_path: str = Field(\n",
      "        ..., description=\"The path of the file to write or modify. Will create directories if they don't exist.\"\n",
      "    )\n",
      "    requirements: str = Field(\n",
      "        ...,\n",
      "        description=\"The comprehensive requirements explaining how the file should be written or modified. This should be a detailed description of what the file should contain, including example inputs, desired behaviour and ideal outputs. It must not contain any code or implementation details.\"\n",
      "    )\n",
      "    details: str = Field(\n",
      "        None, description=\"Additional details like error messages, or class, function, and variable names from other files that this file depends on.\"\n",
      "    )\n",
      "    documentation: Optional[str] = Field(\n",
      "        None, description=\"Relevant documentation extracted with the myfiles_browser tool. You must pass all the relevant code from the documentation, as this tool does not have access to those files.\"\n",
      "    )\n",
      "    mode: Literal[\"write\", \"modify\"] = Field(\n",
      "        ..., description=\"The mode of operation for the tool. 'write' is used to create a new file or overwrite an existing one. 'modify' is used to modify an existing file.\"\n",
      "    )\n",
      "    file_dependencies: List[str] = Field(\n",
      "        [],\n",
      "        description=\"Paths to other files that the file being written depends on.\",\n",
      "        examples=[\"/path/to/dependency1.py\", \"/path/to/dependency2.css\", \"/path/to/dependency3.js\"]\n",
      "        )\n",
      "    library_dependencies: List[str] = Field(\n",
      "        [],\n",
      "        description=\"Any library dependencies required for the file to be written.\",\n",
      "        examples=[\"numpy\", \"pandas\"]\n",
      "    )\n",
      "    \n",
      "    class ToolConfig:\n",
      "        one_call_at_a_time = True\n",
      "\n",
      "    def run(self):\n",
      "        client = get_openai_client()\n",
      "\n",
      "        file_dependencies = format_file_deps(self.file_dependencies)\n",
      "\n",
      "        library_dependencies = \", \".join(self.library_dependencies)\n",
      "\n",
      "        filename = os.path.basename(self.file_path)\n",
      "\n",
      "        if self.mode == \"write\":\n",
      "            message = f\"Please write {filename} file that meets the following requirements: '{self.requirements}'.\\n\"\n",
      "        else:\n",
      "            message = f\"Please rewrite the {filename} file according to the following requirements: '{self.requirements}'.\\n\"\n",
      "\n",
      "        if file_dependencies:\n",
      "            message += f\"\\nHere are the dependencies from other project files: {file_dependencies}.\"\n",
      "        if library_dependencies:\n",
      "            message += f\"\\nUse the following libraries: {library_dependencies}\"\n",
      "        if self.details:\n",
      "            message += f\"\\nAdditional Details: {self.details}\"\n",
      "        if self.documentation:\n",
      "            message += f\"\\nDocumentation: {self.documentation}\"\n",
      "\n",
      "        if self.mode == \"modify\":\n",
      "            message += f\"\\nThe existing file content is as follows:\"\n",
      "\n",
      "            try:\n",
      "                with open(self.file_path, 'r') as file:\n",
      "                    prev_content = file.read()\n",
      "                    message += f\"\\n\\n```{prev_content}```\"\n",
      "            except Exception as e:\n",
      "                return f'Error reading {self.file_path}: {e}'\n",
      "\n",
      "        history.append({\n",
      "                \"role\": \"user\",\n",
      "                \"content\": message\n",
      "            })\n",
      "\n",
      "        messages = history.copy()\n",
      "\n",
      "        # use the last 5 messages\n",
      "        messages = messages[-5:]\n",
      "\n",
      "        # add system message upfront\n",
      "        messages.insert(0, history[0])\n",
      "\n",
      "        n = 0\n",
      "        error_message = \"\"\n",
      "        while n < 3:\n",
      "            resp = client.chat.completions.create(\n",
      "                messages=messages,\n",
      "                model=\"gpt-4o\",\n",
      "                temperature=0,\n",
      "            )\n",
      "\n",
      "            content = resp.choices[0].message.content\n",
      "\n",
      "            messages.append(\n",
      "                {\n",
      "                    \"role\": \"assistant\",\n",
      "                    \"content\": content\n",
      "                }\n",
      "            )\n",
      "\n",
      "            pattern = r\"```(?:[a-zA-Z]+\\n)?(.*?)```\"\n",
      "            match = re.findall(pattern, content, re.DOTALL)\n",
      "            if match:\n",
      "                code = match[-1].strip()\n",
      "                try:\n",
      "                    self.validate_content(code)\n",
      "\n",
      "                    history.append(\n",
      "                        {\n",
      "                            \"role\": \"assistant\",\n",
      "                            \"content\": content\n",
      "                        }\n",
      "                    )\n",
      "\n",
      "                    break\n",
      "                except Exception as e:\n",
      "                    print(f\"Error: {e}. Trying again.\")\n",
      "                    error_message = str(e)\n",
      "                    messages.append(\n",
      "                        {\n",
      "                            \"role\": \"user\",\n",
      "                            \"content\": f\"Error: {e}. Please try again.\"\n",
      "                        }\n",
      "                    )\n",
      "            else:\n",
      "                messages.append(\n",
      "                    {\n",
      "                        \"role\": \"user\",\n",
      "                        \"content\": f\"Error: Could not find the code block in the response. Please try again.\"\n",
      "                    }\n",
      "                )\n",
      "\n",
      "            n += 1\n",
      "\n",
      "        if n == 3 or not code:\n",
      "            history.append(\n",
      "                {\n",
      "                    \"role\": \"assistant\",\n",
      "                    \"content\": content\n",
      "                }\n",
      "            )\n",
      "            history.append(\n",
      "                {\n",
      "                    \"role\": \"user\",\n",
      "                    \"content\": error_message\n",
      "                }\n",
      "            )\n",
      "            return \"Error: Could not generate a valid file: \" + error_message\n",
      "\n",
      "        try:\n",
      "            # create directories if they don't exist\n",
      "            dir_path = os.path.dirname(self.file_path)\n",
      "            if dir_path != \"\" and not os.path.exists(dir_path):\n",
      "                os.makedirs(dir_path, exist_ok=True)\n",
      "\n",
      "            with open(self.file_path, 'w') as file:\n",
      "                file.write(code)\n",
      "            return f'Successfully wrote to file: {self.file_path}. Please make sure to now test the program. Below is the content of the file:\\n\\n```{content}```\\n\\nPlease now verify the integrity of the file and test it.'\n",
      "        except Exception as e:\n",
      "            return f'Error writing to file: {e}'\n",
      "\n",
      "    @field_validator(\"file_dependencies\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_file_dependencies(cls, v):\n",
      "        for file in v:\n",
      "            if not os.path.exists(file):\n",
      "                raise ValueError(f\"File dependency '{file}' does not exist.\")\n",
      "        return v\n",
      "\n",
      "    def validate_content(self, v):\n",
      "        client = get_openai_client()\n",
      "\n",
      "        llm_validator(\n",
      "            statement=\"Check if the code is bug-free. Code should be considered in isolation, with the understanding that it is part of a larger, fully developed program that strictly adheres to these standards of completeness and correctness. All files, elements, components, functions, or modules referenced within this snippet are assumed to exist in other parts of the project and are also devoid of any errors, ensuring a cohesive and error-free integration across the entire software solution. Certain placeholders may be present.\",\n",
      "                      client=client,\n",
      "                      model=\"gpt-4o\",\n",
      "                      temperature=0,\n",
      "                      allow_override=False\n",
      "                      )(v)\n",
      "\n",
      "        return v\n",
      "\n",
      "    @field_validator(\"requirements\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_requirements(cls, v):\n",
      "        if \"placeholder\" in v:\n",
      "            raise ValueError(\"Requirements contain placeholders. \"\n",
      "                             \"Please never user placeholders. Instead, implement only the code that you are confident about.\")\n",
      "\n",
      "        # check if code is included in requirements\n",
      "        pattern = r'(```)((.*\\n){5,})(```)'\n",
      "        if re.search(pattern, v):\n",
      "            raise ValueError(\n",
      "                \"Requirements contain a code snippet. Please never include code snippets in requirements. \"\n",
      "                \"Requirements must be a description of the complete file to be written. You can include specific class, function, and variable names, but not the actual code.\"\n",
      "            )\n",
      "\n",
      "        return v\n",
      "\n",
      "    @field_validator(\"details\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_details(cls, v):\n",
      "        if len(v) == 0:\n",
      "            raise ValueError(\"Details are required. Remember: this tool does not have access to other files. Please provide additional details like relevant documentation, error messages, or class, function, and variable names from other files that this file depends on.\")\n",
      "        return v\n",
      "\n",
      "    @field_validator(\"documentation\", mode=\"after\")\n",
      "    @classmethod\n",
      "    def validate_documentation(cls, v):\n",
      "        # check if documentation contains code\n",
      "        pattern = r'(```)((.*\\n){5,})(```)'\n",
      "        pattern2 = r'(`)(.*)(`)'\n",
      "        if not (re.search(pattern, v) or re.search(pattern2, v)):\n",
      "            raise ValueError(\n",
      "                \"Documentation does not contain a code snippet. Please provide relevant documentation extracted with the myfiles_browser tool. You must pass all the relevant code snippets information, as this tool does not have access to those files.\"\n",
      "            )\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    tool = FileWriter(\n",
      "        requirements=\"Write a program that takes a list of integers as input and returns the sum of all the integers in the list.\",\n",
      "        mode=\"write\",\n",
      "        file_path=\"test.py\",\n",
      "    )\n",
      "    print(tool.run())\n"
    ],
    "startline": 1,
    "endline": 244
  },
  {
    "path": "agency_swarm/agents/Devid/tools/ListDir.py",
    "code": [
      "from pydantic import Field, field_validator\n",
      "\n",
      "from agency_swarm import BaseTool\n",
      "import os\n",
      "\n",
      "\n",
      "class ListDir(BaseTool):\n",
      "    \"\"\"\n",
      "    This tool returns the tree structure of the directory.\n",
      "    \"\"\"\n",
      "    dir_path: str = Field(\n",
      "        ..., description=\"Path of the directory to read.\",\n",
      "        examples=[\"./\", \"./test\", \"../../\"]\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        tree = []\n",
      "\n",
      "        def list_directory_tree(path, indent=''):\n",
      "            \"\"\"Recursively list the contents of a directory in a tree-like format.\"\"\"\n",
      "            if not os.path.isdir(path):\n",
      "                raise ValueError(f\"The path {path} is not a valid directory\")\n",
      "\n",
      "            items = os.listdir(path)\n",
      "            # exclude common hidden files and directories\n",
      "            exclude = ['.git', '.idea', '__pycache__', 'node_modules', '.venv', '.gitignore', '.gitkeep',\n",
      "                       '.DS_Store', '.vscode', '.next', 'dist', 'build', 'out', 'venv', 'env', 'logs', 'data']\n",
      "\n",
      "            items = [item for item in items if item not in exclude]\n",
      "\n",
      "            for i, item in enumerate(items):\n",
      "                item_path = os.path.join(path, item)\n",
      "                if i < len(items) - 1:\n",
      "                    tree.append(indent + '\u251c\u2500\u2500 ' + item)\n",
      "                    if os.path.isdir(item_path):\n",
      "                        list_directory_tree(item_path, indent + '\u2502   ')\n",
      "                else:\n",
      "                    tree.append(indent + '\u2514\u2500\u2500 ' + item)\n",
      "                    if os.path.isdir(item_path):\n",
      "                        list_directory_tree(item_path, indent + '    ')\n",
      "\n",
      "        list_directory_tree(self.dir_path)\n",
      "\n",
      "        return \"\\n\".join(tree)\n",
      "\n",
      "    @field_validator(\"dir_path\", mode='after')\n",
      "    @classmethod\n",
      "    def validate_dir_path(cls, v):\n",
      "        if \"file-\" in v:\n",
      "            raise ValueError(\"You tried to access an openai file with a local directory reader tool. \"\n",
      "                             \"Please use the `myfiles_browser` tool to access openai directories instead.\")\n",
      "\n",
      "        if not os.path.isdir(v):\n",
      "            if \"/mnt/data\" in v:\n",
      "                raise ValueError(\"You tried to access an openai file directory with a local directory reader tool. \"\n",
      "                                 \"Please use the `myfiles_browser` tool to access openai files instead. \"\n",
      "                                 \"You can work in your local directory by using the `FileReader` tool.\")\n",
      "\n",
      "            raise ValueError(f\"The path {v} is not a valid directory\")\n",
      "        return v\n"
    ],
    "startline": 1,
    "endline": 60
  },
  {
    "path": "agency_swarm/agents/Devid/tools/__init__.py",
    "code": [],
    "startline": 1,
    "endline": 0
  },
  {
    "path": "agency_swarm/agents/Devid/tools/util/format_file_deps.py",
    "code": [
      "from pydantic import Field, BaseModel\n",
      "from typing import List, Literal\n",
      "\n",
      "from agency_swarm import get_openai_client\n",
      "\n",
      "\n",
      "def format_file_deps(v):\n",
      "    client = get_openai_client()\n",
      "    result = ''\n",
      "    for file in v:\n",
      "        # extract dependencies from the file using openai\n",
      "        with open(file, 'r') as f:\n",
      "            content = f.read()\n",
      "\n",
      "        class Dependency(BaseModel):\n",
      "            type: Literal['class', 'function', 'import'] = Field(..., description=\"The type of the dependency.\")\n",
      "            name: str = Field(..., description=\"The name of the dependency, matching the import or definition.\")\n",
      "\n",
      "        class Dependencies(BaseModel):\n",
      "            dependencies: List[Dependency] = Field([], description=\"The dependencies extracted from the file.\")\n",
      "\n",
      "            def append_dependencies(self):\n",
      "                functions = [dep.name for dep in self.dependencies if dep.type == 'function']\n",
      "                classes = [dep.name for dep in self.dependencies if dep.type == 'class']\n",
      "                imports = [dep.name for dep in self.dependencies if dep.type == 'import']\n",
      "                variables = [dep.name for dep in self.dependencies if dep.type == 'variable']\n",
      "                nonlocal result\n",
      "                result += f\"File path: {file}\\n\"\n",
      "                result += f\"Functions: {functions}\\nClasses: {classes}\\nImports: {imports}\\nVariables: {variables}\\n\\n\"\n",
      "\n",
      "        completion = client.beta.chat.completions.parse(\n",
      "            messages=[\n",
      "                {\n",
      "                    \"role\": \"system\",\n",
      "                    \"content\": \"You are a world class dependency resolved. You must extract the dependencies from the file provided.\"\n",
      "                },\n",
      "                {\n",
      "                    \"role\": \"user\",\n",
      "                    \"content\": f\"Extract the dependencies from the file '{file}'.\"\n",
      "                }\n",
      "            ],\n",
      "            model=\"gpt-4o-mini\",\n",
      "            temperature=0,\n",
      "            response_format=Dependencies\n",
      "        )\n",
      "\n",
      "        if completion.choices[0].message.refusal:\n",
      "            raise ValueError(completion.choices[0].message.refusal)\n",
      "\n",
      "        model = completion.choices[0].message.parsed\n",
      "\n",
      "        model.append_dependencies()\n",
      "\n",
      "    return result"
    ],
    "startline": 1,
    "endline": 54
  },
  {
    "path": "agency_swarm/agents/Devid/tools/util/__init__.py",
    "code": [
      "from .format_file_deps import format_file_deps"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/messages/message_output.py",
    "code": [
      "from typing import Literal\n",
      "import hashlib\n",
      "from rich.markdown import Markdown\n",
      "from rich.console import Console, Group\n",
      "from rich.live import Live\n",
      "\n",
      "console = Console()\n",
      "\n",
      "class MessageOutput:\n",
      "    def __init__(self, msg_type: Literal[\"function\", \"function_output\", \"text\", \"system\"], sender_name: str,\n",
      "                 receiver_name: str, content, obj=None):\n",
      "        \"\"\"Initialize a message object with sender, receiver, content and type.\n",
      "\n",
      "        Args:\n",
      "            msg_type (Literal[\"function\", \"function_output\", \"text\", \"system\"]): Type of message.\n",
      "            sender_name (str): Name of the sender.\n",
      "            receiver_name (str): Name of the receiver.\n",
      "            content: Content of the message.\n",
      "            obj: Optional OpenAI object that is causing the message.\n",
      "        \"\"\"\n",
      "        self.msg_type = msg_type\n",
      "        self.sender_name = str(sender_name)\n",
      "        self.receiver_name = str(receiver_name)\n",
      "        self.content = str(content)\n",
      "        self.obj = obj\n",
      "\n",
      "    def hash_names_to_color(self):\n",
      "        if self.msg_type == \"function\" or self.msg_type == \"function_output\":\n",
      "            return \"dim\"\n",
      "\n",
      "        if self.msg_type == \"system\":\n",
      "            return \"red\"\n",
      "\n",
      "        combined_str = self.sender_name + self.receiver_name\n",
      "        encoded_str = combined_str.encode()\n",
      "        hash_obj = hashlib.md5(encoded_str)\n",
      "        hash_int = int(hash_obj.hexdigest(), 16)\n",
      "        colors = [\n",
      "            'green', 'yellow', 'blue', 'magenta', 'cyan', 'bright_white',\n",
      "        ]\n",
      "        color_index = hash_int % len(colors)\n",
      "        return colors[color_index]\n",
      "\n",
      "    def cprint(self):\n",
      "        console.rule()\n",
      "\n",
      "        header_text = self.formatted_header\n",
      "        md_content = Markdown(self.content)\n",
      "\n",
      "        render_group = Group(header_text, md_content)\n",
      "\n",
      "        console.print(render_group, end=\"\")\n",
      "\n",
      "    @property\n",
      "    def formatted_header(self):\n",
      "        return self.get_formatted_header()\n",
      "\n",
      "    def get_formatted_header(self):\n",
      "        if self.msg_type == \"function\":\n",
      "            text = f\"{self.sender_emoji} {self.sender_name} \ud83d\udee0\ufe0f Executing Function\"\n",
      "            return text\n",
      "\n",
      "        if self.msg_type == \"function_output\":\n",
      "            text = f\"{self.sender_name} \u2699\ufe0f Function Output\"\n",
      "            return text\n",
      "\n",
      "        text = f\"{self.sender_emoji} {self.sender_name} \ud83d\udde3\ufe0f @{self.receiver_name}\"\n",
      "\n",
      "        return text\n",
      "\n",
      "    def get_formatted_content(self):\n",
      "        header = self.get_formatted_header()\n",
      "        content = f\"\\n{self.content}\\n\"\n",
      "        return header + content\n",
      "\n",
      "    @property\n",
      "    def sender_emoji(self):\n",
      "        return self.get_sender_emoji()\n",
      "\n",
      "    def get_sender_emoji(self):\n",
      "        if self.msg_type == \"system\":\n",
      "            return \"\ud83e\udd16\"\n",
      "\n",
      "        sender_name = self.sender_name.lower()\n",
      "        if self.msg_type == \"function_output\":\n",
      "            sender_name = self.receiver_name.lower()\n",
      "\n",
      "        if sender_name == \"user\":\n",
      "            return \"\ud83d\udc64\"\n",
      "\n",
      "        if sender_name == \"ceo\":\n",
      "            return \"\ud83e\udd35\"\n",
      "\n",
      "        # output emoji based on hash of sender name\n",
      "        encoded_str = sender_name.encode()\n",
      "        hash_obj = hashlib.md5(encoded_str)\n",
      "        hash_int = int(hash_obj.hexdigest(), 16)\n",
      "        emojis = [\n",
      "            '\ud83d\udc36', '\ud83d\udc31', '\ud83d\udc2d', '\ud83d\udc39', '\ud83d\udc30', '\ud83e\udd8a',\n",
      "            '\ud83d\udc3b', '\ud83d\udc3c', '\ud83d\udc28', '\ud83d\udc2f', '\ud83e\udd81', '\ud83d\udc2e',\n",
      "            '\ud83d\udc37', '\ud83d\udc38', '\ud83d\udc35', '\ud83d\udc14', '\ud83d\udc27', '\ud83d\udc26',\n",
      "            '\ud83d\udc24']\n",
      "\n",
      "        emoji_index = hash_int % len(emojis)\n",
      "\n",
      "        return emojis[emoji_index]\n",
      "\n",
      "\n",
      "class MessageOutputLive(MessageOutput):\n",
      "    live_display = None\n",
      "\n",
      "    def __init__(self, msg_type: Literal[\"function\", \"function_output\", \"text\", \"system\"], sender_name: str,\n",
      "                 receiver_name: str, content):\n",
      "        super().__init__(msg_type, sender_name, receiver_name, content)\n",
      "        # Initialize Live display if not already done\n",
      "        self.live_display = Live(vertical_overflow=\"visible\")\n",
      "        self.live_display.start()\n",
      "\n",
      "        console.rule()\n",
      "\n",
      "    def __del__(self):\n",
      "        if self.live_display:\n",
      "            self.live_display.stop()\n",
      "            self.live_display = None\n",
      "\n",
      "    def cprint_update(self, snapshot):\n",
      "        \"\"\"\n",
      "        Update the display with new snapshot content.\n",
      "        \"\"\"\n",
      "        self.content = snapshot  # Update content with the latest snapshot\n",
      "\n",
      "        header_text = self.formatted_header\n",
      "        md_content = Markdown(self.content)\n",
      "\n",
      "        # Creating a group of renderables for the live display\n",
      "        render_group = Group(header_text, md_content)\n",
      "\n",
      "        # Update the Live display\n",
      "        self.live_display.update(render_group)\n"
    ],
    "startline": 1,
    "endline": 139
  },
  {
    "path": "agency_swarm/messages/__init__.py",
    "code": [
      "from .message_output import MessageOutput"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/threads/thread.py",
    "code": [
      "import asyncio\n",
      "import inspect\n",
      "import json\n",
      "import os\n",
      "import time\n",
      "from typing import List, Optional, Type, Union\n",
      "\n",
      "from openai import APIError, BadRequestError\n",
      "from openai.types.beta import AssistantToolChoice\n",
      "from openai.types.beta.threads.message import Attachment\n",
      "from openai.types.beta.threads.run import TruncationStrategy\n",
      "\n",
      "from agency_swarm.tools import FileSearch, CodeInterpreter\n",
      "from agency_swarm.util.streaming import AgencyEventHandler\n",
      "from agency_swarm.agents import Agent\n",
      "from agency_swarm.messages import MessageOutput\n",
      "from agency_swarm.user import User\n",
      "from agency_swarm.util.oai import get_openai_client\n",
      "\n",
      "from concurrent.futures import ThreadPoolExecutor, as_completed\n",
      "\n",
      "import re\n",
      "\n",
      "class Thread:\n",
      "    async_mode: str = None\n",
      "    max_workers: int = 4\n",
      "\n",
      "    @property\n",
      "    def thread_url(self):\n",
      "        return f'https://platform.openai.com/playground/assistants?assistant={self.recipient_agent.assistant.id}&mode=assistant&thread={self.id}'\n",
      "\n",
      "    def __init__(self, agent: Union[Agent, User], recipient_agent: Agent):\n",
      "        self.agent = agent\n",
      "        self.recipient_agent = recipient_agent\n",
      "\n",
      "        self.client = get_openai_client()\n",
      "\n",
      "        self.id = None\n",
      "        self.thread = None\n",
      "        self.run = None\n",
      "        self.stream = None\n",
      "\n",
      "        self.num_run_retries = 0\n",
      "\n",
      "    def init_thread(self):\n",
      "        if self.id:\n",
      "            self.thread = self.client.beta.threads.retrieve(self.id)\n",
      "        else:\n",
      "            self.thread = self.client.beta.threads.create()\n",
      "            self.id = self.thread.id\n",
      "\n",
      "            if self.recipient_agent.examples:\n",
      "                for example in self.recipient_agent.examples:\n",
      "                    self.client.beta.threads.messages.create(\n",
      "                        thread_id=self.id,\n",
      "                        **example,\n",
      "                    )\n",
      "\n",
      "    def get_completion_stream(self,\n",
      "                              message: str,\n",
      "                              event_handler: type(AgencyEventHandler),\n",
      "                              message_files: List[str] = None,\n",
      "                              attachments: Optional[List[Attachment]] = None,\n",
      "                              recipient_agent:Agent=None,\n",
      "                              additional_instructions: str = None,\n",
      "                              tool_choice: AssistantToolChoice = None,\n",
      "                              response_format: Optional[dict] = None):\n",
      "\n",
      "        return self.get_completion(message,\n",
      "                                   message_files,\n",
      "                                   attachments,\n",
      "                                   recipient_agent,\n",
      "                                   additional_instructions,\n",
      "                                   event_handler,\n",
      "                                   tool_choice,\n",
      "                                   yield_messages=False,\n",
      "                                   response_format=response_format)\n",
      "\n",
      "    def get_completion(self,\n",
      "                       message: str | List[dict],\n",
      "                       message_files: List[str] = None,\n",
      "                       attachments: Optional[List[dict]] = None,\n",
      "                       recipient_agent: Agent = None,\n",
      "                       additional_instructions: str = None,\n",
      "                       event_handler: type(AgencyEventHandler) = None,\n",
      "                       tool_choice: AssistantToolChoice = None,\n",
      "                       yield_messages: bool = False,\n",
      "                       response_format: Optional[dict] = None\n",
      "                       ):\n",
      "        if not recipient_agent:\n",
      "            recipient_agent = self.recipient_agent\n",
      "        \n",
      "        if not attachments:\n",
      "            attachments = []\n",
      "\n",
      "        if message_files:\n",
      "            recipient_tools = []\n",
      "\n",
      "            if FileSearch in recipient_agent.tools:\n",
      "                recipient_tools.append({\"type\": \"file_search\"})\n",
      "            if CodeInterpreter in recipient_agent.tools:\n",
      "                recipient_tools.append({\"type\": \"code_interpreter\"})\n",
      "\n",
      "            for file_id in message_files:\n",
      "                attachments.append({\"file_id\": file_id,\n",
      "                                    \"tools\": recipient_tools or [{\"type\": \"file_search\"}]})\n",
      "\n",
      "        if not self.thread:\n",
      "            self.init_thread()\n",
      "\n",
      "        if event_handler:\n",
      "            event_handler.set_agent(self.agent)\n",
      "            event_handler.set_recipient_agent(recipient_agent)\n",
      "\n",
      "        # Determine the sender's name based on the agent type\n",
      "        sender_name = \"user\" if isinstance(self.agent, User) else self.agent.name\n",
      "        print(f'THREAD:[ {sender_name} -> {recipient_agent.name} ]: URL {self.thread_url}')\n",
      "\n",
      "        # send message\n",
      "        message_obj = self.create_message(\n",
      "            message=message,\n",
      "            role=\"user\",\n",
      "            attachments=attachments\n",
      "        )\n",
      "\n",
      "        if yield_messages:\n",
      "            yield MessageOutput(\"text\", self.agent.name, recipient_agent.name, message, message_obj)\n",
      "\n",
      "        self._create_run(recipient_agent, additional_instructions, event_handler, tool_choice, response_format=response_format)\n",
      "\n",
      "        error_attempts = 0\n",
      "        validation_attempts = 0\n",
      "        full_message = \"\"\n",
      "        while True:\n",
      "            self._run_until_done()\n",
      "\n",
      "            # function execution\n",
      "            if self.run.status == \"requires_action\":\n",
      "                tool_calls = self.run.required_action.submit_tool_outputs.tool_calls\n",
      "                tool_outputs_and_names = [] # list of tuples (name, tool_output)\n",
      "                sync_tool_calls = [tool_call for tool_call in tool_calls if tool_call.function.name == \"SendMessage\"]\n",
      "                async_tool_calls = [tool_call for tool_call in tool_calls if tool_call.function.name != \"SendMessage\"]\n",
      "\n",
      "                def handle_output(tool_call, output):\n",
      "                    if inspect.isgenerator(output):\n",
      "                        try:\n",
      "                            while True:\n",
      "                                item = next(output)\n",
      "                                if isinstance(item, MessageOutput) and yield_messages:\n",
      "                                    yield item\n",
      "                        except StopIteration as e:\n",
      "                            output = e.value\n",
      "                    else:\n",
      "                        if yield_messages:\n",
      "                            yield MessageOutput(\"function_output\", tool_call.function.name, recipient_agent.name, output, tool_call)\n",
      "\n",
      "                    for tool_output in tool_outputs_and_names:\n",
      "                        if tool_output[1][\"tool_call_id\"] == tool_call.id:\n",
      "                            tool_output[1][\"output\"] = output\n",
      "\n",
      "                if len(async_tool_calls) > 0 and self.async_mode == \"tools_threading\":\n",
      "                    max_workers = min(self.max_workers, os.cpu_count() or 1)  # Use at most 4 workers or the number of CPUs available\n",
      "                    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n",
      "                        futures = {}\n",
      "                        for tool_call in async_tool_calls:\n",
      "                            if yield_messages:\n",
      "                                yield MessageOutput(\"function\", recipient_agent.name, self.agent.name, str(tool_call.function), tool_call)\n",
      "                            futures[executor.submit(self.execute_tool, tool_call, recipient_agent, event_handler, tool_outputs_and_names)] = tool_call\n",
      "                            tool_outputs_and_names.append((tool_call.function.name, {\"tool_call_id\": tool_call.id}))\n",
      "\n",
      "                        for future in as_completed(futures):\n",
      "                            tool_call = futures[future]\n",
      "                            output = future.result()\n",
      "                            yield from handle_output(tool_call, output)\n",
      "                else:\n",
      "                    sync_tool_calls += async_tool_calls\n",
      "\n",
      "                # execute sync tool calls\n",
      "                for tool_call in sync_tool_calls:\n",
      "                    if yield_messages:\n",
      "                        yield MessageOutput(\"function\", recipient_agent.name, self.agent.name, str(tool_call.function), tool_call)\n",
      "                    output = self.execute_tool(tool_call, recipient_agent, event_handler, tool_outputs_and_names)\n",
      "                    tool_outputs_and_names.append((tool_call.function.name, {\"tool_call_id\": tool_call.id, \"output\": output}))\n",
      "                    yield from handle_output(tool_call, output)\n",
      "                \n",
      "                # split names and outputs\n",
      "                tool_outputs = [tool_output for _, tool_output in tool_outputs_and_names]\n",
      "                tool_names = [name for name, _ in tool_outputs_and_names]\n",
      "\n",
      "                # await coroutines\n",
      "                tool_outputs = self._execute_async_tool_calls_outputs(tool_outputs)\n",
      "\n",
      "                # convert all tool outputs to strings\n",
      "                for tool_output in tool_outputs:\n",
      "                    if not isinstance(tool_output[\"output\"], str):\n",
      "                        tool_output[\"output\"] = str(tool_output[\"output\"])\n",
      "\n",
      "                # send message tools can change this in other threads\n",
      "                if event_handler:\n",
      "                    event_handler.set_agent(self.agent)\n",
      "                    event_handler.set_recipient_agent(recipient_agent)\n",
      "                    \n",
      "                # submit tool outputs\n",
      "                try:\n",
      "                    self._submit_tool_outputs(tool_outputs, event_handler)\n",
      "                except BadRequestError as e:\n",
      "                    if 'Runs in status \"expired\"' in e.message:\n",
      "                        self.create_message(\n",
      "                            message=\"Previous request timed out. Please repeat the exact same tool calls in the exact same order with the same arguments.\",\n",
      "                            role=\"user\"\n",
      "                        )\n",
      "\n",
      "                        self._create_run(recipient_agent, additional_instructions, event_handler, 'required', temperature=0)\n",
      "                        self._run_until_done()\n",
      "\n",
      "                        if self.run.status != \"requires_action\":\n",
      "                            raise Exception(\"Run Failed. Error: \", self.run.last_error or self.run.incomplete_details)\n",
      "\n",
      "                        # change tool call ids\n",
      "                        tool_calls = self.run.required_action.submit_tool_outputs.tool_calls\n",
      "\n",
      "                        if len(tool_calls) != len(tool_outputs):\n",
      "                            tool_outputs = []\n",
      "                            for i, tool_call in enumerate(tool_calls):\n",
      "                                tool_outputs.append({\"tool_call_id\": tool_call.id, \"output\": \"Error: openai run timed out. You can try again one more time.\"})\n",
      "                        else:\n",
      "                            for i, tool_name in enumerate(tool_names):\n",
      "                                for tool_call in tool_calls[:]:\n",
      "                                    if tool_call.function.name == tool_name:\n",
      "                                        tool_outputs[i][\"tool_call_id\"] = tool_call.id\n",
      "                                        tool_calls.remove(tool_call)\n",
      "                                        break\n",
      "\n",
      "                        self._submit_tool_outputs(tool_outputs, event_handler)\n",
      "                    else:\n",
      "                        raise e\n",
      "            # error\n",
      "            elif self.run.status == \"failed\":\n",
      "                full_message += self._get_last_message_text()\n",
      "                common_errors = [\"something went wrong\", \"the server had an error processing your request\", \"rate limit reached\"]\n",
      "                error_message = self.run.last_error.message.lower()\n",
      "\n",
      "                if error_attempts < 3 and any(error in error_message for error in common_errors):\n",
      "                    if error_attempts < 2:\n",
      "                        time.sleep(1 + error_attempts)\n",
      "                    else:\n",
      "                        self.create_message(message=\"Continue.\", role=\"user\")\n",
      "                    \n",
      "                    self._create_run(recipient_agent, additional_instructions, event_handler, \n",
      "                                     tool_choice, response_format=response_format)\n",
      "                    error_attempts += 1\n",
      "                else:\n",
      "                    raise Exception(\"OpenAI Run Failed. Error: \", self.run.last_error.message)\n",
      "            elif self.run.status == \"incomplete\":\n",
      "                raise Exception(\"OpenAI Run Incomplete. Details: \", self.run.incomplete_details)\n",
      "            # return assistant message\n",
      "            else:\n",
      "                message_obj = self._get_last_assistant_message()\n",
      "                last_message = message_obj.content[0].text.value\n",
      "                full_message += last_message\n",
      "\n",
      "                if yield_messages:\n",
      "                    yield MessageOutput(\"text\", recipient_agent.name, self.agent.name, last_message, message_obj)\n",
      "\n",
      "                if recipient_agent.response_validator:\n",
      "                    try:\n",
      "                        if isinstance(recipient_agent, Agent):\n",
      "                            # TODO: allow users to modify the last message from response validator and replace it on OpenAI\n",
      "                            recipient_agent.response_validator(message=last_message)\n",
      "                    except Exception as e:\n",
      "                        if validation_attempts < recipient_agent.validation_attempts:\n",
      "                            try:\n",
      "                                evaluated_content = eval(str(e))\n",
      "                                if isinstance(evaluated_content, list):\n",
      "                                    content = evaluated_content\n",
      "                                else:\n",
      "                                    content = str(e)\n",
      "                            except Exception as eval_exception:\n",
      "                                content = str(e)\n",
      "\n",
      "                            message_obj = self.create_message(\n",
      "                                message=content,\n",
      "                                role=\"user\"\n",
      "                            )\n",
      "\n",
      "                            if yield_messages:\n",
      "                                for content in message_obj.content:\n",
      "                                    if hasattr(content, 'text') and hasattr(content.text, 'value'):\n",
      "                                        yield MessageOutput(\"text\", self.agent.name, recipient_agent.name,\n",
      "                                                            content.text.value, message_obj)\n",
      "                                        break\n",
      "\n",
      "                            if event_handler:\n",
      "                                handler = event_handler()\n",
      "                                handler.on_message_created(message_obj)\n",
      "                                handler.on_message_done(message_obj)\n",
      "\n",
      "                            validation_attempts += 1\n",
      "\n",
      "                            self._create_run(recipient_agent, additional_instructions, event_handler, tool_choice, response_format=response_format)\n",
      "\n",
      "                            continue\n",
      "\n",
      "                return last_message\n",
      "\n",
      "    def _create_run(self, recipient_agent, additional_instructions, event_handler, tool_choice, temperature=None, response_format: Optional[dict] = None):\n",
      "        try:\n",
      "            if event_handler:\n",
      "                with self.client.beta.threads.runs.stream(\n",
      "                        thread_id=self.thread.id,\n",
      "                        event_handler=event_handler(),\n",
      "                        assistant_id=recipient_agent.id,\n",
      "                        additional_instructions=additional_instructions,\n",
      "                        tool_choice=tool_choice,\n",
      "                        max_prompt_tokens=recipient_agent.max_prompt_tokens,\n",
      "                        max_completion_tokens=recipient_agent.max_completion_tokens,\n",
      "                        truncation_strategy=recipient_agent.truncation_strategy,\n",
      "                        temperature=temperature,\n",
      "                        extra_body={\"parallel_tool_calls\": recipient_agent.parallel_tool_calls},\n",
      "                        response_format=response_format\n",
      "                ) as stream:\n",
      "                    stream.until_done()\n",
      "                    self.run = stream.get_final_run()\n",
      "            else:\n",
      "                self.run = self.client.beta.threads.runs.create(\n",
      "                    thread_id=self.thread.id,\n",
      "                    assistant_id=recipient_agent.id,\n",
      "                    additional_instructions=additional_instructions,\n",
      "                    tool_choice=tool_choice,\n",
      "                    max_prompt_tokens=recipient_agent.max_prompt_tokens,\n",
      "                    max_completion_tokens=recipient_agent.max_completion_tokens,\n",
      "                    truncation_strategy=recipient_agent.truncation_strategy,\n",
      "                    temperature=temperature,\n",
      "                    parallel_tool_calls=recipient_agent.parallel_tool_calls,\n",
      "                    response_format=response_format\n",
      "                )\n",
      "                self.run = self.client.beta.threads.runs.poll(\n",
      "                    thread_id=self.thread.id,\n",
      "                    run_id=self.run.id,\n",
      "                    # poll_interval_ms=500,\n",
      "                )\n",
      "        except APIError as e:\n",
      "            if \"The server had an error processing your request\" in e.message and self.num_run_retries < 3:\n",
      "                time.sleep(1 + self.num_run_retries)\n",
      "                self._create_run(recipient_agent, additional_instructions, event_handler, tool_choice, response_format=response_format)\n",
      "                self.num_run_retries += 1\n",
      "            else:\n",
      "                raise e\n",
      "\n",
      "    def _run_until_done(self):\n",
      "        while self.run.status in ['queued', 'in_progress', \"cancelling\"]:\n",
      "            time.sleep(0.5)\n",
      "            self.run = self.client.beta.threads.runs.retrieve(\n",
      "                thread_id=self.thread.id,\n",
      "                run_id=self.run.id\n",
      "            )\n",
      "\n",
      "    def _submit_tool_outputs(self, tool_outputs, event_handler):\n",
      "        if not event_handler:\n",
      "            self.run = self.client.beta.threads.runs.submit_tool_outputs_and_poll(\n",
      "                thread_id=self.thread.id,\n",
      "                run_id=self.run.id,\n",
      "                tool_outputs=tool_outputs\n",
      "            )\n",
      "        else:\n",
      "            with self.client.beta.threads.runs.submit_tool_outputs_stream(\n",
      "                    thread_id=self.thread.id,\n",
      "                    run_id=self.run.id,\n",
      "                    tool_outputs=tool_outputs,\n",
      "                    event_handler=event_handler()\n",
      "            ) as stream:\n",
      "                stream.until_done()\n",
      "                self.run = stream.get_final_run()\n",
      "\n",
      "    def _get_last_message_text(self):\n",
      "        messages = self.client.beta.threads.messages.list(\n",
      "            thread_id=self.id,\n",
      "            limit=1\n",
      "        )\n",
      "\n",
      "        if len(messages.data) == 0 or len(messages.data[0].content) == 0:\n",
      "            return \"\"\n",
      "\n",
      "        return messages.data[0].content[0].text.value\n",
      "\n",
      "    def _get_last_assistant_message(self):\n",
      "        messages = self.client.beta.threads.messages.list(\n",
      "            thread_id=self.id,\n",
      "            limit=1\n",
      "        )\n",
      "\n",
      "        if len(messages.data) == 0 or len(messages.data[0].content) == 0:\n",
      "            raise Exception(\"No messages found in the thread\")\n",
      "\n",
      "        message = messages.data[0]\n",
      "\n",
      "        if message.role == \"assistant\":\n",
      "            return message\n",
      "\n",
      "        raise Exception(\"No assistant message found in the thread\")   \n",
      "\n",
      "    def create_message(self, message: str, role: str = \"user\", attachments: List[dict] = None):\n",
      "        try:\n",
      "            return self.client.beta.threads.messages.create(\n",
      "                thread_id=self.id,\n",
      "                role=role,\n",
      "                content=message,\n",
      "                attachments=attachments\n",
      "            )\n",
      "        except BadRequestError as e:\n",
      "            regex = re.compile(\n",
      "                r\"Can't add messages to thread_([a-zA-Z0-9]+) while a run run_([a-zA-Z0-9]+) is active\\.\"\n",
      "            )\n",
      "            match = regex.search(str(e))\n",
      "            \n",
      "            if match:\n",
      "                thread_id, run_id = match.groups()\n",
      "                thread_id = f\"thread_{thread_id}\"\n",
      "                run_id = f\"run_{run_id}\"\n",
      "                self.client.beta.threads.runs.cancel(\n",
      "                    thread_id=thread_id,\n",
      "                    run_id=run_id\n",
      "                )\n",
      "                self.run = self.client.beta.threads.runs.poll(\n",
      "                    thread_id=thread_id,\n",
      "                    run_id=run_id,\n",
      "                    poll_interval_ms=500,\n",
      "                )\n",
      "                return self.client.beta.threads.messages.create(\n",
      "                    thread_id=thread_id,\n",
      "                    role=role,\n",
      "                    content=message,\n",
      "                    attachments=attachments\n",
      "                )\n",
      "            else:\n",
      "                raise Exception(\"Please start a new chat.\") from e\n",
      "\n",
      "    def execute_tool(self, tool_call, recipient_agent=None, event_handler=None, tool_outputs_and_names={}):\n",
      "        if not recipient_agent:\n",
      "            recipient_agent = self.recipient_agent\n",
      "\n",
      "        funcs = recipient_agent.functions\n",
      "        tool = next((func for func in funcs if func.__name__ == tool_call.function.name), None)\n",
      "\n",
      "        if not tool:\n",
      "            return f\"Error: Function {tool_call.function.name} not found. Available functions: {[func.__name__ for func in funcs]}\"\n",
      "\n",
      "        try:\n",
      "            # init tool\n",
      "            args = tool_call.function.arguments\n",
      "            args = json.loads(args) if args else {}\n",
      "            tool = tool(**args)\n",
      "            for tool_name in [name for name, _ in tool_outputs_and_names]:\n",
      "                if tool_name == tool_call.function.name and (\n",
      "                        hasattr(tool, \"ToolConfig\") and hasattr(tool.ToolConfig, \"one_call_at_a_time\") and tool.ToolConfig.one_call_at_a_time):\n",
      "                    return f\"Error: Function {tool_call.function.name} is already called. You can only call this function once at a time. Please wait for the previous call to finish before calling it again.\"\n",
      "            \n",
      "            tool._caller_agent = recipient_agent\n",
      "            tool._event_handler = event_handler\n",
      "\n",
      "            return tool.run()\n",
      "        except Exception as e:\n",
      "            error_message = f\"Error: {e}\"\n",
      "            if \"For further information visit\" in error_message:\n",
      "                error_message = error_message.split(\"For further information visit\")[0]\n",
      "            return error_message\n",
      "        \n",
      "    def _execute_async_tool_calls_outputs(self, tool_outputs):\n",
      "        async_tool_calls = []\n",
      "        for tool_output in tool_outputs:\n",
      "            if inspect.iscoroutine(tool_output[\"output\"]):\n",
      "                async_tool_calls.append(tool_output)\n",
      "\n",
      "        if async_tool_calls:\n",
      "            try:\n",
      "                loop = asyncio.get_event_loop()\n",
      "                if loop.is_closed():\n",
      "                    raise RuntimeError\n",
      "            except RuntimeError:\n",
      "                loop = asyncio.new_event_loop()\n",
      "                asyncio.set_event_loop(loop)\n",
      "                loop = asyncio.get_event_loop()\n",
      "\n",
      "            results = loop.run_until_complete(asyncio.gather(*[call[\"output\"] for call in async_tool_calls]))\n",
      "            \n",
      "            for tool_output, result in zip(async_tool_calls, results):\n",
      "                tool_output[\"output\"] = str(result)\n",
      "        \n",
      "        return tool_outputs\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "\n"
    ],
    "startline": 1,
    "endline": 499
  },
  {
    "path": "agency_swarm/threads/thread_async.py",
    "code": [
      "import threading\n",
      "from typing import Union, Optional, List\n",
      "\n",
      "from openai.types.beta import AssistantToolChoice\n",
      "\n",
      "from agency_swarm.agents import Agent\n",
      "from agency_swarm.threads import Thread\n",
      "from agency_swarm.user import User\n",
      "\n",
      "\n",
      "class ThreadAsync(Thread):\n",
      "    def __init__(self, agent: Union[Agent, User], recipient_agent: Agent):\n",
      "        super().__init__(agent, recipient_agent)\n",
      "        self.pythread = None\n",
      "        self.response = None\n",
      "        self.async_mode = False \n",
      "\n",
      "    def worker(self,\n",
      "               message: str,\n",
      "               message_files: List[str] = None,\n",
      "               attachments: Optional[List[dict]] = None,\n",
      "               recipient_agent=None,\n",
      "               additional_instructions: str = None,\n",
      "               tool_choice: AssistantToolChoice = None\n",
      "               ):\n",
      "        self.async_mode = False \n",
      "\n",
      "        gen = self.get_completion(message=message,\n",
      "                                    message_files=message_files,\n",
      "                                    attachments=attachments,\n",
      "                                    recipient_agent=recipient_agent,\n",
      "                                    additional_instructions=additional_instructions,\n",
      "                                    tool_choice=tool_choice)\n",
      "\n",
      "        while True:\n",
      "            try:\n",
      "                next(gen)\n",
      "            except StopIteration as e:\n",
      "                self.response = f\"\"\"{self.recipient_agent.name}'s Response: '{e.value}'\"\"\"\n",
      "                break\n",
      "\n",
      "        return\n",
      "\n",
      "    def get_completion_async(self,\n",
      "                             message: str,\n",
      "                             message_files: List[str] = None,\n",
      "                             attachments: Optional[List[dict]] = None,\n",
      "                             recipient_agent=None,\n",
      "                             additional_instructions: str = None,\n",
      "                             tool_choice: AssistantToolChoice = None,\n",
      "                             ):\n",
      "        if self.pythread and self.pythread.is_alive():\n",
      "            return \"System Notification: 'Agent is busy, so your message was not received. Please always use 'GetResponse' tool to check for status first, before using 'SendMessage' tool again for the same agent.'\"\n",
      "        elif self.pythread and not self.pythread.is_alive():\n",
      "            self.pythread.join()\n",
      "            self.pythread = None\n",
      "            self.response = None\n",
      "\n",
      "        run = self.get_last_run()\n",
      "\n",
      "        if run and run.status in ['queued', 'in_progress', 'requires_action']:\n",
      "            return \"System Notification: 'Agent is busy, so your message was not received. Please always use 'GetResponse' tool to check for status first, before using 'SendMessage' tool again for the same agent.'\"\n",
      "\n",
      "        self.pythread = threading.Thread(target=self.worker,\n",
      "                                         args=(message, message_files, attachments, recipient_agent, additional_instructions, tool_choice))\n",
      "\n",
      "        self.pythread.start()\n",
      "\n",
      "        return \"System Notification: 'Task has started. Please notify the user that they can tell you to check the status later. You can do this with the 'GetResponse' tool, after you have been instructed to do so. Don't mention the tool itself to the user. \"\n",
      "\n",
      "    def check_status(self, run=None):\n",
      "        if not run:\n",
      "            run = self.get_last_run()\n",
      "\n",
      "        if not run:\n",
      "            return \"System Notification: 'Agent is ready to receive a message. Please send a message with the 'SendMessage' tool.'\"\n",
      "\n",
      "        # check run status\n",
      "        if run.status in ['queued', 'in_progress', 'requires_action']:\n",
      "            return \"System Notification: 'Task is not completed yet. Please tell the user to wait and try again later.'\"\n",
      "\n",
      "        if run.status == \"failed\":\n",
      "            return f\"System Notification: 'Agent run failed with error: {run.last_error.message}. You may send another message with the 'SendMessage' tool.'\"\n",
      "\n",
      "        messages = self.client.beta.threads.messages.list(\n",
      "            thread_id=self.id,\n",
      "            order=\"desc\",\n",
      "        )\n",
      "\n",
      "        return f\"\"\"{self.recipient_agent.name}'s Response: '{messages.data[0].content[0].text.value}'\"\"\"\n",
      "\n",
      "    def get_last_run(self):\n",
      "        if not self.thread:\n",
      "            self.init_thread()\n",
      "\n",
      "        runs = self.client.beta.threads.runs.list(\n",
      "            thread_id=self.thread.id,\n",
      "            order=\"desc\",\n",
      "        )\n",
      "\n",
      "        if len(runs.data) == 0:\n",
      "            return None\n",
      "\n",
      "        run = runs.data[0]\n",
      "\n",
      "        return run\n"
    ],
    "startline": 1,
    "endline": 106
  },
  {
    "path": "agency_swarm/threads/__init__.py",
    "code": [
      "from .thread import Thread\n"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/tools/BaseTool.py",
    "code": [
      "from abc import ABC, abstractmethod\n",
      "from typing import Any, ClassVar\n",
      "\n",
      "from docstring_parser import parse\n",
      "\n",
      "from pydantic import BaseModel\n",
      "from agency_swarm.util.shared_state import SharedState\n",
      "\n",
      "\n",
      "class BaseTool(BaseModel, ABC):\n",
      "    _shared_state: ClassVar[SharedState] = None\n",
      "    _caller_agent: Any = None\n",
      "    _event_handler: Any = None\n",
      "\n",
      "    def __init__(self, **kwargs):\n",
      "        if not self.__class__._shared_state:\n",
      "            self.__class__._shared_state = SharedState()\n",
      "        super().__init__(**kwargs)\n",
      "\n",
      "    class ToolConfig:\n",
      "        strict: bool = False\n",
      "        one_call_at_a_time: bool = False\n",
      "\n",
      "    @classmethod\n",
      "    @property\n",
      "    def openai_schema(cls):\n",
      "        \"\"\"\n",
      "        Return the schema in the format of OpenAI's schema as jsonschema\n",
      "\n",
      "        Note:\n",
      "            Its important to add a docstring to describe how to best use this class, it will be included in the description attribute and be part of the prompt.\n",
      "\n",
      "        Returns:\n",
      "            model_json_schema (dict): A dictionary in the format of OpenAI's schema as jsonschema\n",
      "        \"\"\"\n",
      "        schema = cls.model_json_schema()\n",
      "        docstring = parse(cls.__doc__ or \"\")\n",
      "        parameters = {\n",
      "            k: v for k, v in schema.items() if k not in (\"title\", \"description\")\n",
      "        }\n",
      "        for param in docstring.params:\n",
      "            if (name := param.arg_name) in parameters[\"properties\"] and (\n",
      "                description := param.description\n",
      "            ):\n",
      "                if \"description\" not in parameters[\"properties\"][name]:\n",
      "                    parameters[\"properties\"][name][\"description\"] = description\n",
      "\n",
      "        parameters[\"required\"] = sorted(\n",
      "            k for k, v in parameters[\"properties\"].items() if \"default\" not in v\n",
      "        )\n",
      "\n",
      "        if \"description\" not in schema:\n",
      "            if docstring.short_description:\n",
      "                schema[\"description\"] = docstring.short_description\n",
      "            else:\n",
      "                schema[\"description\"] = (\n",
      "                    f\"Correctly extracted `{cls.__name__}` with all \"\n",
      "                    f\"the required parameters with correct types\"\n",
      "                )\n",
      "\n",
      "        schema = {\n",
      "            \"name\": schema[\"title\"],\n",
      "            \"description\": schema[\"description\"],\n",
      "            \"parameters\": parameters,\n",
      "        }\n",
      "\n",
      "        strict = getattr(cls.ToolConfig, \"strict\", False)\n",
      "        if strict:\n",
      "            schema[\"strict\"] = True\n",
      "            schema[\"parameters\"][\"additionalProperties\"] = False\n",
      "            # iterate through defs and set additionalProperties to false\n",
      "            if \"$defs\" in schema[\"parameters\"]:\n",
      "                for def_ in schema[\"parameters\"][\"$defs\"].values():\n",
      "                    def_[\"additionalProperties\"] = False\n",
      "        else:\n",
      "            schema[\"strict\"] = False\n",
      "            \n",
      "        return schema\n",
      "\n",
      "    @abstractmethod\n",
      "    def run(self, **kwargs):\n",
      "        pass\n"
    ],
    "startline": 1,
    "endline": 82
  },
  {
    "path": "agency_swarm/tools/ToolFactory.py",
    "code": [
      "import inspect\n",
      "import json\n",
      "import os\n",
      "import sys\n",
      "from importlib import import_module\n",
      "from typing import Any, Dict, List, Type, Union\n",
      "\n",
      "import jsonref\n",
      "from jsonref import requests\n",
      "from pydantic import create_model, Field\n",
      "\n",
      "from .BaseTool import BaseTool\n",
      "from ..util.schema import dereference_schema, reference_schema\n",
      "\n",
      "from datamodel_code_generator import DataModelType, PythonVersion\n",
      "from datamodel_code_generator.model import get_data_model_types\n",
      "from datamodel_code_generator.parser.jsonschema import JsonSchemaParser\n",
      "\n",
      "import httpx\n",
      "\n",
      "class ToolFactory:\n",
      "\n",
      "    @staticmethod\n",
      "    def from_langchain_tools(tools: List) -> List[Type[BaseTool]]:\n",
      "        \"\"\"\n",
      "        Converts a list of langchain tools into a list of BaseTools.\n",
      "\n",
      "        Parameters:\n",
      "            tools: The langchain tools to convert.\n",
      "\n",
      "        Returns:\n",
      "            A list of BaseTools.\n",
      "        \"\"\"\n",
      "        converted_tools = []\n",
      "        for tool in tools:\n",
      "            converted_tools.append(ToolFactory.from_langchain_tool(tool))\n",
      "\n",
      "        return converted_tools\n",
      "\n",
      "    @staticmethod\n",
      "    def from_langchain_tool(tool) -> Type[BaseTool]:\n",
      "        \"\"\"\n",
      "        Converts a langchain tool into a BaseTool.\n",
      "\n",
      "        Parameters:\n",
      "            tool: The langchain tool to convert.\n",
      "\n",
      "        Returns:\n",
      "            A BaseTool.\n",
      "        \"\"\"\n",
      "        try:\n",
      "            from langchain.tools import format_tool_to_openai_function\n",
      "        except ImportError:\n",
      "            raise ImportError(\"You must install langchain to use this method.\")\n",
      "\n",
      "        if inspect.isclass(tool):\n",
      "            tool = tool()\n",
      "\n",
      "        def callback(self):\n",
      "            tool_input = self.model_dump()\n",
      "            try:\n",
      "                return tool.run(tool_input)\n",
      "            except TypeError:\n",
      "                if len(tool_input) == 1:\n",
      "                    return tool.run(list(tool_input.values())[0])\n",
      "                else:\n",
      "                    raise TypeError(f\"Error parsing input for tool '{tool.__class__.__name__}' Please open an issue \"\n",
      "                                    f\"on github.\")\n",
      "\n",
      "        return ToolFactory.from_openai_schema(\n",
      "            format_tool_to_openai_function(tool),\n",
      "            callback\n",
      "        )\n",
      "\n",
      "\n",
      "    @staticmethod\n",
      "    def from_openai_schema(schema: Dict[str, Any], callback: Any) -> Type[BaseTool]:\n",
      "        \"\"\"\n",
      "        Converts an OpenAI schema into a BaseTool.\n",
      "\n",
      "        Parameters:\n",
      "            schema: The OpenAI schema to convert.\n",
      "            callback: The function to run when the tool is called.\n",
      "\n",
      "        Returns:\n",
      "            A BaseTool.\n",
      "        \"\"\"\n",
      "        data_model_types = get_data_model_types(\n",
      "            DataModelType.PydanticV2BaseModel,\n",
      "            target_python_version=PythonVersion.PY_37\n",
      "        )\n",
      "\n",
      "        parser = JsonSchemaParser(\n",
      "            json.dumps(schema['parameters']),\n",
      "            data_model_type=data_model_types.data_model,\n",
      "            data_model_root_type=data_model_types.root_model,\n",
      "            data_model_field_type=data_model_types.field_model,\n",
      "            data_type_manager_type=data_model_types.data_type_manager,\n",
      "            dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,\n",
      "            use_schema_description=True,\n",
      "            validation=False,\n",
      "            class_name='Model',\n",
      "            # custom_template_dir=Path('/Users/vrsen/Projects/agency-swarm/agency-swarm/agency_swarm/tools/data_schema_templates')\n",
      "        )\n",
      "\n",
      "        result = parser.parse()\n",
      "\n",
      "        # # Execute the result to extract the model\n",
      "        exec_globals = {}\n",
      "        exec(result, exec_globals)\n",
      "        model = exec_globals.get('Model')\n",
      "\n",
      "        if not model:\n",
      "            raise ValueError(f\"Could not extract model from schema {schema['name']}\")\n",
      "        \n",
      "        class ToolConfig:\n",
      "            strict: bool = schema.get(\"strict\", False)\n",
      "        \n",
      "        tool = type(schema['name'], (BaseTool, model), {\n",
      "            \"__doc__\": schema.get('description', \"\"),\n",
      "            \"run\": callback,\n",
      "        })\n",
      "\n",
      "        tool.ToolConfig = ToolConfig\n",
      "\n",
      "        return tool\n",
      "\n",
      "    @staticmethod\n",
      "    def from_openapi_schema(schema: Union[str, dict], headers: Dict[str, str] = None, params: Dict[str, Any] = None, strict: bool = False) \\\n",
      "            -> List[Type[BaseTool]]:\n",
      "        \"\"\"\n",
      "        Converts an OpenAPI schema into a list of BaseTools.\n",
      "\n",
      "        Parameters:\n",
      "            schema: The OpenAPI schema to convert.\n",
      "            headers: The headers to use for requests.\n",
      "            params: The parameters to use for requests.\n",
      "            strict: Whether to use strict OpenAI mode.\n",
      "        Returns:\n",
      "            A list of BaseTools.\n",
      "        \"\"\"\n",
      "        if isinstance(schema, dict):\n",
      "            openapi_spec = schema\n",
      "            openapi_spec = jsonref.JsonRef.replace_refs(openapi_spec)\n",
      "        else:\n",
      "            openapi_spec = jsonref.loads(schema)\n",
      "        tools = []\n",
      "        headers = headers or {}\n",
      "        headers = {k: v for k, v in headers.items() if v is not None}\n",
      "        for path, methods in openapi_spec[\"paths\"].items():\n",
      "            for method, spec_with_ref in methods.items():\n",
      "                async def callback(self):\n",
      "                    url = openapi_spec[\"servers\"][0][\"url\"] + path\n",
      "                    parameters = self.model_dump().get('parameters', {})\n",
      "                    # replace all parameters in url\n",
      "                    for param, value in parameters.items():\n",
      "                        if \"{\" + str(param) + \"}\" in url:\n",
      "                            url = url.replace(f\"{{{param}}}\", str(value))\n",
      "                            parameters[param] = None\n",
      "                    url = url.rstrip(\"/\")\n",
      "                    parameters = {k: v for k, v in parameters.items() if v is not None}\n",
      "                    parameters = {**parameters, **params} if params else parameters\n",
      "                    async with httpx.AsyncClient(timeout=90) as client:  # Set custom read timeout to 10 seconds\n",
      "                        if method == \"get\":\n",
      "                            response = await client.get(url, params=parameters, headers=headers)\n",
      "                        elif method == \"post\":\n",
      "                            response = await client.post(url,\n",
      "                                                         params=parameters,\n",
      "                                                         json=self.model_dump().get('requestBody', None),\n",
      "                                                         headers=headers)\n",
      "                        elif method == \"put\":\n",
      "                            response = await client.put(url,\n",
      "                                                        params=parameters,\n",
      "                                                        json=self.model_dump().get('requestBody', None),\n",
      "                                                        headers=headers)\n",
      "                        elif method == \"delete\":\n",
      "                            response = await client.delete(url,\n",
      "                                                           params=parameters,\n",
      "                                                           json=self.model_dump().get('requestBody', None),\n",
      "                                                           headers=headers)\n",
      "                        return response.json()\n",
      "\n",
      "                # 1. Resolve JSON references.\n",
      "                spec = jsonref.replace_refs(spec_with_ref)\n",
      "\n",
      "                # 2. Extract a name for the functions.\n",
      "                function_name = spec.get(\"operationId\")\n",
      "\n",
      "                # 3. Extract a description and parameters.\n",
      "                desc = spec.get(\"description\") or spec.get(\"summary\", \"\")\n",
      "\n",
      "                schema = {\"type\": \"object\", \"properties\": {}}\n",
      "\n",
      "                req_body = (\n",
      "                    spec.get(\"requestBody\", {})\n",
      "                    .get(\"content\", {})\n",
      "                    .get(\"application/json\", {})\n",
      "                    .get(\"schema\")\n",
      "                )\n",
      "                if req_body:\n",
      "                    schema[\"properties\"][\"requestBody\"] = req_body\n",
      "\n",
      "                spec_params = spec.get(\"parameters\", [])\n",
      "                if spec_params:\n",
      "                    param_properties = {}\n",
      "                    required_params = []\n",
      "                    for param in spec_params:\n",
      "                        if \"schema\" not in param and \"type\" in param:\n",
      "                            param[\"schema\"] = {\"type\": param[\"type\"]}\n",
      "                        param_properties[param[\"name\"]] = param[\"schema\"]\n",
      "                        if \"description\" in param:\n",
      "                            param_properties[param[\"name\"]][\"description\"] = param[\"description\"]\n",
      "                        if \"required\" in param and param[\"required\"]:\n",
      "                            required_params.append(param[\"name\"])\n",
      "                        if \"example\" in param:\n",
      "                            param_properties[param[\"name\"]][\"example\"] = param[\"example\"]\n",
      "                        if \"examples\" in param:\n",
      "                            param_properties[param[\"name\"]][\"examples\"] = param[\"examples\"]\n",
      "                    \n",
      "                    schema[\"properties\"][\"parameters\"] = {\n",
      "                        \"type\": \"object\",\n",
      "                        \"properties\": param_properties,\n",
      "                        \"required\": required_params\n",
      "                    }\n",
      "\n",
      "                function = {\n",
      "                    \"name\": function_name,\n",
      "                    \"description\": desc,\n",
      "                    \"parameters\": schema,\n",
      "                    \"strict\": strict\n",
      "                }\n",
      "\n",
      "                tools.append(ToolFactory.from_openai_schema(function, callback))\n",
      "\n",
      "        return tools\n",
      "    \n",
      "    @staticmethod\n",
      "    def from_file(file_path: str) -> Type[BaseTool]:\n",
      "        \"\"\"Dynamically imports a BaseTool class from a Python file within a package structure.\n",
      "\n",
      "        Parameters:\n",
      "            file_path: The file path to the Python file containing the BaseTool class.\n",
      "\n",
      "        Returns:\n",
      "            The imported BaseTool class.\n",
      "        \"\"\"\n",
      "        file_path = os.path.relpath(file_path)\n",
      "        # Normalize the file path to be absolute and extract components\n",
      "        directory, file_name = os.path.split(file_path)\n",
      "        import_path = os.path.splitext(file_path)[0].replace(os.sep, \".\")\n",
      "        class_name = os.path.splitext(file_name)[0]\n",
      "\n",
      "        exec_globals = globals()\n",
      "        \n",
      "        # importing from agency_swarm package\n",
      "        if \"agency_swarm\" in import_path:\n",
      "            import_path = import_path.lstrip(\".\")\n",
      "            exec(f\"from {import_path} import {class_name}\", exec_globals)\n",
      "        # importing from current working directory\n",
      "        else:\n",
      "            current_working_directory = os.getcwd()\n",
      "            sys.path.append(current_working_directory)\n",
      "            exec(f\"from {import_path} import {class_name}\", exec_globals)\n",
      "\n",
      "        \n",
      "\n",
      "        imported_class = exec_globals.get(class_name)\n",
      "        if not imported_class:\n",
      "            raise ImportError(f\"Could not import {class_name} from {import_path}\")\n",
      "\n",
      "        # Check if the imported class is a subclass of BaseTool\n",
      "        if not issubclass(imported_class, BaseTool):\n",
      "            raise TypeError(f\"Class {class_name} must be a subclass of BaseTool\")\n",
      "\n",
      "        return imported_class\n",
      "\n",
      "    @staticmethod\n",
      "    def get_openapi_schema(tools: List[Type[BaseTool]], url: str, title=\"Agent Tools\",\n",
      "                           description=\"A collection of tools.\") -> str:\n",
      "        \"\"\"\n",
      "        Generates an OpenAPI schema from a list of BaseTools.\n",
      "\n",
      "        Parameters:\n",
      "            tools: BaseTools to generate the schema from.\n",
      "            url: The base URL for the schema.\n",
      "            title: The title of the schema.\n",
      "            description: The description of the schema.\n",
      "\n",
      "        Returns:\n",
      "            A JSON string representing the OpenAPI schema with all the tools combined as separate endpoints.\n",
      "        \"\"\"\n",
      "        schema = {\n",
      "            \"openapi\": \"3.1.0\",\n",
      "            \"info\": {\n",
      "                \"title\": title,\n",
      "                \"description\": description,\n",
      "                \"version\": \"v1.0.0\"\n",
      "            },\n",
      "            \"servers\": [\n",
      "                {\n",
      "                    \"url\": url,\n",
      "                }\n",
      "            ],\n",
      "            \"paths\": {},\n",
      "            \"components\": {\n",
      "                \"schemas\": {},\n",
      "                \"securitySchemes\": {\n",
      "                    \"apiKey\": {\n",
      "                        \"type\": \"apiKey\"\n",
      "                    }\n",
      "                }\n",
      "            },\n",
      "        }\n",
      "\n",
      "        for tool in tools:\n",
      "            if not issubclass(tool, BaseTool):\n",
      "                continue\n",
      "\n",
      "            openai_schema = tool.openai_schema\n",
      "            defs = {}\n",
      "            if '$defs' in openai_schema['parameters']:\n",
      "                defs = openai_schema['parameters']['$defs']\n",
      "                del openai_schema['parameters']['$defs']\n",
      "\n",
      "            schema['paths'][\"/\" + openai_schema['name']] = {\n",
      "                \"post\": {\n",
      "                    \"description\": openai_schema['description'],\n",
      "                    \"operationId\": openai_schema['name'],\n",
      "                    \"x-openai-isConsequential\": False,\n",
      "                    \"parameters\": [],\n",
      "                    \"requestBody\": {\n",
      "                        \"content\": {\n",
      "                            \"application/json\": {\n",
      "                                \"schema\": openai_schema['parameters']\n",
      "                            }\n",
      "                        }\n",
      "                    },\n",
      "                }\n",
      "            }\n",
      "\n",
      "            schema['components']['schemas'].update(defs)\n",
      "\n",
      "        schema = json.dumps(schema, indent=2).replace(\"#/$defs/\", \"#/components/schemas/\")\n",
      "\n",
      "        return schema"
    ],
    "startline": 1,
    "endline": 345
  },
  {
    "path": "agency_swarm/tools/__init__.py",
    "code": [
      "from .BaseTool import BaseTool\n",
      "from .oai.CodeInterpreter import CodeInterpreter\n",
      "from .oai.FileSearch import FileSearch\n",
      "from .oai.Retrieval import Retrieval\n",
      "from .ToolFactory import ToolFactory\n"
    ],
    "startline": 1,
    "endline": 5
  },
  {
    "path": "agency_swarm/tools/oai/CodeInterpreter.py",
    "code": [
      "from pydantic import BaseModel\n",
      "\n",
      "\n",
      "class CodeInterpreter(BaseModel):\n",
      "    type: str = \"code_interpreter\"\n"
    ],
    "startline": 1,
    "endline": 5
  },
  {
    "path": "agency_swarm/tools/oai/FileSearch.py",
    "code": [
      "from typing import Optional\n",
      "from pydantic import BaseModel, field_validator, Field\n",
      "\n",
      "class FileSearchConfig(BaseModel):\n",
      "    max_num_results: int = Field(50, description=\"Optional override for the maximum number of results\")\n",
      "\n",
      "    @field_validator('max_num_results')\n",
      "    def check_max_num_results(cls, v):\n",
      "        if not 1 <= v <= 50:\n",
      "            raise ValueError('file_search.max_num_results must be between 1 and 50 inclusive')\n",
      "        return v\n",
      "class FileSearch(BaseModel):\n",
      "    type: str = \"file_search\"\n",
      "\n",
      "    file_search: Optional[FileSearchConfig] = None\n",
      "\n",
      "    class Config:\n",
      "        exclude_none = True\n"
    ],
    "startline": 1,
    "endline": 18
  },
  {
    "path": "agency_swarm/tools/oai/Retrieval.py",
    "code": [
      "from pydantic import BaseModel\n",
      "\n",
      "\n",
      "class Retrieval(BaseModel):\n",
      "    type: str = \"file_search\""
    ],
    "startline": 1,
    "endline": 5
  },
  {
    "path": "agency_swarm/tools/oai/__init__.py",
    "code": [
      "from .CodeInterpreter import CodeInterpreter\n",
      "from .FileSearch import FileSearch\n",
      "from .Retrieval import Retrieval\n"
    ],
    "startline": 1,
    "endline": 3
  },
  {
    "path": "agency_swarm/user/user.py",
    "code": [
      "class User:\n",
      "    name: str = \"User\"\n",
      "\n",
      "    def __init__(self, name: str = None):\n",
      "        # later, we can add more attributes to the user like bio, etc\n",
      "        pass\n"
    ],
    "startline": 1,
    "endline": 6
  },
  {
    "path": "agency_swarm/user/__init__.py",
    "code": [
      "from .user import User"
    ],
    "startline": 1,
    "endline": 1
  },
  {
    "path": "agency_swarm/util/errors.py",
    "code": [
      "class RefusalError(Exception):\n",
      "    pass"
    ],
    "startline": 1,
    "endline": 2
  },
  {
    "path": "agency_swarm/util/files.py",
    "code": [
      "import mimetypes\n",
      "\n",
      "image_types = [\n",
      "    \"image/jpeg\", \"image/jpg\", \"image/png\", \"image/webp\", \"image/gif\"\n",
      "]\n",
      "\n",
      "code_interpreter_types = [\n",
      "    \"application/csv\", \"image/jpeg\", \"image/gif\", \"image/png\",\n",
      "    \"application/x-tar\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n",
      "    \"application/xml\", \"text/xml\", \"application/zip\"\n",
      "]\n",
      "\n",
      "dual_types = [\n",
      "    \"text/x-c\", \"text/x-csharp\", \"text/x-c++\", \"application/msword\",\n",
      "    \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n",
      "    \"text/html\", \"text/x-java\", \"application/json\", \"text/markdown\",\n",
      "    \"application/pdf\", \"text/x-php\",\n",
      "    \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n",
      "    \"text/x-python\", \"text/x-script.python\", \"text/x-ruby\", \"text/x-tex\",\n",
      "    \"text/plain\", \"text/css\", \"text/javascript\", \"application/x-sh\",\n",
      "    \"application/typescript\"\n",
      "]\n",
      "\n",
      "def get_file_purpose(file_path):\n",
      "    mime_type, _ = mimetypes.guess_type(file_path)\n",
      "    if mime_type:\n",
      "        if mime_type in image_types:\n",
      "            return \"vision\"\n",
      "        if mime_type in code_interpreter_types or mime_type in dual_types:\n",
      "            return \"assistants\"\n",
      "    raise ValueError(f\"Unsupported file type: {mime_type}\")\n",
      "\n",
      "def get_tools(file_path):\n",
      "    \"\"\"Returns the tools for the given file path\"\"\"\n",
      "    mime_type, _ = mimetypes.guess_type(file_path)\n",
      "    if mime_type in code_interpreter_types:\n",
      "        return [{\"type\": \"code_interpreter\"}]\n",
      "    elif mime_type in dual_types:\n",
      "        return [{\"type\": \"code_interpreter\"}, {\"type\": \"retrieval\"}]\n",
      "    else:\n",
      "        raise ValueError(f\"Unsupported file type: {mime_type}\")"
    ],
    "startline": 1,
    "endline": 41
  },
  {
    "path": "agency_swarm/util/oai.py",
    "code": [
      "import httpx\n",
      "import openai\n",
      "import threading\n",
      "import os\n",
      "\n",
      "from dotenv import load_dotenv\n",
      "\n",
      "load_dotenv()\n",
      "\n",
      "client_lock = threading.Lock()\n",
      "client = None\n",
      "\n",
      "\n",
      "def get_openai_client():\n",
      "    global client\n",
      "    with client_lock:\n",
      "        if client is None:\n",
      "            # Check if the API key is set\n",
      "            api_key = openai.api_key or os.getenv('OPENAI_API_KEY')\n",
      "            if api_key is None:\n",
      "                raise ValueError(\"OpenAI API key is not set. Please set it using set_openai_key.\")\n",
      "            client = openai.OpenAI(api_key=api_key,\n",
      "                                   timeout=httpx.Timeout(60.0, read=40, connect=5.0),\n",
      "                                   max_retries=10,\n",
      "                                   default_headers={\"OpenAI-Beta\": \"assistants=v2\"})\n",
      "    return client\n",
      "\n",
      "\n",
      "def set_openai_client(new_client):\n",
      "    global client\n",
      "    with client_lock:\n",
      "        client = new_client\n",
      "\n",
      "\n",
      "def set_openai_key(key):\n",
      "    if not key:\n",
      "        raise ValueError(\"Invalid API key. The API key cannot be empty.\")\n",
      "    openai.api_key = key\n",
      "    global client\n",
      "    with client_lock:\n",
      "        client = None\n"
    ],
    "startline": 1,
    "endline": 41
  },
  {
    "path": "agency_swarm/util/openapi.py",
    "code": [
      "import json\n",
      "\n",
      "\n",
      "def validate_openapi_spec(spec: str):\n",
      "    spec = json.loads(spec)\n",
      "\n",
      "    # Validate that 'paths' is present in the spec\n",
      "    if 'paths' not in spec:\n",
      "        raise ValueError(\"The spec must contain 'paths'.\")\n",
      "\n",
      "    for path, path_item in spec['paths'].items():\n",
      "        # Ensure each path item is a dictionary\n",
      "        if not isinstance(path_item, dict):\n",
      "            raise ValueError(f\"Path item for '{path}' must be a dictionary.\")\n",
      "\n",
      "        for operation in path_item.values():\n",
      "            # Basic validation for each operation\n",
      "            if 'operationId' not in operation:\n",
      "                raise ValueError(\"Each operation must contain an 'operationId'.\")\n",
      "            if 'description' not in operation:\n",
      "                raise ValueError(\"Each operation must contain a 'description'.\")\n",
      "\n",
      "    # Perform any additional basic validation as needed\n",
      "\n",
      "    # If the function reaches this point, the spec has passed basic validation\n",
      "    return spec"
    ],
    "startline": 1,
    "endline": 26
  },
  {
    "path": "agency_swarm/util/schema.py",
    "code": [
      "from typing import Dict, Any\n",
      "\n",
      "\n",
      "def dereference_schema(schema):\n",
      "    defs = schema.get(\"parameters\", {}).get(\"$defs\", {})\n",
      "\n",
      "    def resolve_refs(node):\n",
      "        if isinstance(node, dict):\n",
      "            if '$ref' in node:\n",
      "                ref_path = node['$ref']\n",
      "                ref_path_parts = ref_path.split('/')\n",
      "                ref = defs.get(ref_path_parts[-1], {})\n",
      "                return ref\n",
      "            else:\n",
      "                return {k: resolve_refs(v) for k, v in node.items()}\n",
      "        elif isinstance(node, list):\n",
      "            return [resolve_refs(element) for element in node]\n",
      "        else:\n",
      "            return node\n",
      "\n",
      "    return resolve_refs(schema)\n",
      "\n",
      "\n",
      "def reference_schema(schema):\n",
      "    # Enhanced function to only extract nested properties into $defs\n",
      "\n",
      "    def find_and_extract_defs(node, defs, parent_key=None, path_prefix=\"#/$defs/\"):\n",
      "        if isinstance(node, dict):\n",
      "            # Extract nested properties into $defs\n",
      "            if parent_key == 'properties' and 'properties' in node and isinstance(node['properties'], dict):\n",
      "                def_name = node.get('title', None)\n",
      "                if def_name:\n",
      "                    defs[def_name] = node\n",
      "                    return {\"$ref\": path_prefix + def_name}\n",
      "\n",
      "            # Recursively process the dictionary\n",
      "            return {k: find_and_extract_defs(v, defs, parent_key=k) for k, v in node.items()}\n",
      "        elif isinstance(node, list):\n",
      "            # Recursively process the list\n",
      "            return [find_and_extract_defs(element, defs, parent_key) for element in node]\n",
      "        else:\n",
      "            return node\n",
      "\n",
      "    defs = {}\n",
      "    # Extract definitions and update the schema\n",
      "    new_schema = {k: find_and_extract_defs(v, defs) for k, v in schema.items()}\n",
      "    if defs:\n",
      "        new_schema['parameters'] = new_schema.get('parameters', {})\n",
      "        new_schema['parameters']['$defs'] = defs\n",
      "    return new_schema\n",
      "\n",
      "\n",
      "\n"
    ],
    "startline": 1,
    "endline": 53
  },
  {
    "path": "agency_swarm/util/shared_state.py",
    "code": [
      "class SharedState:\n",
      "    def __init__(self):\n",
      "        self.data = {}\n",
      "\n",
      "    def set(self, key, value):\n",
      "        if not isinstance(key, str):\n",
      "            raise ValueError(\"Key must be a string\")\n",
      "        self.data[key] = value\n",
      "\n",
      "    def get(self, key, default=None):\n",
      "        if not isinstance(key, str):\n",
      "            raise ValueError(\"Key must be a string\")\n",
      "        return self.data.get(key, default)\n",
      "\n",
      "    def print_data(self):\n",
      "        for key, value in self.data.items():\n",
      "            print(f\"{key}: {value}\")"
    ],
    "startline": 1,
    "endline": 17
  },
  {
    "path": "agency_swarm/util/streaming.py",
    "code": [
      "from abc import ABC\n",
      "\n",
      "from openai.lib.streaming import AssistantEventHandler\n",
      "\n",
      "\n",
      "class AgencyEventHandler(AssistantEventHandler, ABC):\n",
      "    agent_name = None\n",
      "    recipient_agent_name = None\n",
      "    agent = None\n",
      "    recipient_agent = None\n",
      "\n",
      "    @classmethod\n",
      "    def on_all_streams_end(cls):\n",
      "        \"\"\"Fires when streams for all agents have ended, as there can be multiple if you're agents are communicating\n",
      "        with each other or using tools.\"\"\"\n",
      "        pass\n",
      "\n",
      "    @classmethod\n",
      "    def set_agent(cls, value):\n",
      "        cls.agent = value\n",
      "        cls.agent_name = value.name if value else None\n",
      "\n",
      "    @classmethod\n",
      "    def set_recipient_agent(cls, value):\n",
      "        cls.recipient_agent = value\n",
      "        cls.recipient_agent_name = value.name if value else None\n"
    ],
    "startline": 1,
    "endline": 26
  },
  {
    "path": "agency_swarm/util/validators.py",
    "code": [
      "from openai import OpenAI\n",
      "from typing import Callable\n",
      "from pydantic import Field, BaseModel\n",
      "from agency_swarm.util.oai import get_openai_client\n",
      "\n",
      "class Validator(BaseModel):\n",
      "    \"\"\"\n",
      "    Validate if an attribute is correct and if not,\n",
      "    return a new value with an error message\n",
      "    \"\"\"\n",
      "    reason: str = Field(..., description=\"Step-by-step reasoning why the attribute could be valid or not with a conclussion at the end.\")\n",
      "    is_valid: bool = Field(..., description=\"Whether the attribute is valid based on the requirements.\")\n",
      "    fixed_value: str = Field(..., description=\"If the attribute is not valid, suggest a new value for the attribute. Otherwise, leave it empty.\")\n",
      "\n",
      "def llm_validator(\n",
      "    statement: str,\n",
      "    client: OpenAI=None,\n",
      "    allow_override: bool = False,\n",
      "    model: str = \"gpt-4o-mini\",\n",
      "    temperature: float = 0,\n",
      ") -> Callable[[str], str]:\n",
      "    \"\"\"\n",
      "    Create a validator that uses the LLM to validate an attribute\n",
      "\n",
      "    ## Usage\n",
      "\n",
      "    ```python\n",
      "    from agency_swarm import llm_validator\n",
      "    from pydantic import Field, field_validator\n",
      "\n",
      "    class User(BaseTool):\n",
      "        name: str = Annotated[str, llm_validator(\"The name must be a full name all lowercase\")\n",
      "        age: int = Field(description=\"The age of the person\")\n",
      "\n",
      "    try:\n",
      "        user = User(name=\"Jason Liu\", age=20)\n",
      "    except ValidationError as e:\n",
      "        print(e)\n",
      "    ```\n",
      "\n",
      "    ```\n",
      "    1 validation error for User\n",
      "    name\n",
      "        The name is valid but not all lowercase (type=value_error.llm_validator)\n",
      "    ```\n",
      "\n",
      "    Note that there, the error message is written by the LLM, and the error type is `value_error.llm_validator`.\n",
      "\n",
      "    Parameters:\n",
      "        statement (str): The statement to validate\n",
      "        model (str): The LLM to use for validation. Must be compatible with structured outputs. (default: \"gpt-4o-mini\")\n",
      "        temperature (float): The temperature to use for the LLM (default: 0)\n",
      "        openai_client (OpenAI): The OpenAI client to use (default: None)\n",
      "    \"\"\"\n",
      "    if client is None:\n",
      "        client = get_openai_client()\n",
      "\n",
      "    def llm(v: str) -> str:\n",
      "        resp = client.beta.chat.completions.parse(\n",
      "            response_format=Validator,\n",
      "            messages=[\n",
      "                {\n",
      "                    \"role\": \"system\",\n",
      "                    \"content\": \"You are a world class validation model, capable to determine if the following value is valid or not for a given statement. Before providing a response, you must think step by step about the validation.\",\n",
      "                },\n",
      "                {\n",
      "                    \"role\": \"user\",\n",
      "                    \"content\": f\"Does `{v}` follow the rules: {statement}\",\n",
      "                },\n",
      "            ],\n",
      "            model=model,\n",
      "            temperature=temperature,\n",
      "        )\n",
      "\n",
      "        if resp.choices[0].message.refusal:\n",
      "            raise ValueError(resp.choices[0].message.refusal)\n",
      "\n",
      "        resp = resp.choices[0].message.parsed\n",
      "\n",
      "        # If the response is  not valid, return the reason, this could be used in\n",
      "        # the future to generate a better response, via reasking mechanism.\n",
      "        assert resp.is_valid, resp.reason\n",
      "\n",
      "        if allow_override and not resp.is_valid and resp.fixed_value is not None:\n",
      "            # If the value is not valid, but we allow override, return the fixed value\n",
      "            return resp.fixed_value\n",
      "        return v\n",
      "\n",
      "    return llm"
    ],
    "startline": 1,
    "endline": 89
  },
  {
    "path": "agency_swarm/util/__init__.py",
    "code": [
      "from .cli.create_agent_template import create_agent_template\n",
      "from .cli.import_agent import import_agent\n",
      "from .oai import set_openai_key, get_openai_client, set_openai_client\n",
      "from .files import get_tools, get_file_purpose\n",
      "from .validators import llm_validator"
    ],
    "startline": 1,
    "endline": 5
  },
  {
    "path": "agency_swarm/util/cli/create_agent_template.py",
    "code": [
      "import os\n",
      "\n",
      "\n",
      "def create_agent_template(agent_name=None,\n",
      "                          agent_description=None,\n",
      "                          path=\"./\",\n",
      "                          instructions=None,\n",
      "                          code_interpreter=False,\n",
      "                          use_txt=False,\n",
      "                          include_example_tool=True):\n",
      "    if not agent_name:\n",
      "        agent_name = input(\"Enter agent name: \")\n",
      "    if not agent_description:\n",
      "        agent_description = input(\"Enter agent description: \")\n",
      "\n",
      "    class_name = agent_name.replace(\" \", \"\").strip()\n",
      "\n",
      "    # create folder\n",
      "    path = os.path.join(path, class_name) + \"/\"\n",
      "    if os.path.isdir(path):\n",
      "        raise Exception(\"Folder already exists.\")\n",
      "    os.mkdir(path)\n",
      "\n",
      "    # create agent file\n",
      "    with open(path + class_name + \".py\", \"w\") as f:\n",
      "        f.write(agent_template.format(\n",
      "            class_name=class_name,\n",
      "            agent_name=agent_name,\n",
      "            agent_description=agent_description,\n",
      "            ext=\"md\" if not use_txt else \"txt\",\n",
      "            code_interpreter=\"CodeInterpreter\" if code_interpreter else \"\",\n",
      "            code_interpreter_import=\"from agency_swarm.tools import CodeInterpreter\" if code_interpreter else \"\"\n",
      "        ))\n",
      "\n",
      "    with open(path + \"__init__.py\", \"w\") as f:\n",
      "        f.write(f\"from .{class_name} import {class_name}\")\n",
      "\n",
      "    # create instructions file\n",
      "    instructions_path = \"instructions.md\" if not use_txt else \"instructions.txt\"\n",
      "    with open(path + instructions_path, \"w\") as f:\n",
      "        if instructions:\n",
      "            f.write(instructions)\n",
      "        else:\n",
      "            f.write(f\"# {agent_name} Instructions\\n\\n\")\n",
      "\n",
      "    # create files folder\n",
      "    os.mkdir(path + \"files\")\n",
      "    os.mkdir(path + \"schemas\")\n",
      "    os.mkdir(path + \"tools\")\n",
      "\n",
      "    # with open(path + \"tools/\" + \"__init__.py\", \"w\") as f:\n",
      "    #     f.write(\"\")\n",
      "\n",
      "    if include_example_tool:\n",
      "        with open(path + \"tools/\" + \"ExampleTool.py\", \"w\") as f:\n",
      "            f.write(example_tool_template)\n",
      "\n",
      "    print(\"Agent folder created successfully.\")\n",
      "    print(f\"Import it with: from {class_name} import {class_name}\")\n",
      "\n",
      "\n",
      "agent_template = \"\"\"from agency_swarm.agents import Agent\n",
      "{code_interpreter_import}\n",
      "\n",
      "class {class_name}(Agent):\n",
      "    def __init__(self):\n",
      "        super().__init__(\n",
      "            name=\"{agent_name}\",\n",
      "            description=\"{agent_description}\",\n",
      "            instructions=\"./instructions.{ext}\",\n",
      "            files_folder=\"./files\",\n",
      "            schemas_folder=\"./schemas\",\n",
      "            tools=[{code_interpreter}],\n",
      "            tools_folder=\"./tools\",\n",
      "            temperature=0.3,\n",
      "            max_prompt_tokens=25000,\n",
      "        )\n",
      "        \n",
      "    def response_validator(self, message):\n",
      "        return message\n",
      "\"\"\"\n",
      "\n",
      "example_tool_template = \"\"\"from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field\n",
      "import os\n",
      "\n",
      "account_id = \"MY_ACCOUNT_ID\"\n",
      "api_key = os.getenv(\"MY_API_KEY\") # or access_token = os.getenv(\"MY_ACCESS_TOKEN\")\n",
      "\n",
      "class ExampleTool(BaseTool):\n",
      "    \\\"\\\"\\\"\n",
      "    A brief description of what the custom tool does.\n",
      "    The docstring should clearly explain the tool's purpose and functionality.\n",
      "    It will be used by the agent to determine when to use this tool.\n",
      "    \\\"\\\"\\\"\n",
      "\n",
      "    # Define the fields with descriptions using Pydantic Field\n",
      "    example_field: str = Field(\n",
      "        ..., description=\"Description of the example field, explaining its purpose and usage for the Agent.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        \\\"\\\"\\\"\n",
      "        The implementation of the run method, where the tool's main functionality is executed.\n",
      "        This method should utilize the fields defined above to perform the task.\n",
      "        Docstring is not required for this method and will not be used by the agent.\n",
      "        \\\"\\\"\\\"\n",
      "        # Your custom tool logic goes here\n",
      "        # do_something(self.example_field, api_key, account_id)\n",
      "\n",
      "        # Return the result of the tool's operation as a string\n",
      "        return \"Result of ExampleTool operation\"\n",
      "\"\"\"\n"
    ],
    "startline": 1,
    "endline": 113
  },
  {
    "path": "agency_swarm/util/cli/import_agent.py",
    "code": [
      "import os\n",
      "import shutil\n",
      "from importlib import resources  # For Python 3.9+ use importlib.resources\n",
      "\n",
      "\n",
      "def import_agent(agent_name, destination):\n",
      "    \"\"\"\n",
      "    Copies the specified agent files from the package to a specified destination directory,\n",
      "    preserving the folder structure.\n",
      "    \"\"\"\n",
      "    package = 'agency_swarm.agents'\n",
      "\n",
      "    # Construct the destination path for the agent\n",
      "    agent_destination = os.path.join(destination, agent_name)\n",
      "    if not os.path.exists(agent_destination):\n",
      "        os.makedirs(agent_destination, exist_ok=True)\n",
      "\n",
      "    try:\n",
      "        # Using importlib.resources.files to get a reference to the directory\n",
      "        agent_folder = resources.files(package) / agent_name\n",
      "\n",
      "        # Copy each item in the directory to the destination\n",
      "        for item in agent_folder.iterdir():\n",
      "            source_path = item\n",
      "            destination_path = os.path.join(agent_destination, item.name)\n",
      "\n",
      "            if item.is_dir():\n",
      "                shutil.copytree(source_path, destination_path, dirs_exist_ok=True)\n",
      "            else:\n",
      "                shutil.copy2(source_path, destination_path)\n",
      "\n",
      "        print(f\"Agent '{agent_name}' copied to: {agent_destination}\")\n",
      "    except Exception as e:\n",
      "        print(f\"Error importing agent '{agent_name}'. Most likely the agent name is wrong. Error: {e}\")\n"
    ],
    "startline": 1,
    "endline": 34
  },
  {
    "path": "agency_swarm/util/cli/__init__.py",
    "code": [
      "from .create_agent_template import create_agent_template\n",
      "from .import_agent import import_agent\n"
    ],
    "startline": 1,
    "endline": 2
  },
  {
    "path": "agency_swarm/util/helpers/get_available_agent_descriptions.py",
    "code": [
      "import importlib\n",
      "from pathlib import Path\n",
      "import re\n",
      "from .list_available_agents import list_available_agents\n",
      "\n",
      "def extract_description_from_file(file_path):\n",
      "    \"\"\"\n",
      "    Extracts the agent's description from its Python file.\n",
      "    \"\"\"\n",
      "    description_pattern = re.compile(\n",
      "        r'\\s*description\\s*=\\s*[\"\\'](.*?)[\"\\'],', re.DOTALL)\n",
      "    with open(file_path, 'r', encoding='utf-8') as file:\n",
      "        content = file.read()\n",
      "    match = description_pattern.search(content)\n",
      "    if match:\n",
      "        description = ' '.join(match.group(1).split())\n",
      "        return description\n",
      "    return \"Description not found.\"\n",
      "\n",
      "\n",
      "def get_available_agent_descriptions():\n",
      "    descriptions = {}\n",
      "\n",
      "    # Dynamically get the path of the agency_swarm.agents module\n",
      "    spec = importlib.util.find_spec(\"agency_swarm.agents\")\n",
      "    if spec is None or spec.origin is None:\n",
      "        raise ImportError(\"Could not locate 'agency_swarm.agents' module.\")\n",
      "    agents_path = Path(spec.origin).parent\n",
      "\n",
      "    agents = list_available_agents()\n",
      "    for agent_name in agents:\n",
      "        agent_file_path = agents_path / agent_name / f\"{agent_name}.py\"\n",
      "\n",
      "        # Check if the agent file exists before trying to extract the description\n",
      "        if agent_file_path.exists():\n",
      "            descriptions[agent_name] = extract_description_from_file(agent_file_path)\n",
      "        else:\n",
      "            print(f\"Could not find the file for agent '{agent_name}'.\")\n",
      "\n",
      "    agent_descriptions = \"Available agents:\\n\\n\"\n",
      "    for name, desc in descriptions.items():\n",
      "        agent_descriptions += f\"'{name}': {desc}\\n\"\n",
      "\n",
      "    return agent_descriptions"
    ],
    "startline": 1,
    "endline": 44
  },
  {
    "path": "agency_swarm/util/helpers/list_available_agents.py",
    "code": [
      "import os\n",
      "from importlib import resources\n",
      "def list_available_agents(package='agency_swarm.agents'):\n",
      "    \"\"\"\n",
      "    Lists available agents within the specified package directory.\n",
      "\n",
      "    :param package: The package containing the agents directory.\n",
      "    :return: A list of available agent names (subdirectories).\n",
      "    \"\"\"\n",
      "    available_agents = []\n",
      "\n",
      "    # Use resources.files to access the package directory\n",
      "    try:\n",
      "        # For Python 3.9 and newer\n",
      "        package_dir = resources.files(package)\n",
      "    except AttributeError:\n",
      "        # Fallback for Python 3.7 and 3.8 where resources.files is not available\n",
      "        # This requires the importlib_resources backport\n",
      "        from importlib_resources import files as package_files\n",
      "        package_dir = package_files(package)\n",
      "\n",
      "    # List the contents of the agents directory\n",
      "    if package_dir.is_dir():\n",
      "        for entry in package_dir.iterdir():\n",
      "            if entry.is_dir() and not entry.name.startswith(('.', '_')):\n",
      "                available_agents.append(entry.name)\n",
      "\n",
      "    return available_agents"
    ],
    "startline": 1,
    "endline": 28
  },
  {
    "path": "agency_swarm/util/helpers/__init__.py",
    "code": [
      "from .get_available_agent_descriptions import get_available_agent_descriptions\n",
      "from .list_available_agents import list_available_agents"
    ],
    "startline": 1,
    "endline": 2
  },
  {
    "path": "tests/test_agency.py",
    "code": [
      "import inspect\n",
      "import json\n",
      "import os\n",
      "import shutil\n",
      "import sys\n",
      "import time\n",
      "from typing import ClassVar\n",
      "import unittest\n",
      "\n",
      "from openai.types.beta.threads import Text\n",
      "from openai.types.beta.threads.runs import ToolCall\n",
      "\n",
      "from agency_swarm.tools import CodeInterpreter, FileSearch\n",
      "\n",
      "sys.path.insert(0, '../agency-swarm')\n",
      "from agency_swarm.util import create_agent_template\n",
      "\n",
      "from agency_swarm import set_openai_key, Agent, Agency, AgencyEventHandler, get_openai_client\n",
      "from typing_extensions import override\n",
      "from agency_swarm.tools import BaseTool, ToolFactory\n",
      "\n",
      "from pydantic import BaseModel\n",
      "\n",
      "os.environ[\"DEBUG_MODE\"] = \"True\"\n",
      "\n",
      "class AgencyTest(unittest.TestCase):\n",
      "    TestTool = None\n",
      "    agency = None\n",
      "    agent2 = None\n",
      "    agent1 = None\n",
      "    ceo = None\n",
      "    num_schemas = None\n",
      "    num_files = None\n",
      "    client = None\n",
      "\n",
      "    # testing loading agents from db\n",
      "    loaded_thread_ids = None\n",
      "    loaded_agents_settings = None\n",
      "    settings_callbacks = None\n",
      "    threads_callbacks = None\n",
      "\n",
      "    @classmethod\n",
      "    def setUpClass(cls):\n",
      "        cls.num_files = 0\n",
      "        cls.num_schemas = 0\n",
      "        cls.ceo = None\n",
      "        cls.agent1 = None\n",
      "        cls.agent2 = None\n",
      "        cls.agency = None\n",
      "        cls.client = get_openai_client()\n",
      "\n",
      "        # testing loading agents from db\n",
      "        cls.loaded_thread_ids = {}\n",
      "        cls.loaded_agents_settings = []\n",
      "\n",
      "        def save_settings_callback(settings):\n",
      "            cls.loaded_agents_settings = settings\n",
      "\n",
      "        cls.settings_callbacks = {\n",
      "            \"load\": lambda: cls.loaded_agents_settings,\n",
      "            \"save\": save_settings_callback,\n",
      "        }\n",
      "\n",
      "        def save_thread_callback(agents_and_thread_ids):\n",
      "            cls.loaded_thread_ids = agents_and_thread_ids\n",
      "\n",
      "        cls.threads_callbacks = {\n",
      "            \"load\": lambda: cls.loaded_thread_ids,\n",
      "            \"save\": save_thread_callback,\n",
      "        }\n",
      "\n",
      "        if not os.path.exists(\"./test_agents\"):\n",
      "            os.mkdir(\"./test_agents\")\n",
      "        else:\n",
      "            shutil.rmtree(\"./test_agents\")\n",
      "            os.mkdir(\"./test_agents\")\n",
      "\n",
      "        # create init file\n",
      "        with open(\"./test_agents/__init__.py\", \"w\") as f:\n",
      "            f.write(\"\")\n",
      "\n",
      "        # create agent templates in test_agents\n",
      "        create_agent_template(\"CEO\", \"CEO Test Agent\", path=\"./test_agents\",\n",
      "                              instructions=\"Your task is to tell TestAgent1 to say test to another test agent. If the \"\n",
      "                                           \"agent, does not respond or something goes wrong please say 'error' and \"\n",
      "                                           \"nothing else. Otherwise say 'success' and nothing else.\",\n",
      "                              include_example_tool=True)\n",
      "        create_agent_template(\"TestAgent1\", \"Test Agent 1\", path=\"./test_agents\",\n",
      "                              instructions=\"Your task is to say test to another test agent using SendMessage tool. \"\n",
      "                                           \"If the agent, does not \"\n",
      "                                           \"respond or something goes wrong please say 'error' and nothing else. \"\n",
      "                                           \"Otherwise say 'success' and nothing else.\", code_interpreter=True,\n",
      "                              include_example_tool=False)\n",
      "        create_agent_template(\"TestAgent2\", \"Test Agent 2\", path=\"./test_agents\",\n",
      "                              instructions=\"After using TestTool, please respond to the user that test was a success in JSON format. You can use the following format: {'test': 'success'}.\",\n",
      "                              include_example_tool=False)\n",
      "\n",
      "        sys.path.insert(0, './test_agents')\n",
      "\n",
      "        # copy files from data/files to test_agents/TestAgent1/files\n",
      "        for file in os.listdir(\"./data/files\"):\n",
      "            shutil.copyfile(\"./data/files/\" + file, \"./test_agents/TestAgent1/files/\" + file)\n",
      "            cls.num_files += 1\n",
      "\n",
      "        # copy schemas from data/schemas to test_agents/TestAgent2/schemas\n",
      "        for file in os.listdir(\"./data/schemas\"):\n",
      "            shutil.copyfile(\"./data/schemas/\" + file, \"./test_agents/TestAgent2/schemas/\" + file)\n",
      "            cls.num_schemas += 1\n",
      "\n",
      "        class TestTool(BaseTool):\n",
      "            \"\"\"\n",
      "            A simple test tool that returns \"Test Successful\" to demonstrate the functionality of a custom tool within the Agency Swarm framework.\n",
      "            \"\"\"\n",
      "            class ToolConfig:\n",
      "                strict = True\n",
      "\n",
      "            def run(self):\n",
      "                \"\"\"\n",
      "                Executes the test tool's main functionality. In this case, it simply returns a success message.\n",
      "                \"\"\"\n",
      "                self._shared_state.set(\"test_tool_used\", True)\n",
      "\n",
      "                return \"Test Successful\"\n",
      "\n",
      "        cls.TestTool = TestTool\n",
      "\n",
      "        from test_agents.CEO import CEO\n",
      "        from test_agents.TestAgent1 import TestAgent1\n",
      "        from test_agents.TestAgent2 import TestAgent2\n",
      "        cls.agent1 = TestAgent1()\n",
      "        cls.agent1.add_tool(FileSearch)\n",
      "        cls.agent1.truncation_strategy = {\n",
      "            \"type\": \"last_messages\",\n",
      "            \"last_messages\": 10\n",
      "        }\n",
      "        cls.agent1.file_search = {'max_num_results': 49}\n",
      "\n",
      "        cls.agent2 = TestAgent2()\n",
      "        cls.agent2.add_tool(cls.TestTool)\n",
      "\n",
      "        cls.agent2.response_format = {\n",
      "            \"type\": \"json_object\",\n",
      "        }\n",
      "\n",
      "        cls.agent2.model=\"gpt-4o-2024-08-06\"\n",
      "\n",
      "        cls.ceo = CEO()\n",
      "        cls.ceo.examples = [\n",
      "            {\n",
      "                \"role\": \"user\",\n",
      "                \"content\": \"Hi!\"\n",
      "            },\n",
      "            {\n",
      "                \"role\": \"assistant\",\n",
      "                \"content\": \"Hi! I am the CEO. I am here to help you with your testing. Please tell me who to send message to.\"\n",
      "            }\n",
      "        ]\n",
      "\n",
      "        cls.ceo.max_completion_tokens = 100\n",
      "\n",
      "    def test_1_init_agency(self):\n",
      "        \"\"\"it should initialize agency with agents\"\"\"\n",
      "        self.__class__.agency = Agency([\n",
      "            self.__class__.ceo,\n",
      "            [self.__class__.ceo, self.__class__.agent1],\n",
      "            [self.__class__.agent1, self.__class__.agent2]],\n",
      "            shared_instructions=\"This is a shared instruction\",\n",
      "            settings_callbacks=self.__class__.settings_callbacks,\n",
      "            threads_callbacks=self.__class__.threads_callbacks,\n",
      "            temperature=0,\n",
      "        )\n",
      "\n",
      "        self.assertTrue(self.__class__.TestTool.openai_schema[\"strict\"])\n",
      "\n",
      "        self.check_all_agents_settings()\n",
      "\n",
      "    def test_2_load_agent(self):\n",
      "        \"\"\"it should load existing assistant from settings\"\"\"\n",
      "        from test_agents.TestAgent1 import TestAgent1\n",
      "        agent3 = TestAgent1()\n",
      "        agent3.add_shared_instructions(self.__class__.agency.shared_instructions)\n",
      "        agent3.tools = self.__class__.agent1.tools\n",
      "        agent3.top_p = self.__class__.agency.top_p\n",
      "        agent3.file_search = self.__class__.agent1.file_search\n",
      "        agent3 = agent3.init_oai()\n",
      "\n",
      "        print(\"agent3\", agent3.assistant.model_dump())\n",
      "        print(\"agent1\", self.__class__.agent1.assistant.model_dump())\n",
      "\n",
      "        self.assertTrue(self.__class__.agent1.id == agent3.id)\n",
      "\n",
      "        # check that assistant settings match\n",
      "        self.assertTrue(agent3._check_parameters(self.__class__.agent1.assistant.model_dump()))\n",
      "\n",
      "        self.check_agent_settings(agent3)\n",
      "\n",
      "    def test_3_load_agent_id(self):\n",
      "        \"\"\"it should load existing assistant from id\"\"\"\n",
      "        from test_agents import TestAgent1\n",
      "        agent3 = Agent(id=self.__class__.agent1.id)\n",
      "        agent3.tools = self.__class__.agent1.tools\n",
      "        agent3.file_search = self.__class__.agent1.file_search\n",
      "        agent3 = agent3.init_oai()\n",
      "\n",
      "        print(\"agent3\", agent3.assistant.model_dump())\n",
      "        print(\"agent1\", self.__class__.agent1.assistant.model_dump())\n",
      "\n",
      "        self.assertTrue(self.__class__.agent1.id == agent3.id)\n",
      "\n",
      "        # check that assistant settings match\n",
      "        self.assertTrue(agent3._check_parameters(self.__class__.agent1.assistant.model_dump()))\n",
      "\n",
      "        self.check_agent_settings(agent3)\n",
      "\n",
      "    def test_4_agent_communication(self):\n",
      "        \"\"\"it should communicate between agents\"\"\"\n",
      "        print(\"TestAgent1 tools\", self.__class__.agent1.tools)\n",
      "        self.__class__.agent1.parallel_tool_calls = False\n",
      "        message = self.__class__.agency.get_completion(\"Please tell TestAgent1 to say test to TestAgent2.\",\n",
      "                                                       tool_choice={\"type\": \"function\", \"function\": {\"name\": \"SendMessage\"}})\n",
      "\n",
      "        self.assertFalse('error' in message.lower(), f\"Error found in message: {message}\")\n",
      "\n",
      "        for agent_name, threads in self.__class__.agency.agents_and_threads.items():\n",
      "            for other_agent_name, thread in threads.items():\n",
      "                self.assertTrue(thread.id in self.__class__.loaded_thread_ids[agent_name][other_agent_name])\n",
      "\n",
      "        for agent in self.__class__.agency.agents:\n",
      "            self.assertTrue(agent.id in [settings['id'] for settings in self.__class__.loaded_agents_settings])\n",
      "\n",
      "        # assistants v2 checks\n",
      "        main_thread = self.__class__.agency.main_thread\n",
      "        main_thread_id = main_thread.id\n",
      "\n",
      "        thread_messages = self.__class__.client.beta.threads.messages.list(main_thread_id, limit=100, order=\"asc\")\n",
      "\n",
      "        self.assertTrue(len(thread_messages.data) == 4)\n",
      "\n",
      "        self.assertTrue(thread_messages.data[0].content[0].text.value == \"Hi!\")\n",
      "\n",
      "        run = main_thread.run\n",
      "        self.assertTrue(run.max_prompt_tokens == self.__class__.ceo.max_prompt_tokens)\n",
      "        self.assertTrue(run.max_completion_tokens == self.__class__.ceo.max_completion_tokens)\n",
      "        self.assertTrue(run.tool_choice.type == \"function\")\n",
      "\n",
      "        agent1_thread = self.__class__.agency.agents_and_threads[self.__class__.ceo.name][self.__class__.agent1.name]\n",
      "\n",
      "        agent1_thread_id = agent1_thread.id\n",
      "\n",
      "        agent1_thread_messages = self.__class__.client.beta.threads.messages.list(agent1_thread_id, limit=100)\n",
      "\n",
      "        self.assertTrue(len(agent1_thread_messages.data) == 2)\n",
      "\n",
      "        agent1_run = agent1_thread.run\n",
      "\n",
      "        self.assertTrue(agent1_run.truncation_strategy.type == \"last_messages\")\n",
      "        self.assertTrue(agent1_run.truncation_strategy.last_messages == 10)\n",
      "        self.assertFalse(agent1_run.parallel_tool_calls)\n",
      "\n",
      "        agent2_thread = self.__class__.agency.agents_and_threads[self.__class__.agent1.name][self.__class__.agent2.name]\n",
      "\n",
      "        agent2_message = agent2_thread._get_last_message_text()\n",
      "\n",
      "        try:\n",
      "            json.loads(agent2_message)\n",
      "        except json.JSONDecodeError as e:\n",
      "            self.assertTrue(False)\n",
      "\n",
      "    def test_5_agent_communication_stream(self):\n",
      "        \"\"\"it should communicate between agents using streaming\"\"\"\n",
      "        print(\"TestAgent1 tools\", self.__class__.agent1.tools)\n",
      "\n",
      "        test_tool_used = False\n",
      "        test_agent2_used = False\n",
      "        num_on_all_streams_end_calls = 0\n",
      "\n",
      "        class EventHandler(AgencyEventHandler):\n",
      "            @override\n",
      "            def on_text_created(self, text) -> None:\n",
      "                # get the name of the agent that is sending the message\n",
      "                if self.recipient_agent_name == \"TestAgent2\":\n",
      "                    nonlocal test_agent2_used\n",
      "                    test_agent2_used = True\n",
      "\n",
      "            def on_tool_call_done(self, tool_call: ToolCall) -> None:\n",
      "                if tool_call.function.name == \"TestTool\":\n",
      "                    nonlocal test_tool_used\n",
      "                    test_tool_used = True\n",
      "\n",
      "            @override\n",
      "            @classmethod\n",
      "            def on_all_streams_end(cls):\n",
      "                nonlocal num_on_all_streams_end_calls\n",
      "                num_on_all_streams_end_calls += 1\n",
      "\n",
      "        message = self.__class__.agency.get_completion_stream(\n",
      "            \"Please tell TestAgent1 to tell TestAgent2 to use TestTool.\",\n",
      "            event_handler=EventHandler,\n",
      "            additional_instructions=\"\\n\\n**Your message to TestAgent1 should be exactly as follows:** \"\n",
      "                                    \"'Please tell TestAgent2 to use TestTool.'\",\n",
      "            tool_choice={\"type\": \"function\", \"function\": {\"name\": \"SendMessage\"}})\n",
      "\n",
      "        # self.assertFalse('error' in message.lower())\n",
      "\n",
      "        self.assertTrue(test_tool_used)\n",
      "        self.assertTrue(test_agent2_used)\n",
      "        self.assertTrue(num_on_all_streams_end_calls == 1)\n",
      "\n",
      "        self.assertTrue(self.__class__.TestTool._shared_state.get(\"test_tool_used\"))\n",
      "\n",
      "        agent1_thread = self.__class__.agency.agents_and_threads[self.__class__.ceo.name][self.__class__.agent1.name]\n",
      "        self.assertFalse(agent1_thread.run.parallel_tool_calls)\n",
      "\n",
      "        for agent_name, threads in self.__class__.agency.agents_and_threads.items():\n",
      "            for other_agent_name, thread in threads.items():\n",
      "                self.assertTrue(thread.id in self.__class__.loaded_thread_ids[agent_name][other_agent_name])\n",
      "\n",
      "        for agent in self.__class__.agency.agents:\n",
      "            self.assertTrue(agent.id in [settings['id'] for settings in self.__class__.loaded_agents_settings])\n",
      "\n",
      "    def test_6_load_from_db(self):\n",
      "        \"\"\"it should load agents from db\"\"\"\n",
      "        # os.rename(\"settings.json\", \"settings2.json\")\n",
      "\n",
      "        previous_loaded_thread_ids = self.__class__.loaded_thread_ids\n",
      "        previous_loaded_agents_settings = self.__class__.loaded_agents_settings\n",
      "\n",
      "        from test_agents.CEO import CEO\n",
      "        from test_agents.TestAgent1 import TestAgent1\n",
      "        from test_agents.TestAgent2 import TestAgent2\n",
      "        agent1 = TestAgent1()\n",
      "        agent1.add_tool(FileSearch)\n",
      "\n",
      "        agent1.truncation_strategy = {\n",
      "            \"type\": \"last_messages\",\n",
      "            \"last_messages\": 10\n",
      "        }\n",
      "\n",
      "        agent1.file_search = {'max_num_results': 49}\n",
      "\n",
      "        agent2 = TestAgent2()\n",
      "        agent2.add_tool(self.__class__.TestTool)\n",
      "\n",
      "        agent2.response_format = {\n",
      "            \"type\": \"json_object\",\n",
      "        }\n",
      "\n",
      "        ceo = CEO()\n",
      "\n",
      "        # check that agents are loaded\n",
      "        agency = Agency([\n",
      "            ceo,\n",
      "            [ceo, agent1],\n",
      "            [agent1, agent2]],\n",
      "            shared_instructions=\"This is a shared instruction\",\n",
      "            settings_path=\"./settings2.json\",\n",
      "            settings_callbacks=self.__class__.settings_callbacks,\n",
      "            threads_callbacks=self.__class__.threads_callbacks,\n",
      "            temperature=0,\n",
      "        )\n",
      "\n",
      "        # check that settings are the same\n",
      "        self.assertTrue(len(agency.agents) == len(self.__class__.agency.agents))\n",
      "\n",
      "        os.remove(\"settings.json\")\n",
      "        os.rename(\"settings2.json\", \"settings.json\")\n",
      "\n",
      "        self.check_all_agents_settings()\n",
      "\n",
      "        # check that threads are the same\n",
      "        for agent_name, threads in agency.agents_and_threads.items():\n",
      "            for other_agent_name, thread in threads.items():\n",
      "                self.assertTrue(thread.id in self.__class__.loaded_thread_ids[agent_name][other_agent_name])\n",
      "                self.assertTrue(thread.id in previous_loaded_thread_ids[agent_name][other_agent_name])\n",
      "\n",
      "        # check that agents are the same\n",
      "        for agent in agency.agents:\n",
      "            self.assertTrue(agent.id in [settings['id'] for settings in self.__class__.loaded_agents_settings])\n",
      "            self.assertTrue(agent.id in [settings['id'] for settings in previous_loaded_agents_settings])\n",
      "\n",
      "    def test_7_init_async_agency(self):\n",
      "        \"\"\"it should initialize agency with agents\"\"\"\n",
      "        # reset loaded thread ids\n",
      "        self.__class__.loaded_thread_ids = {}\n",
      "\n",
      "        # Set ids for all agents to None\n",
      "        self.__class__.ceo.id = None\n",
      "        self.__class__.agent1.id = None\n",
      "        self.__class__.agent2.id = None\n",
      "\n",
      "        self.__class__.agent1.file_search = {'max_num_results': 49}\n",
      "\n",
      "        self.__class__.agency = Agency([\n",
      "            self.__class__.ceo,\n",
      "            [self.__class__.ceo, self.__class__.agent1],\n",
      "            [self.__class__.agent1, self.__class__.agent2]],\n",
      "            shared_instructions=\"\",\n",
      "            settings_callbacks=self.__class__.settings_callbacks,\n",
      "            threads_callbacks=self.__class__.threads_callbacks,\n",
      "            async_mode='threading',\n",
      "            temperature=0,\n",
      "        )\n",
      "\n",
      "        self.check_all_agents_settings(True)\n",
      "\n",
      "    def test_8_async_agent_communication(self):\n",
      "        \"\"\"it should communicate between agents asynchronously\"\"\"\n",
      "        print(\"TestAgent1 tools\", self.__class__.agent1.tools)\n",
      "        self.__class__.agency.get_completion(\"Please tell TestAgent2 hello.\",\n",
      "                                             tool_choice={\"type\": \"function\", \"function\": {\"name\": \"SendMessage\"}},\n",
      "                                             recipient_agent=self.__class__.agent1)\n",
      "\n",
      "        time.sleep(10)\n",
      "\n",
      "        num_on_all_streams_end_calls = 0\n",
      "        delta_value = \"\"\n",
      "        full_text = \"\"\n",
      "\n",
      "        class EventHandler(AgencyEventHandler):\n",
      "            @override\n",
      "            def on_text_delta(self, delta, snapshot):\n",
      "                nonlocal delta_value\n",
      "                delta_value += delta.value\n",
      "\n",
      "            @override\n",
      "            def on_text_done(self, text: Text) -> None:\n",
      "                nonlocal full_text\n",
      "                full_text += text.value\n",
      "\n",
      "            @override\n",
      "            @classmethod\n",
      "            def on_all_streams_end(cls):\n",
      "                nonlocal num_on_all_streams_end_calls\n",
      "                num_on_all_streams_end_calls += 1\n",
      "\n",
      "        message = self.__class__.agency.get_completion_stream(\n",
      "            \"Please check response. If output includes `TestAgent2's Response`, say 'success'. If the function output does not include `TestAgent2's Response`, or if you get a System Notification, or an error instead, say 'error'.\",\n",
      "            tool_choice={\"type\": \"function\", \"function\": {\"name\": \"GetResponse\"}},\n",
      "            recipient_agent=self.__class__.agent1,\n",
      "            event_handler=EventHandler)\n",
      "\n",
      "        self.assertTrue(num_on_all_streams_end_calls == 1)\n",
      "\n",
      "        self.assertTrue(delta_value == full_text == message)\n",
      "\n",
      "        self.assertTrue(EventHandler.agent_name == \"User\")\n",
      "        self.assertTrue(EventHandler.recipient_agent_name == \"TestAgent1\")\n",
      "\n",
      "        if 'error' in message.lower():\n",
      "            self.assertFalse('error' in message.lower(), self.__class__.agency.main_thread.thread_url)\n",
      "\n",
      "        for agent_name, threads in self.__class__.agency.agents_and_threads.items():\n",
      "            for other_agent_name, thread in threads.items():\n",
      "                self.assertTrue(thread.id in self.__class__.loaded_thread_ids[agent_name][other_agent_name])\n",
      "\n",
      "        for agent in self.__class__.agency.agents:\n",
      "            self.assertTrue(agent.id in [settings['id'] for settings in self.__class__.loaded_agents_settings])\n",
      "\n",
      "    def test_9_async_tool_calls(self):\n",
      "        \"\"\"it should execute tools asynchronously\"\"\"\n",
      "        class PrintTool(BaseTool):\n",
      "            def run(self, **kwargs):\n",
      "                time.sleep(2)  # Simulate a delay\n",
      "                return \"Printed successfully.\"\n",
      "\n",
      "        class AnotherPrintTool(BaseTool):\n",
      "            def run(self, **kwargs):\n",
      "                time.sleep(2)  # Simulate a delay\n",
      "                return \"Another print successful.\"\n",
      "            \n",
      "        ceo = Agent(name=\"CEO\", tools=[PrintTool, AnotherPrintTool])\n",
      "\n",
      "        agency = Agency(\n",
      "            [ceo],\n",
      "            async_mode='tools_threading',\n",
      "            temperature=0\n",
      "        )\n",
      "\n",
      "        self.assertTrue(agency.main_thread.async_mode == 'tools_threading')\n",
      "\n",
      "        result = agency.get_completion(\"Use 2 print tools together at the same time and output the results exectly as they are. \", yield_messages=False)\n",
      "\n",
      "        self.assertIn(\"success\", result.lower(), agency.main_thread.thread_url)\n",
      "        self.assertIn(\"success\", result.lower(), agency.main_thread.thread_url)\n",
      "\n",
      "    def test_10_concurrent_API_calls(self):\n",
      "        \"\"\"it should execute API calls concurrently with asyncio\"\"\"\n",
      "        tools = []\n",
      "        with open(\"./data/schemas/get-headers-params.json\", \"r\") as f:\n",
      "            tools = ToolFactory.from_openapi_schema(f.read(), {})\n",
      "\n",
      "        ceo = Agent(name=\"CEO\", tools=tools, instructions=\"You are an agent that tests concurrent API calls.\")\n",
      "\n",
      "        agency = Agency([ceo], temperature=0)\n",
      "\n",
      "        result = agency.get_completion(\"Please call PrintHeaders tool TWICE at the same time in a single message. If any of the function outputs do not contains headers, please say 'error'.\")\n",
      "\n",
      "        self.assertTrue(result.lower().count('error') == 0, agency.main_thread.thread_url)\n",
      "\n",
      "    def test_11_structured_outputs(self):\n",
      "        class MathReasoning(BaseModel):\n",
      "            class Step(BaseModel):\n",
      "                explanation: str\n",
      "                output: str\n",
      "\n",
      "            steps: list[Step]\n",
      "            final_answer: str\n",
      "\n",
      "        math_tutor_prompt = '''\n",
      "            You are a helpful math tutor. You will be provided with a math problem,\n",
      "            and your goal will be to output a step by step solution, along with a final answer.\n",
      "            For each step, just provide the output as an equation use the explanation field to detail the reasoning.\n",
      "        '''\n",
      "\n",
      "        agent = Agent(name=\"MathTutor\", response_format=MathReasoning, instructions=math_tutor_prompt)\n",
      "\n",
      "        agency = Agency([agent], temperature=0)\n",
      "\n",
      "        result = agency.get_completion(\"how can I solve 8x + 7 = -23\")\n",
      "\n",
      "        # check if result is a MathReasoning object\n",
      "        self.assertTrue(MathReasoning.model_validate_json(result))\n",
      "\n",
      "        result = agency.get_completion_parse(\"how can I solve 3x + 2 = 14\", response_format=MathReasoning)\n",
      "\n",
      "        # check if result is a MathReasoning object\n",
      "        self.assertTrue(isinstance(result, MathReasoning))\n",
      "\n",
      "    # --- Helper methods ---\n",
      "\n",
      "    def get_class_folder_path(self):\n",
      "        return os.path.abspath(os.path.dirname(inspect.getfile(self.__class__)))\n",
      "\n",
      "    def check_agent_settings(self, agent, async_mode=False):\n",
      "        try:\n",
      "            settings_path = agent.get_settings_path()\n",
      "            self.assertTrue(os.path.exists(settings_path))\n",
      "            with open(settings_path, 'r') as f:\n",
      "                settings = json.load(f)\n",
      "                for assistant_settings in settings:\n",
      "                    if assistant_settings['id'] == agent.id:\n",
      "                        self.assertTrue(agent._check_parameters(assistant_settings, debug=True))\n",
      "\n",
      "            assistant = agent.assistant\n",
      "            self.assertTrue(assistant)\n",
      "            self.assertTrue(agent._check_parameters(assistant.model_dump(), debug=True))\n",
      "            if agent.name == \"TestAgent1\":\n",
      "                num_tools = 3 if not async_mode else 4\n",
      "\n",
      "                self.assertTrue(len(assistant.tool_resources.model_dump()['code_interpreter']['file_ids']) == 3)\n",
      "                self.assertTrue(len(assistant.tool_resources.model_dump()['file_search']['vector_store_ids']) == 1)\n",
      "\n",
      "                vector_store_id = assistant.tool_resources.model_dump()['file_search']['vector_store_ids'][0]\n",
      "                vector_store_files = agent.client.beta.vector_stores.files.list(\n",
      "                    vector_store_id=vector_store_id\n",
      "                )\n",
      "\n",
      "                file_ids = [file.id for file in vector_store_files.data]\n",
      "\n",
      "                self.assertTrue(len(file_ids) == 5)\n",
      "                # check retrieval tools is there\n",
      "                self.assertTrue(len(assistant.tools) == num_tools)\n",
      "                self.assertTrue(len(agent.tools) == num_tools)\n",
      "                self.assertTrue(assistant.tools[0].type == \"code_interpreter\")\n",
      "                self.assertTrue(assistant.tools[1].type == \"file_search\")\n",
      "                if not async_mode:\n",
      "                    self.assertTrue(assistant.tools[1].file_search.max_num_results == 49)  # Updated line\n",
      "                self.assertTrue(assistant.tools[2].type == \"function\")\n",
      "                self.assertTrue(assistant.tools[2].function.name == \"SendMessage\")\n",
      "                self.assertFalse(assistant.tools[2].function.strict)\n",
      "                if async_mode:\n",
      "                    self.assertTrue(assistant.tools[3].type == \"function\")\n",
      "                    self.assertTrue(assistant.tools[3].function.name == \"GetResponse\")\n",
      "                    self.assertFalse(assistant.tools[3].function.strict)\n",
      "                \n",
      "            elif agent.name == \"TestAgent2\":\n",
      "                self.assertTrue(len(assistant.tools) == self.__class__.num_schemas + 1)\n",
      "                for tool in assistant.tools:\n",
      "                    self.assertTrue(tool.type == \"function\")\n",
      "                    self.assertTrue(tool.function.name in [tool.__name__ for tool in agent.tools])\n",
      "                test_tool = next((tool for tool in assistant.tools if tool.function.name == \"TestTool\"), None)\n",
      "                self.assertTrue(test_tool.function.strict, test_tool)\n",
      "            elif agent.name == \"CEO\":\n",
      "                num_tools = 1 if not async_mode else 2\n",
      "                self.assertFalse(assistant.tool_resources.code_interpreter)\n",
      "                self.assertFalse(assistant.tool_resources.file_search)\n",
      "                self.assertTrue(len(assistant.tools) == num_tools)\n",
      "            else:\n",
      "                pass\n",
      "        except Exception as e:\n",
      "            print(\"Error checking agent settings \", agent.name)\n",
      "            raise e\n",
      "\n",
      "    def check_all_agents_settings(self, async_mode=False):\n",
      "        self.check_agent_settings(self.__class__.ceo, async_mode=async_mode)\n",
      "        self.check_agent_settings(self.__class__.agent1, async_mode=async_mode)\n",
      "        self.check_agent_settings(self.__class__.agent2, async_mode=async_mode)\n",
      "\n",
      "    @classmethod\n",
      "    def tearDownClass(cls):\n",
      "        shutil.rmtree(\"./test_agents\")\n",
      "        # os.remove(\"./settings.json\")\n",
      "        if cls.agency:\n",
      "            cls.agency.delete()\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n"
    ],
    "startline": 1,
    "endline": 608
  },
  {
    "path": "tests/test_tool_factory.py",
    "code": [
      "import asyncio\n",
      "from enum import Enum\n",
      "import json\n",
      "import os\n",
      "import sys\n",
      "import unittest\n",
      "from typing import List, Optional\n",
      "\n",
      "from pydantic import Field, BaseModel\n",
      "\n",
      "sys.path.insert(0, '../agency-swarm')\n",
      "from agency_swarm.tools import ToolFactory, BaseTool\n",
      "from agency_swarm.util.schema import dereference_schema, reference_schema\n",
      "from langchain.tools import MoveFileTool, YouTubeSearchTool\n",
      "\n",
      "from agency_swarm.util import get_openai_client\n",
      "\n",
      "\n",
      "class ToolFactoryTest(unittest.TestCase):\n",
      "    def setUp(self):\n",
      "        self.client = get_openai_client()\n",
      "\n",
      "    def test_move_file_tool(self):\n",
      "        tool = ToolFactory.from_langchain_tool(MoveFileTool())\n",
      "        print(json.dumps(tool.openai_schema, indent=4))\n",
      "        print(tool)\n",
      "\n",
      "        tool = tool(destination_path=\"Move a file from one folder to another\",\n",
      "                    source_path=\"Move a file from one folder to another\")\n",
      "\n",
      "        print(tool.model_dump())\n",
      "\n",
      "        tool.run()\n",
      "\n",
      "    def test_complex_schema(self):\n",
      "        class FriendDetail(BaseModel):\n",
      "            \"test 123\"\n",
      "            id: int = Field(..., description=\"Unique identifier for each friend.\")\n",
      "            name: str = Field(..., description=\"Name of the friend.\")\n",
      "            age: Optional[int] = Field(25, description=\"Age of the friend.\")\n",
      "            email: Optional[str] = Field(None, description=\"Email address of the friend.\")\n",
      "            is_active: Optional[bool] = Field(None, description=\"Indicates if the friend is currently active.\")\n",
      "\n",
      "        class UserDetail(BaseModel):\n",
      "            \"\"\"Hey this is a test?\"\"\"\n",
      "            id: int = Field(..., description=\"Unique identifier for each user.\")\n",
      "            age: int\n",
      "            name: str\n",
      "            friends: List[FriendDetail] = Field(...,\n",
      "                                                description=\"List of friends, each represented by a FriendDetail model.\")\n",
      "\n",
      "        class RelationshipType(Enum):\n",
      "            FAMILY = \"family\"\n",
      "            FRIEND = \"friend\"\n",
      "            COLLEAGUE = \"colleague\"\n",
      "\n",
      "        class UserRelationships(BaseTool):\n",
      "            \"\"\"Hey this is a test?\"\"\"\n",
      "            users: List[UserDetail] = Field(...,\n",
      "                                            description=\"Collection of users, correctly capturing the relationships among them.\", title=\"Users\")\n",
      "            relationship_type: RelationshipType = Field(..., description=\"Type of relationship among users.\", title=\"Relationship Type\")\n",
      "\n",
      "        print(\"schema\", json.dumps(UserRelationships.openai_schema, indent=4))\n",
      "\n",
      "        # print(\"ref\", json.dumps(reference_schema(deref_schema), indent=4))\n",
      "\n",
      "        tool = ToolFactory.from_openai_schema(UserRelationships.openai_schema, lambda x: x)\n",
      "\n",
      "        print(json.dumps(tool.openai_schema, indent=4))\n",
      "        user_detail_instance = {\n",
      "            \"id\": 1,\n",
      "            \"age\": 20,\n",
      "            \"name\": \"John Doe\",\n",
      "            \"friends\": [\n",
      "                {\n",
      "                    \"id\": 1,\n",
      "                    \"name\": \"Jane Doe\"\n",
      "                }\n",
      "            ]\n",
      "        }\n",
      "        user_relationships_instance = {\n",
      "            \"users\": [user_detail_instance],\n",
      "            \"relationship_type\": \"family\"\n",
      "        }\n",
      "        \n",
      "        #print user detail instance\n",
      "        tool = tool(**user_relationships_instance)\n",
      "\n",
      "        user_relationships_schema = UserRelationships.openai_schema\n",
      "\n",
      "        def remove_empty_fields(d):\n",
      "            \"\"\"\n",
      "            Recursively remove all empty fields from a dictionary.\n",
      "            \"\"\"\n",
      "            if not isinstance(d, dict):\n",
      "                return d\n",
      "            return {k: remove_empty_fields(v) for k, v in d.items() if v not in [{}, [], '']}\n",
      "\n",
      "        cleaned_schema = remove_empty_fields(user_relationships_schema)\n",
      "\n",
      "        print(\"clean schema\", json.dumps(cleaned_schema, indent=4))\n",
      "\n",
      "        print(\"tool schema\", json.dumps(tool.openai_schema, indent=4))\n",
      "\n",
      "        tool_schema = tool.openai_schema\n",
      "\n",
      "        assert cleaned_schema == tool_schema\n",
      "\n",
      "    def test_youtube_search_tool(self):\n",
      "        # requires pip install youtube_search to run\n",
      "        ToolFactory.from_langchain_tool(YouTubeSearchTool)\n",
      "\n",
      "    def test_custom_tool(self):\n",
      "        schema = {\n",
      "            \"name\": \"query_database\",\n",
      "            \"description\": \"Use this funciton to query the database that provides insights about the interests of different family and household segments and describes various aspects of demographic data. It also contains advertising data, offering insights into various channels and platforms to provide a granular view of advertising performance. Use when you don't already have enough information to answer the user's question based on your previous responses.\",\n",
      "            \"parameters\": {\n",
      "                \"type\": \"object\",\n",
      "                \"properties\": {\n",
      "                    \"query\": {\n",
      "                        \"type\": \"string\",\n",
      "                        \"description\": \"Query to the demographic database. Must be clearly stated in natural language.\",\n",
      "                    },\n",
      "                },\n",
      "                \"required\": [\"query\"],\n",
      "            },\n",
      "            \"strict\": False\n",
      "        }\n",
      "\n",
      "        tool = ToolFactory.from_openai_schema(schema, lambda x: x)\n",
      "\n",
      "        schema['strict'] = True\n",
      "\n",
      "        tool2 = ToolFactory.from_openai_schema(schema, lambda x: x)\n",
      "\n",
      "        print(json.dumps(tool.openai_schema, indent=4))\n",
      "\n",
      "        tool = tool(query=\"John Doe\")\n",
      "\n",
      "        print(tool.model_dump())\n",
      "\n",
      "        self.assertFalse(tool.openai_schema.get(\"strict\", False))\n",
      "\n",
      "        tool.run()\n",
      "\n",
      "        self.assertTrue(tool2.openai_schema[\"strict\"])\n",
      "\n",
      "    def test_get_weather_openapi(self):\n",
      "        with open(\"./data/schemas/get-weather.json\", \"r\") as f:\n",
      "            tools = ToolFactory.from_openapi_schema(f.read())\n",
      "\n",
      "        self.assertFalse(tools[0].openai_schema.get(\"strict\", False))\n",
      "\n",
      "        print(json.dumps(tools[0].openai_schema, indent=4))\n",
      "\n",
      "    def test_relevance_openapi_schema(self):\n",
      "        with open(\"./data/schemas/relevance.json\", \"r\") as f:\n",
      "            tools = ToolFactory.from_openapi_schema(f.read(), {\n",
      "                \"Authorization\": os.environ.get(\"TEST_SCHEMA_API_KEY\")\n",
      "            })\n",
      "\n",
      "        print(json.dumps(tools[0].openai_schema, indent=4))\n",
      "\n",
      "        async def gather_output():\n",
      "            output = await tools[0](requestBody={\"text\": 'test'}).run()\n",
      "            return output\n",
      "\n",
      "        output = asyncio.run(gather_output())\n",
      "\n",
      "        print(output)\n",
      "\n",
      "        assert output['output']['transformed']['data'] == 'test complete.'\n",
      "\n",
      "    def test_get_headers_openapi_schema(self):\n",
      "        with open(\"./data/schemas/get-headers-params.json\", \"r\") as f:\n",
      "            tools = ToolFactory.from_openapi_schema(f.read(),{\n",
      "                \"Bearer\": os.environ.get(\"GET_HEADERS_SCHEMA_API_KEY\")\n",
      "            })\n",
      "\n",
      "        async def gather_output():\n",
      "            output = await tools[0](parameters={\"domain\": \"print-headers\", \"query\": \"test\"}).run()\n",
      "            return output\n",
      "\n",
      "        output = asyncio.run(gather_output())\n",
      "\n",
      "        self.assertTrue(\"headers\" in output)\n",
      "\n",
      "        print(output)\n",
      "\n",
      "    def test_ga4_openapi_schema(self):\n",
      "        with open(\"./data/schemas/ga4.json\", \"r\") as f:\n",
      "            tools = ToolFactory.from_openapi_schema(f.read(), {})\n",
      "\n",
      "        print(json.dumps(tools[0].openai_schema, indent=4))\n",
      "\n",
      "    def test_import_from_file(self):\n",
      "        tool = ToolFactory.from_file(\"./data/tools/ExampleTool1.py\")\n",
      "\n",
      "        print(tool)\n",
      "\n",
      "        self.assertTrue(tool.__name__ == \"ExampleTool1\")\n",
      "\n",
      "        self.assertTrue(tool(content='test').run() == \"Tool output\")\n",
      "\n",
      "    # def test_openapi_schema(self):\n",
      "    #     with open(\"./data/schemas/get-headers-params.json\", \"r\") as f:\n",
      "    #         tools = ToolFactory.from_openapi_schema(f.read())\n",
      "\n",
      "    #     schema = ToolFactory.get_openapi_schema(tools, \"123\")\n",
      "\n",
      "    #     self.assertTrue(schema)\n",
      "\n",
      "\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n"
    ],
    "startline": 1,
    "endline": 217
  },
  {
    "path": "tests/__init__.py",
    "code": [],
    "startline": 1,
    "endline": 0
  },
  {
    "path": "tests/data/tools/ExampleTool1.py",
    "code": [
      "from agency_swarm.tools import BaseTool\n",
      "from pydantic import Field\n",
      "\n",
      "\n",
      "class ExampleTool1(BaseTool):\n",
      "    \"\"\"Enter your tool description here. It should be informative for the Agent.\"\"\"\n",
      "    content: str = Field(\n",
      "        ..., description=\"Enter parameter descriptions using pydantic for the model here.\"\n",
      "    )\n",
      "\n",
      "    def run(self):\n",
      "        # Enter your tool code here. It should return a string.\n",
      "\n",
      "        # do_something(self.content)\n",
      "\n",
      "        return \"Tool output\""
    ],
    "startline": 1,
    "endline": 16
  },
  {
    "path": "tests/demos/demo_gradio.py",
    "code": [
      "import sys\n",
      "\n",
      "import gradio as gr\n",
      "\n",
      "sys.path.insert(0, './agency-swarm')\n",
      "\n",
      "from agency_swarm import set_openai_key, Agent\n",
      "\n",
      "from agency_swarm.agency.agency import Agency\n",
      "from agency_swarm.tools.oai import FileSearch, CodeInterpreter\n",
      "from agency_swarm.tools.BaseTool import BaseTool\n",
      "\n",
      "class PrintTool(BaseTool):\n",
      "    def run(self, **kwargs):\n",
      "        print(\"This is a test tool from BaseTool.\")\n",
      "        return \"Printed successfully.\"\n",
      "\n",
      "class AnotherPrintTool(BaseTool):\n",
      "    def run(self, **kwargs):\n",
      "        print(\"This is another test tool from BaseTool.\")\n",
      "        return \"Another print successful.\"\n",
      "\n",
      "ceo = Agent(name=\"CEO\",\n",
      "            description=\"Responsible for client communication, task planning and management.\",\n",
      "            instructions=\"Analyze uploaded files with myfiles_browser tool.\", # can be a file like ./instructions.md\n",
      "            tools=[FileSearch, CodeInterpreter, PrintTool, AnotherPrintTool], \n",
      "            file_search={'max_num_results': 50})\n",
      "\n",
      "\n",
      "test_agent = Agent(name=\"Test Agent1\",\n",
      "                     description=\"Responsible for testing.\",\n",
      "                     instructions=\"Read files with myfiles_browser tool.\", # can be a file like ./instructions.md\n",
      "                     tools=[FileSearch])\n",
      "\n",
      "test_agent2 = Agent(name=\"Test Agent2\",\n",
      "                     description=\"Responsible for testing.\",\n",
      "                     instructions=\"Read files with myfiles_browser tool.\", # can be a file like ./instructions.md\n",
      "                     tools=[FileSearch])\n",
      "\n",
      "\n",
      "\n",
      "agency = Agency([\n",
      "    ceo, [ceo, test_agent, test_agent2],\n",
      "], shared_instructions=\"\", async_tool_calls=False)\n",
      "\n",
      "# agency.demo_gradio()\n",
      "\n",
      "print(agency.get_completion(\"Use 2 print tools\", yield_messages=False))\n",
      "\n"
    ],
    "startline": 1,
    "endline": 49
  },
  {
    "path": "tests/demos/streaming_demo.py",
    "code": [
      "import sys\n",
      "import time\n",
      "import unittest\n",
      "\n",
      "from agency_swarm import Agent, BaseTool\n",
      "from agency_swarm.agency.agency import Agency\n",
      "\n",
      "sys.path.insert(0, '../agency-swarm')\n",
      "\n",
      "\n",
      "class StreamingTest(unittest.TestCase):\n",
      "    def setUp(self):\n",
      "        class TestTool(BaseTool):\n",
      "            def run(self):\n",
      "                time.sleep(10)\n",
      "                print('done')\n",
      "                return \"Test Successful\"\n",
      "\n",
      "        self.ceo = Agent(name=\"ceo\", instructions=\"You are a CEO of an agency made for testing purposes.\",\n",
      "                         model='gpt-3.5-turbo')\n",
      "        self.test_agent1 = Agent(name=\"test_agent1\", tools=[TestTool], model='gpt-3.5-turbo')\n",
      "        self.test_agent2 = Agent(name=\"test_agent2\", model='gpt-3.5-turbo')\n",
      "\n",
      "        self.agency = Agency([\n",
      "            self.ceo,\n",
      "            [self.ceo, self.test_agent1, self.test_agent2],\n",
      "            [self.ceo, self.test_agent2]\n",
      "        ])\n",
      "\n",
      "    def test_demo(self):\n",
      "        self.agency.demo_gradio()\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n"
    ],
    "startline": 1,
    "endline": 35
  },
  {
    "path": "tests/demos/term_demo.py",
    "code": [
      "import sys\n",
      "import unittest\n",
      "\n",
      "from agency_swarm import set_openai_key\n",
      "from agency_swarm.agency.agency import Agency\n",
      "from agency_swarm.threads import Thread\n",
      "from tests.ceo.ceo import Ceo\n",
      "from .test_agent.test_agent import TestAgent\n",
      "from .test_agent2.test_agent2 import TestAgent2\n",
      "\n",
      "sys.path.insert(0, '../agency-swarm')\n",
      "import json\n",
      "\n",
      "\n",
      "class MyTestCase(unittest.TestCase):\n",
      "    def setUp(self):\n",
      "        self.test_agent1 = TestAgent()\n",
      "        self.test_agent2 = TestAgent2()\n",
      "        self.ceo = Ceo()\n",
      "\n",
      "        self.agency = Agency([\n",
      "            self.ceo,\n",
      "            [self.ceo, self.test_agent1, self.test_agent2],\n",
      "            [self.ceo, self.test_agent2]\n",
      "        ])\n",
      "\n",
      "        def custom_serializer(obj):\n",
      "            if isinstance(obj, Thread):\n",
      "                return {\"agent\": obj.agent.name, \"recipient_agent\": obj.recipient_agent.name}\n",
      "            # You can add more types here if needed\n",
      "            raise TypeError(f\"Type {type(obj)} not serializable\")\n",
      "\n",
      "        print(json.dumps(self.agency.agents_and_threads, indent=4, default=custom_serializer))\n",
      "\n",
      "        print(\"Ceo Tools: \", self.agency.ceo.tools)\n",
      "\n",
      "    def test_demo(self):\n",
      "        self.agency.run_demo()\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n"
    ],
    "startline": 1,
    "endline": 42
  },
  {
    "path": "tests/demos/__init__.py",
    "code": [],
    "startline": 1,
    "endline": 0
  }
]